

## 环境准备

```shell
# kernel-package: utility for building Linux kernel
sudo apt-get install build-essential  bison flex autoconf automake kernel-package libncurses5-dev libssl-dev
# download kernel source with version same as the system
$ uname -r
5.11.0-27-generic
$ apt-cache search linux-source
linux-source - Linux kernel source with Ubuntu patches
linux-source-5.4.0 - Linux kernel source for version 5.4.0 with Ubuntu patches
linux-gkeop-source-5.4.0 - Linux kernel source for version 5.4.0 with Ubuntu patches
linux-hwe-5.11-source-5.11.0 - Linux kernel source for version 5.11.0 with Ubuntu patches
linux-hwe-5.8-source-5.8.0 - Linux kernel source for version 5.8.0 with Ubuntu patches

# will generate /lib/modules/5.11.0-27-generic/build -> /usr/src/linux-headers-5.11.0-27-generic
$ sudo apt-get install linux-hwe-5.11-source-5.11.0

sudo make oldconfig
sudo make
# 生成和构建设备树 $make modules, $make modules_install两条指令
make modules
make modules_install
```
### sample1
测试程序: `~/Documents$ cat test.c`
```c++
//~/Documents$ cat test.c
// printk 打印内容通过dmesg 查看
#include <linux/init.h>
#include <linux/module.h>

static unsigned int panel_type = 6;


MODULE_LICENSE("GPL");
static int test_init(void) {
    printk(KERN_EMERG "hello: %d", panel_type);
    return 0;
}

static void test_exit(void) {
    printk(KERN_ALERT "goodbye");
}

module_init(test_init);
module_exit(test_exit);

// 演示使用module parameter， insmod test.ko panel_type=97
module_param(panel_type/*参数名*/, uint/*参数类型*/, S_IRUGO | S_IWUSR/*参数读写权限*/);
MODULE_PARM_DESC(panel_type, "Select the panel type: 37, 6, 97");

```

测试程序对应编译脚本： `~/Documents$ cat Makefile `
```makefile
# KERNELRELEASE是在内核源码的顶层Makefile中定义的一个变量，在第一次读取执行此Makefile时，KERNELRELEASE没有被定义，
# 所以make将读取执行else之后的内容，如果make的目标是clean，直接执行clean操作，然后结束。
# 当make的目标为all时，-C $(KDIR)指明跳转到内核源码目录下读取那里的Makefile；M=$(PWD) 表明然后
# 返回到当前目录继续读入、执行当前的Makefile。当从内核源码目录返回时，KERNELRELEASE已被定义，
# kbuild也被启动去解析kbuild语法的语句，make将继续读取else之前的内容。else之前的内容为kbuild语法
# 的语句，指明模块源码中各文件的依赖关系，以及要生成的目标模块名。param-objs := file1.o file2.o 
# 表示param.o由file1.o与file2.o 连接生成，obj-m := param.o表示编译连接后将生成param.o模块。


# 避免错误：module verification failed: signature and/or required key missing - tainting kernel
CONFIG_MODULE_SIG=n

ifneq ($(KERNELRELEASE),)

# obj-m表示把文件test.o作为"模块"进行编译，不会编译到内核，但是会生成一个独立的 "test.ko" 文件；
# obj-y表示把test.o文件编译进内核;
obj-m := test.o

else
PWD:=$(shell pwd)
KVER?=$(shell uname -r)
KDIR:=/lib/modules/$(KVER)/build

## Use make M=dir or set the environment variable KBUILD_EXTMOD to 
## specify the directory of external module to build. Setting M= takes precedence.

modules:
	make -C $(KDIR) M=$(PWD) modules
clean:
	rm -f *.ko *.o *.mod.o *.mod.c *.symvers

endif
```


加载/卸载：
```shell
# or sudo modprobe test.ko
$ sudo insmod test.ko
$ lsmod |grep test
test                   16384  0
# query modle info in sysfs
$ tree  /sys/module/test/
/sys/module/test/
├── coresize
├── holders
├── initsize
├── initstate
├── notes
├── parameters
│   └── panel_type
├── refcnt
├── sections
│   ├── __mcount_loc
│   └── __param
├── srcversion
├── taint
└── uevent

# or sudo modprobe -r test
$ sudo rmmod test
$ lsmod |grep test
$
```

### sample2: sample1 + platform
封装为platform_driver. 加载后，将会在发现新增了“/sys/bus/platform/drivers/xxxxx”

```c++
#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>

static unsigned int panel_type = 6;


MODULE_LICENSE("GPL");
static int test_init(struct platform_device *pdev) {
	    printk(KERN_EMERG "hello: %d", panel_type);
	        return 0;
}


static int test_exit(struct platform_device *pdev) {
    printk(KERN_ALERT "goodbye");
    return 0;
}
module_param(panel_type/*参数名*/, uint/*参数类型*/, S_IRUGO | S_IWUSR/*参数读写权限*/);

//module_init(test_init);
//module_exit(test_exit);
static struct platform_driver xxx_driver={
		.driver = {
			.name = "xxxxx",
			.owner= THIS_MODULE,
			},
        .probe = test_init,
		.remove= test_exit,
};
module_platform_driver(xxx_driver);
// builtin_platform_driver
```

注： module_platform_driver是一个宏，如果不想使用该宏，而是想采用传统格式module_init/module_exit来书写platform_driver, “drivers/tty/serial/stm32-usart.c” 提供了一个范例。

```shell
# query modle info in sysfs
$ tree  /sys/module/test/
test/
├── coresize
├── drivers
│   └── platform:xxxxx -> ../../../bus/platform/drivers/xxxxx
├── holders
├── initsize
├── initstate
├── notes
├── parameters
│   └── panel_type
├── refcnt
├── sections
│   ├── __mcount_loc
│   └── __param
├── srcversion
├── taint
└── uevent
```

## 基本概念

内核下的`Documentation/CodingStyle` 描述了Linux 内核对编码风格的要求，内核下的`scripts/checkpatch.pl` 提供了1 个检查代码风格的脚本。

### 应用程序 与设备驱动

应用程序和 VFS 之间的接口是系统调用． 而VFS与文件系统以及设备文件之间的接口是自file_operations 结构体成员函数．这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数．
```text
          系统调用            file_opertion
应用程序 -------------> VFS -------------------> 设备驱动 -------->  硬件
```

###  devfs vs  udev

使用devfs， 驱动在设备初始化时在`/dev`目录下创建设备文件，显然如果采用devfs，当打开一个并不存在的`/dev/节点`，devfs会自动加载对应的驱动。 注意它们已经在3.26以后的内核被废弃， udev取代了devfs：
```c++
/* 创建设备目录*/
devfs_handle_t devfs_mk_dir(devfs_handle_t dir, const char *name, void *info);
/* 创建设备文件*/
devfs_handle_t devfs_register(devfs_handle_t dir, const char *name, unsigned int flags,
                              unsigned int major, unsigned int minor, umde_t mode,
                              void * ops, void *info);
/* 撤销设备文件*/
void devfs_unregister(devfs_handle_t de);
```

相反，udev思想是应该在设备被发现时加载驱动模块。系统中所有的设备都应该产生热插拔事件并加载恰当的驱动．而udev 能注意到这点并且为它创建对应的的设备节点。
udev 完全在用户态工作，利用设备加入或移除时内核所发送的热插拔 netlink事件来工作。
```shell
$ ps -aux | grep udev
root         431  0.0  0.0  24168  7684 ?        Ss   8月30   0:00 /lib/systemd/systemd-udevd
```
对于在udev启动前，开机时已经存在的冷插拔设备，如果没有特别处理，udev就会漏掉它们的事件。 为解决这个我问题。linux内核提供了sysfs下面的一个uevent节点（例如 `/sys/module/psmouse/uevent`）,在该节点中增加"add",会导致内核重新发送冷插拔的netlink事件

udev的配置文件位于 `/etc/udev/ 和 /lib/udev/ `. udev的规则文件一般位于 `/lib/udev/rules.d/`，也可以位于  `/etc/udev/rules.d/`。规则文件是按照字母顺序处理的，不管放在哪个目录。对于相同名字的规则文件， /etc/udev/rules.d 比  /lib/udev/rules.d 优先。



### sysfs与procfs

内核的结构化设备模型在用户空间就称为sysfs 。与procfs类似。sysfs 虚拟文件系统提供了一种比 proc 更为理想的访问内核数据的途径。新设计的内核机制应该尽量使用 sysfs 机制，而将 proc 保留给纯净的“进程文件系统”。

sysfs 文件系统总是被挂载在 /sys 挂载点上。

[使用 /sys 文件系统访问 Linux 内核](https://blog.csdn.net/halazi100/article/details/39961467)

在Linux 内核中． 设备和驱动是分开注册的. 注册1个设备的时候． 并不需要驱动已经存在．而l个驱动被注册的时候． 也不需要对应的设备设备已经被注册。设备和驱动各自涌向内核；而每个设备和驱动涌入内核的时候，都会去寻找自己的另一半．而正是bus_type 的match（）成员函数将两者捆绑在一起。简单地说．设备和驱动就是红尘中漂浮的男女，而bus_type的malch（）则是牵引红线的月老．它可以识别什么设备与什么驱动是可以配对的。一旦配对成功，xxx_driver的probe()就会被执行, xxx是总线名，例如platform,pci,i2c,spi,usb...

### DTS （device tree source）

document： `/usr/src/linux-source/Documentation/devicetree`



## 字符设备： 顺序存取设备数据

比如时钟/磁带，打印件, 没有和任何物理硬件相连接但需要顺序访问的伪字符设备...

```shell
# c表示字符设备驱动程序， b表示块设备驱动程序， l表示符号链接
$ ls -lh  /dev
total 0
crw-r--r--  1 root root     10, 235 8月  30 09:17 autofs
drwxr-xr-x  2 root root         480 8月  30 09:18 block
...
```

字符驱动程序并不仅仅在`drivers/char/`目录下 。下面是一些“超级”字符驱动程序的例子，它们受到特别的对待，其目录位置也很特殊。
- 串行驱动程序是管理计算机串行端口的字符驱动程序． 然而，它们不仅仅是简单的字符驱动程序，因此被放在`drivers/serial/` 目录下．
- 输入驱动程序负责像键盘、鼠标和操纵杆这样的设备。它们位于单独的源文件目录：`drivers/input/`。
- 帧缓冲区(`/dev/fb*`)提供对显存的访问， `/dev/mem` 提供对系统内存的访问途径。
- －些设备类支持少量采用字符接口的硬件。例如SCSI设备一般是块设备，但SCSI磁带是字符设备。
- 一些内核层提供钩子，通过导出相应的字符接口实现用户空间的设备驱动程序。例如  `drivers/scsi/sg.c, i2c-dev`

关键数据结构: `struct cdev`, struct file_operations

linux内核操作`struct cdev`的函数：
```c++
/* 初始化cdev成员，并建立cdev与file_operations之间的连接*/
void cdev_init(struct cdev *, struct file_operations *);
struct cdev *cdev_alloc();
void cdev_put(struct cdev *p);
/* 向系统添加/删除一个cdev，完成字符设备的注册/注销*/
int cdev_add(struct cdev*, dev_t, unsigned);
void cdev_del(struct cdev*);
```
注意，在调用`cdev_add`前，应首先调用`register_chrdev_region or alloc_chrdev_region`向系统申请设备号。
注意，在调用`cdev_del`后，应调用`unregister_chrdev_region`向系统释放原来申请的设备号。

下面的例子，演示了一个简单的字符设备驱动加载/卸载
```c++
static int major;		/* default to dynamic major */
module_param(major, int, 0);
MODULE_PARM_DESC(major, "Major device number");

struct xxx_dev_t {
	struct cdev  cdev;
	...
} 
static xxx_dev_t xxx_dev;

dev_t devid;
static int xxx_init(void){
    ...
	if (major) {
		devid = MKDEV(major, 0);
		rc = register_chrdev_region(devid, 1, DEVNAME);
	} else {
		rc = alloc_chrdev_region(&devid, 0, 1, DEVNAME);
		major = MAJOR(devid);
	}

	/* ignore minor errs, and succeed */
	cdev_init(&xxx_dev.cdev, &xxx_fileops);
	cdev_add(&xxx_dev.cdev, devid, 1);
    ...
};
static void xxx_exit(){
    unregister_chrdev_region(devid, 1);
    cdev_del(&xxx_dev.cdev);
}

module_init(xxx_init);
module_exit(xxx_exit);
```

## platform 设备驱动

在Linux 2.6 以后的设备驱动模型中，需要关心： 总线/设备/驱动这三个实体． 总线将设备和驱动绑定。在系统每注册一个设备的时候． 会寻找与之匹配的驱动． 相反的，在系统每位注册一个驱动的时候． 会寻找与之匹配的设备． 而匹配由总线完成。

但是在SOC系统中，通常外设都是挂接在SOC内存空间，它们本身并不依附于类似PCI/USB/SPI/I2C..., 基于此，linux发明了一种虚拟的总线，称为platform总线，相应设备称为platform_device, 而驱动称为platform_driver.

“platform”这个概念专门为嵌入式引入。 注意所谓platform_device 并不是于字符设备/块设备/网络设备...等并列的概念。而只是一种附加的手段。

与platform_driver 地位对等的是： i2c_driver，spi_driver, usb_driver, pci_driver

通过platform_bus_type的定义可以知道， 设备和驱动的匹配是由platform_match完成的。
```c++
struct bus_type platform_bus_type = {
	.name		= "platform",
	.dev_groups	= platform_dev_groups,
	.match		= platform_match,
	.uevent		= platform_uevent,
	.dma_configure	= platform_dma_configure,
	.pm		= &platform_dev_pm_ops,
};
EXPORT_SYMBOL_GPL(platform_bus_type);
```
这个platform_match匹配有[四种方式](https://www.cnblogs.com/zhuangquan/p/12877244.html)：
```c++
static int platform_match(struct device *dev, struct device_driver *drv)
{
	...
	/* Attempt an OF style match first */
	if (of_driver_match_device(dev, drv))
		return 1;

	/* Then try ACPI style match */
	if (acpi_driver_match_device(dev, drv))
		return 1;

	/* Then try to match against the id table */
	if (pdrv->id_table)
		return platform_match_id(pdrv->id_table, pdev) != NULL;

	/* fall-back to driver name match */
	return (strcmp(pdev->name, drv->name) == 0);
}
```

为了不同的匹配支持，下面演示了怎么构建platform_driver：
```c++
static struct platform_driver  xxxx_driver = {
	.driver = {
		.name = ???,
		.owner = THIS_MODULE,
		/* to support OF style match*/
		.of_match_table = of_match_ptr(xxxx_of_matches),
		/* to support acpi style match*/
		// .acpi_match_table = ??
	},
	/* to support id table style match*/
	// .id_table = ??,
	.probe  = ???,
	.remove = ???
}
```



### 提供platform驱动
将一个驱动更改为platform驱动，在“环境准备”中提供了一个例子，这里有点需要注意的是，因为有了“struct platform_device *pdev”输入，所以建议做设备关联的malloc， 如下面：
更改的核心就是更改注册，同时有个小改动就是将
```c++
struct xxx_dev_t {
	struct cdev  cdev;
	...
} *xxx_devp;

static int xxx_init(struct platform_device *pdev){
	xxx_devp = devm_kzalloc(&pdev-dev, sizeof(xxx_dev_t));
    ...
};
// static void xxx_exit(void){
static int xxx_exit(struct platform_device *pdev){
	(VOID)pdev; // 不需要使用
	//改为操纵 xxx_devp->cdev
    ...
	return 0;
}
...
```

### 增加platform 设备

要将一个设备让内核以platform设备对待，增加这个设备时，有两种方式，一种是将该设备在板文件中硬编码增加；一种是通过设备树提供必要的信息告知内核。

方式1：
在"arch/arm/mach-xxx/板文件"中硬编码增加。 这会使得在“`/sys/devices/platform`”目录下增加一个同名的子目录
```c++
static struct platform_device bast_device_ide1 = {
	.name		= "xxxxx",
	.id		= 1,	
	}
};

platform_add_devices(&bast_device_ide1,1);
```

方式2：
在内核，是通过内核函数of_platform_default_populate_init, 遍历device_node树, 生成platform_device。这个函数对会满足以下条件的节点会处理为platform_device:
- b. 并非所有的device_node都会转换为platform_device只有以下的device_node会转换:
  - b.1 该节点必须含有compatible属性
  - b.2 根节点的子节点(节点必须含有compatible属性)
  - b.3 含有特殊compatible属性的节点的子节点(子节点必须含有compatible属性):
- 这些特殊的compatilbe属性为: “simple-bus”,“simple-mfd”,“isa”,"arm,amba-bus "
- 根节点是例外的，生成platfrom_device时，即使有compatible属性也不会处理

具体见“drivers/of/platform.c”中下面代码：
```c++
const struct of_device_id of_default_bus_match_table[] = {
	{ .compatible = "simple-bus", },
	{ .compatible = "simple-mfd", },
	{ .compatible = "isa", },
#ifdef CONFIG_ARM_AMBA
	{ .compatible = "arm,amba-bus", },
#endif /* CONFIG_ARM_AMBA */
	{} /* Empty terminated list */
};
```

对i2c/spi 总线设备，也会默认创建platorm 设备，具体见下面例子说明。
```c++
/{
   /* /mytest会被转换为platform_device,因为它兼容"simple-bus", 
      它的子节点/mytest/mytest@0 也会被转换为platform_device */	
   mytest{
       compatile = "mytest", "simple-bus";
	   mytest@0{
		   compatile = "mytest_0";
		   reg = <0>;
	   };
   };
   /* /i2c节点一般表示i2c控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;
      /i2c/at24c02节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 
	  一般是被创建为一个i2c_client。*/
   i2c{
	   compatile = "samsung, i2c";
	   at24c02 {
		   compatile = "at24c02";
	   };
   };
   /* 类似的也有/spi节点, 它一般也是用来表示SPI控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;
   /spi/flash@0节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个spi_device。*/
   spi{
	   compatile = "samsung, spi";
	   flash@0 {
		   compatile = "winbond,w25q32dw";
		   reg = <0>;
	   };
   };
};
```

###  platform设备 与platform驱动的匹配

在前面章节中，已经描述了如何让内核将某个设备当作platform_device对待，以及怎么让一个驱动称为platform_driver。 在该前提下，我们下面描述platform设备与platform驱动的匹配。

在设备树中的“compatible”属性，通过它来与驱动关联。 

下面描述了设备驱动中如何使用“compatible”来与设备关联，也称为OF style match方法：

```c++
static const struct of_device_id  xxxx_of_matches[] = {
   {.compatible = "davicom,dm9000",},
   {}
};

static struct platform_driver  xxxx_driver = {
	.driver = {
		.name = ???,
		.owner = THIS_MODULE,
		/* to support OF style match*/
		.of_match_table = of_match_ptr(xxxx_of_matches),
	},
	.probe  = ???,
	.remove = ???
}
```

补充： 
- 如果使用DT，可以在probe中增加类似"`const struct of_device_id *match= of_match_device(xxxx_of_matches, &pdev->dev);`", 得到匹配的设备，从而对该匹配设备做写特殊的动作。另外不论是否采用了设备树，都可以在驱动中通过`platform_get_xx `去获取设备树里面的属性。
- 在驱动代码中，可以利用"`if (pdev->dev->of_node) {/*DT based instantiation*/} else {/*NON-DT based instantiation*/}`"识别做些动作。

## gpio子系统与pinctrl子系统

gpio子系统提供了：

- 读引脚值，高或者低

- 输出高低电平；

- 部分gpio还负责接收IRQ，涉及irqchip子系统；

pinctrl子系统提供了：

- 引脚复用，大多数引脚都可以通过配置寄存器来选择复用成不同的功能，例如某个引脚即可用作为普通的gpio，也可以作为UART的TX；

- 引脚配置，一般包括上下拉、驱动能力等；


Sometimes shared signals need to use 
- "open drain" ： where only the low signal level is actually driven), or 
- "open source" ： where only the high signal level is driven  signaling. 
- 
A pullup or pulldown resistor causes the high or low signal level. This is sometimes called a "wire-AND"; or more practically, from the negative
logic (low=true) perspective this is a "wire-OR".

- open-drain(漏极开路输出) : 相当于集电极开路(open-collector)输出，即ttl中的集电极开路（oc）输出。一般用于线或、线与，也有的用于电流驱动。open-drain是对mos管而言，open-collector是对双极型管(TTL)而言，在用法上没啥区别。

- "wire-OR"(线或) : 接下拉电阻至地。(~A)+(~B)=~(AB);
- "wire-AND"(线与): 接上拉电阻至电源。(~A)&(~B)=~(A+B)


- `#include <linux/gpio/consumer.h>` :All the functions that work with the descriptor-based GPIO interface are prefixed with gpiod_. The gpio_ prefix is used for the legacy interface. 

### 使用GPIO

documents/gpio/consumer.txt

函数名均是`gpiod_xxx`的。 内核中操作gpio的地方都是要调用该类接口。

- 通过"gpiod_get*()"初始化并获取gpio handle：
	```c++
	    /*
		*flags sample:
		* GPIOD_ASIS or 0 to not initialize the GPIO at all. The direction must be set
		* later with one of the dedicated functions.
        * GPIOD_IN to initialize the GPIO as input.
        * GPIOD_OUT_LOW to initialize the GPIO as output with a value of 0.
        * GPIOD_OUT_HIGH to initialize the GPIO as output with a value of 1.*/
		struct gpio_desc *gpiod_get(struct device *dev, const char *con_id,
						enum gpiod_flags flags);
	    /*If a function is implemented by using several GPIOs together (e.g. a simple LED
	      device that displays digits), an additional index argument can be specified:*/
		struct gpio_desc *gpiod_get_index(struct device *dev,
						const char *con_id, unsigned int idx,
						enum gpiod_flags flags);
        还有其他...						
	```

- 通过"gpiod_direction_*()" 设置方向，如果已经通过"gpiod_get*()"设置了方向，也可以省略:
	```c++
	/* return value is zero for success, else a negative errno.*/
	int gpiod_direction_input(struct gpio_desc *desc)
	int gpiod_direction_output(struct gpio_desc *desc, int value)
	...
	/* return either GPIOF_DIR_IN or GPIOF_DIR_OUT.*/
	int gpiod_get_direction(const struct gpio_desc *desc);
    ```

-  access GPIOs from an atomic context:
	```c++
	/* The values are boolean, zero for low, nonzero for high.*/
	int gpiod_get_value(const struct gpio_desc *desc);
	void gpiod_set_value(struct gpio_desc *desc, int value);
	```

- 基于消息机制访问GPIO
	类似I2C/SPI等，Some GPIO controllers must be accessed using message based buses like I2C or
	SPI. Commands to read or write those GPIO values require waiting to get to the
	head of a queue to transmit a command and get its response. This requires
	sleeping, which can't be done from inside IRQ handlers.

	Accessing such GPIOs requires a context which may sleep, for example a threaded
	IRQ handler, and those accessors must be used instead of spinlock-safe
	accessors without the cansleep() name suffix.

	Other than the fact that these accessors might sleep, and will work on GPIOs
	that can't be accessed from hardIRQ handlers, these calls act the same as the
	spinlock-safe calls.

	```c++
	/* Platforms that support this type of GPIO distinguish them from other GPIOs by
	   returning nonzero from this call:*/
	int gpiod_cansleep(const struct gpio_desc *desc)

    /* To access such GPIOs, a different set of accessors is defined:
	*/
	int gpiod_get_value_cansleep(const struct gpio_desc *desc)
	void gpiod_set_value_cansleep(struct gpio_desc *desc, int value)
    ```

### GPIO驱动编写指南

documents/gpio/driver.txt
documentation/driver-api/pinctrl.rst

[和device tree或者machine driver相关的接口](http://www.wowotech.net/linux_kenrel/pin-control-subsystem.html)

- 编写gpio驱动，主要是：构造gpio_chip, 然后通过 gpiochip_add_data 注册它。

- 编写pinctrl驱动，主要： 构造struct pinctrl_desc用于表示一个pin控制器，然后通过`[devm_]pinctrl_register()`将其注册进pinctrl子系统；

	注：pinctrl是在linux 3.4引入的。



现在流行的编写方式是： 在设备树描述gpio信息，然后在pinctrl驱动里面顺便构造gpio_chip,并以gpiochip_add_data注册到gpio子系统。 参见“`drivers/pinctrl/stm32/pinctrl-stm32.c`”例子。

`#include<linux/gpio/driver.h>`

首先注意： 
- 在GPIO驱动程序中，各个GPIO通过其硬件编号（hardware number）进行标识，该hardware number永远不会在驱动程序外部可见。
- 除此之外，各个GPIO还需要有个全局编号(global number)进行标识，该global number = (base + hardware number); 其中base由内核自动分配

- RT_FULL: the GPIO driver should not use spinlock_t or any sleepable APIs (like PM runtime) in its gpio_chip implementation (.get/.set and direction
control callbacks) if it is expected to call GPIO APIs from atomic context on -RT (inside hard IRQ handlers and similar contexts). Normally this should
not be required.

- Requesting self-owned GPIO pins:

	有时候需要允许GPIO chip driver 使用GPIO description， 在这种情况下，可以使用下面的api，不过注意它们不会影响使用计数，并且它们只能在gpio chip driver自身内部使用

	```c++
	/*Descriptors requested with gpiochip_request_own_desc() must be released with
	  gpiochip_free_own_desc().*/
	struct gpio_desc *gpiochip_request_own_desc(struct gpio_desc *desc,
						    const char *label)   
	void gpiochip_free_own_desc(struct gpio_desc *desc)
	```



GPIO的内部表示

================================

，n是由管理的GPIO数

芯片。这个数字纯粹是内部的：特定设备的硬件编号



除此之外，每个GPIO中还需要有一个全局编号

整数GPIO命名空间，以便可以与旧GPIO一起使用

接口。因此，每个芯片必须有一个“基本”编号（可以自动

对于每个GPIO，全局编号为（基本+硬件编号）。

尽管整数表示法被认为是不推荐使用的，但它仍然有许多优点

用户，因此需要维护。

例如，一个平台可以将数字32-159用于GPIO，并使用

以32为“基数”定义128 GPIO的控制器；而另一个平台使用

数字0..63带有一组GPIO控制器，64-79带有另一种类型的GPIO控制器

控制器，并在一个特定的板80-95与FPGA。这些数字不需要

相邻；这两个平台中的任何一个都可以使用数字2000-2063来

识别I2C GPIO扩展器组中的GPIO。

控制器驱动程序：gpio_芯片



## 模块调试

21

第6章讲解了两种设备： 一个PC衍生器件上的触摸控制器和一个手机上的UART 。第8章则讲解了PC系统中的EEPROM和嵌入式设备中的实时钟。

第21章讨论了设备驱动秤，序的调试技术，开·扯驱动程序的时候，提前阅读该章会很有用。

[USB厂家ID](http://www.linux-usb.org/usb.ids)

## 操作系统是如何知道硬件参数的

[发现新硬件的前前后后](https://www.docin.com/p-1291428941.html)

作者：子者阳生之初
链接：https://www.zhihu.com/question/389774365/answer/1578725483
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

IBM、Sun等厂家的服务器最初都在硬件设备中嵌入了相应的程序，称为固件(Firmware)，用于初始化系统配置，提供操作系统软件和硬件之间的接口，启动和运行系统。
后来为了标准化和兼容性，IBM、Sun等联合推出了固件接口IEEE 1275标准，让他们的服务器如IBM PowerPC pSeries，Apple PowerPC，Sun SPARC等均采用Open Firmware，在运行时构建系统硬件的设备树信息传递给内核，进行系统的启动运行。

这样做的好处有，减少内核对系统硬件的严重依赖，利于加速支持包的开发，降低硬件带来的变化需求和成本，降低对内核设计和编译的要求。随着Linux内核的发展，在内核代码中引入了Open Firmware API以使用标准固件接口。在嵌入式PowerPC中，一般使用U-Boot之类的系统引导代码，而不采用Open Firmware。

早期的U-Boot使用include/asm-ppc/u-boot.h中的静态数据结构struct bd_t将板子基本信息传递给内核。这样的接口不够灵活，硬件发生变化就需要重新定制编译烧写引导代码和内核，而且也不再适应于现在的内核。为了适应内核的发展及嵌入式PowerPC平台的千变万化，吸收标准Open Firmware的优点，U-Boot引入了扁平设备树FDT这样的动态接口，使用一个单独的FDT blob存储传递给内核的参数。一些确定信息，例如cache大小、中断路由等直接由设备树提供，而其他的信息，例如eTSEC的MAC地址、频率、PCI总线数目等由U-Boot在运行时修改。从上述描述来看，首先要了解设备树的相关知识。在Linux 2.6中，ARM架构的板极硬件细节过多地被硬编码在arch/arm/plat-xxx和arch/arm/mach-xxx，比如板上的platform设备、 resource、i2c_board_info、spi_board_info以及各种硬件的platform_data，这些板级细节代码对内核来讲只不过是垃圾代码。 而采用Device Tree后，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。……（后来）ARM SOC board specific的代码被移除，由DeviceTree机制来负责传递硬件拓扑和硬件资源信息。本质上，Device Tree改变了原来用hardcode方式将HW 配置信息嵌入到内核代码的方法，改用bootloader传递一个DB的形式。

如果我们认为kernel是一个black box，那么其输入参数应该包括：

- 1. 识别platform的信息
- 2. runtime的配置参数
- 3. 设备的拓扑结构以及特性对于嵌入式系统，在系统启动阶段，bootloader会加载内核并将控制权转交给内核，此外， 还需要把上述的三个参数信息传递给kernel，以便kernel可以有较大的灵活性。
 
在linux kernel中，Device Tree的设计目标就是如此。……Device Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性， 其实就是成对出现的name和value。在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）：

- o CPU的数量和类别
- o 内存基地址和大小
- o 总线和桥o 外设连接
- o 中断控制器和中断使用情况
- o GPIO控制器和GPIO使用情况
- o Clock控制器和Clock使用情况
 
它基本上就是画一棵电路板上CPU、总线、设备组成的树，Bootloader会将这棵树传递给内核，然后内核可以识别这棵树， 并根据它展开出Linux内核中的platform_device、i2c_client、spi_device等设备，而这些设备用到的内存、IRQ等资源， 也被传递给了内核，内核会将这些资源绑定给展开的相应的设备。是否Device Tree要描述系统中的所有硬件信息？答案是否定的。基本上，那些可以动态探测到的设备是不需要描述的， 例如USB device。不过对于SOC上的usb hostcontroller，它是无法动态识别的，需要在device tree中描述。同样的道理， 在computersystem中，PCI device可以被动态探测到，不需要在device tree中描述，但是PCI bridge如果不能被探测，那么就需要描述之。看来，操作系统不是通过和硬件通信获得硬件参数，而是直接被写好读取的。同时也有一些信息是可以动态获取的。用于实现驱动代码与设备信息相分离。在设备树出现以前，所有关于设备的具体信息都要写在驱动里，一旦外围设备变化，驱动代码就要重写。引入了设备树之后，驱动代码只负责处理驱动的逻辑，而关于设备的具体信息存放到设备树文件中。固件的任务BIOS和UEFI的最主要的功能：初始化硬件和提供硬件的软件抽象。ARM体系也要初始化具体主板相关硬件如GPIO和内存等，这些一般在BSP中完成。与X86体系不同之处在于这些硬件完全定制化，初始化的时候就预先知道有哪些设备，Solder Down了哪个品牌的哪种内存颗粒，到时候就照方抓药，初始化一大堆寄存器而已。X86系统配置情况在开机时候是不知道的，需要探测（Probe）、Training(内存和PCIe)和枚举（PCIe等等即插即用设备），相对较复杂。BIOS和UEFI提供了整个主板、包括主板上外插的设备的软件抽象。通过探测、Training和枚举，BIOS就有了系统所有硬件的信息。它通过几组详细定义好的接口，把这些信息抽象后传递给操作系统，这些信息包括SMBIOS（专栏稍后介绍）、ACPI表（ACPI与UEFI），内存映射表（E820或者UEFI运行时）等等。通过这层映射，才能做到做到操作系统完全不改而能够适配到所有机型和硬件。x86从 start_kernel() 到 PID 1https://zhuanlan.zhihu.com/p/34511698内核的硬件清单：设备树和 ACPI 表在引导时，内核需要硬件信息，不仅仅是已编译过的处理器类型。代码中的指令通过单独存储的配置数据进行扩充。有两种主要的数据存储方法：a href="https://www.youtube.com/watch?v=m_NyYEBxfn8"> 设备树(device-tree) 和 高级配置和电源接口（ACPI）表。内核通过读取这些文件了解每次启动时需要运行的硬件。对于嵌入式设备，设备树是已安装硬件的清单。设备树只是一个与内核源代码同时编译的文件，通常与 vmlinux 一样位于 /boot目录中。要查看 ARM 设备上的设备树的内容，只需对名称与 /boot/*.dtb 匹配的文件执行 binutils 包中的 strings 命令即可，这里 dtb 是指 设备树二进制文件(device-tree binary)。显然，只需编辑构成它的类 JSON 的文件并重新运行随内核源代码提供的特殊 dtc 编译器即可修改设备树。虽然设备树是一个静态文件，其文件路径通常由命令行引导程序传递给内核，但近年来增加了一个 设备树覆盖 的功能，内核在启动后可以动态加载热插拔的附加设备。x86 系列和许多企业级的 ARM64 设备使用 ACPI 机制。与设备树不同的是，ACPI 信息存储在内核在启动时通过访问板载 ROM 而创建的 /sys/firmware/acpi/tables 虚拟文件系统中。读取 ACPI 表的简单方法是使用 acpica-tools 包中的 acpidump 命令。