

[The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/index.html)


 1288  wget -c https://busybox.net/downloads/busybox-1.34.0.tar.bz2
 1289  ls
 1290  rm -rf busybox-1.24.0.tar.bz2  busybox-1.31.0  busybox-1.31.0.tar.bz2
 1291  ls
 1292  tar jxvf busybox-1.34.0.tar.bz2 
 1293  cd busybox-1.34.0/
 1294  make menuconfig
 1295  make install
 1296  uname -a
 1297  cd ..
 1298  ls
 1299  wget -c https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.0.tar.gz
 1300  ls
 1301  tar zxvf linux-4.0.tar.gz 
 1302  ls
 1303  cd linux-4.0/
 1304  ls
 1305  cp   ../busybox-1.34.0/_install  .
 1306  cp -r  ../busybox-1.34.0/_install  .
 1307  ls
 1308  cd _install/
 1309  ls
 1310  mkdir etc
 1311  mkdir dev
 1312  mkdir mnt
 1313  mkdir -p etc/init.d/
 1314  touch etc/init.d/rcS
 1315  vi etc/init.d/rcS
 1316  chmod +x  etc/init.d/rcS
 1317  vi etc/fstab
 1318  vi etc/inittab
 1319  cd dev
 1320  ls
 1321  sudo mknod console c 5 1
 1322  sudo mknod null c 1 3
 1323  cd ../..
 1324  make vexpress_defconfig
 1325  make menuconfig
 1326  make bzImage -j4 ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
 1327  make bzImage -j4 
 1328  cd ..
 1329  ls

 1348  sudo apt-get install qemu
 1349  which qemu-system-arm
 1350  apt search qemu
 1351  locate qemu
 1352  cd
 1353  locate qemu-system-arm
 1354  apt search qemu-system
 1355  sudo apt-get install qemu-system-arm
 1356  ls
 1357  cd Downloads/qemu/linux-5.9/
 1358  ls

 1360  qemu-system-arm -M vexpress-a9 -smp 4 -m 1024M -kernel arch/arm/boot/zImage -append "rdinit=/linuxrc console=ttyAMA0 loglevel=8" -dtb arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic




# 1.预备

## A.1.环境准备

```shell
# kernel-package: utility for building Linux kernel
sudo apt-get install build-essential  bison flex autoconf automake kernel-package libncurses5-dev libssl-dev
# download kernel source with version same as the system
$ uname -r
5.11.0-27-generic
$ apt-cache search linux-source
linux-source - Linux kernel source with Ubuntu patches
linux-source-5.4.0 - Linux kernel source for version 5.4.0 with Ubuntu patches
linux-gkeop-source-5.4.0 - Linux kernel source for version 5.4.0 with Ubuntu patches
linux-hwe-5.11-source-5.11.0 - Linux kernel source for version 5.11.0 with Ubuntu patches
linux-hwe-5.8-source-5.8.0 - Linux kernel source for version 5.8.0 with Ubuntu patches

# will generate /lib/modules/5.11.0-27-generic/build -> /usr/src/linux-headers-5.11.0-27-generic
$ sudo apt-get install linux-hwe-5.11-source-5.11.0

sudo make oldconfig
sudo make
# 生成和构建设备树 $make modules, $make modules_install两条指令
make modules
make modules_install
```

## A.2. 简单驱动实践

### sample1
测试程序: `~/Documents$ cat test.c`
```c++
//~/Documents$ cat test.c
// printk 打印内容通过dmesg 查看
#include <linux/init.h>
#include <linux/module.h>

static unsigned int panel_type = 6;


MODULE_LICENSE("GPL");
static int test_init(void) {
    printk(KERN_EMERG "hello: %d", panel_type);
    return 0;
}

static void test_exit(void) {
    printk(KERN_ALERT "goodbye");
}

module_init(test_init);
module_exit(test_exit);

// 演示使用module parameter， insmod test.ko panel_type=97
module_param(panel_type/*参数名*/, uint/*参数类型*/, S_IRUGO | S_IWUSR/*参数读写权限*/);
MODULE_PARM_DESC(panel_type, "Select the panel type: 37, 6, 97");

```

测试程序对应编译脚本： `~/Documents$ cat Makefile `
```makefile
# KERNELRELEASE是在内核源码的顶层Makefile中定义的一个变量，在第一次读取执行此Makefile时，KERNELRELEASE没有被定义，
# 所以make将读取执行else之后的内容，如果make的目标是clean，直接执行clean操作，然后结束。
# 当make的目标为all时，-C $(KDIR)指明跳转到内核源码目录下读取那里的Makefile；M=$(PWD) 表明然后
# 返回到当前目录继续读入、执行当前的Makefile。当从内核源码目录返回时，KERNELRELEASE已被定义，
# kbuild也被启动去解析kbuild语法的语句，make将继续读取else之前的内容。else之前的内容为kbuild语法
# 的语句，指明模块源码中各文件的依赖关系，以及要生成的目标模块名。param-objs := file1.o file2.o 
# 表示param.o由file1.o与file2.o 连接生成，obj-m := param.o表示编译连接后将生成param.o模块。


# 避免错误：module verification failed: signature and/or required key missing - tainting kernel
CONFIG_MODULE_SIG=n

ifneq ($(KERNELRELEASE),)

# obj-m表示把文件test.o作为"模块"进行编译，不会编译到内核，但是会生成一个独立的 "test.ko" 文件；
# obj-y表示把test.o文件编译进内核;
obj-m := test.o

else
PWD:=$(shell pwd)
KVER?=$(shell uname -r)
KDIR:=/lib/modules/$(KVER)/build

## Use make M=dir or set the environment variable KBUILD_EXTMOD to 
## specify the directory of external module to build. Setting M= takes precedence.

modules:
	make -C $(KDIR) M=$(PWD) modules
clean:
	rm -f *.ko *.o *.mod.o *.mod.c *.symvers

endif
```


加载/卸载：
```shell
# or sudo modprobe test.ko
$ sudo insmod test.ko
$ lsmod |grep test
test                   16384  0
# query modle info in sysfs
$ tree  /sys/module/test/
/sys/module/test/
├── coresize
├── holders
├── initsize
├── initstate
├── notes
├── parameters
│   └── panel_type
├── refcnt
├── sections
│   ├── __mcount_loc
│   └── __param
├── srcversion
├── taint
└── uevent

# or sudo modprobe -r test
$ sudo rmmod test
$ lsmod |grep test
$
```

### sample2: sample1 + platform

补充：“linux\drivers\gpio\gpio-bcm-exp.c” 这个例子

封装为platform_driver. 加载后，将会在发现新增了“/sys/bus/platform/drivers/xxxxx”

```c++
#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>

static unsigned int panel_type = 6;


MODULE_LICENSE("GPL");
static int test_init(struct platform_device *pdev) {
	    printk(KERN_EMERG "hello: %d", panel_type);
	        return 0;
}


static int test_exit(struct platform_device *pdev) {
    printk(KERN_ALERT "goodbye");
    return 0;
}
module_param(panel_type/*参数名*/, uint/*参数类型*/, S_IRUGO | S_IWUSR/*参数读写权限*/);

//module_init(test_init);
//module_exit(test_exit);
static struct platform_driver xxx_driver={
		.driver = {
			.name = "xxxxx",
			.owner= THIS_MODULE,
			},
        .probe = test_init,
		.remove= test_exit,
};
module_platform_driver(xxx_driver);
// builtin_platform_driver
```

注： module_platform_driver是一个宏，如果不想使用该宏，而是想采用传统格式module_init/module_exit来书写platform_driver, “drivers/tty/serial/stm32-usart.c” 提供了一个范例。

```shell
# query modle info in sysfs
$ tree  /sys/module/test/
test/
├── coresize
├── drivers
│   └── platform:xxxxx -> ../../../bus/platform/drivers/xxxxx
├── holders
├── initsize
├── initstate
├── notes
├── parameters
│   └── panel_type
├── refcnt
├── sections
│   ├── __mcount_loc
│   └── __param
├── srcversion
├── taint
└── uevent
```

## A.3. Linux kernel开启DEBUG选项

kernel不会将这些日志输出到控制台上，除非：
- 1）开启了DEBUG宏，并且
- 2）kernel printk的默认日志级别大于7

### 设置kernel printk的默认日志级别为8

修改printk的默认日志级别的方法有多种，例如直接修改printk.c(新kernel为printk.h)中的`CONSOLE_LOGLEVEL_DEFAULT`宏定义。不过修改kernel原生代码的方式稍显粗暴，我们还有优雅一些的手段，例如通过命令行参数的loglevel变量传递，如下：

```diff
diff --git a/arch/arm64/configs/xprj_defconfig b/arch/arm64/configs/xprj_defconfig
index 5d0d591..9335d3f 100644
--- a/arch/arm64/configs/xprj_defconfig
+++ b/arch/arm64/configs/xprj_defconfig
@@ -320,7 +320,7 @@ CONFIG_FORCE_MAX_ZONEORDER=11
#
# Boot options
#
-CONFIG_CMDLINE="earlycon=owl_serial"
+CONFIG_CMDLINE="earlycon=owl_serial loglevel=8"
CONFIG_CMDLINE_FORCE=y
# CONFIG_EFI is not set
```

### DEBUG设置

- 针对单个文件开启debug

	在需要调用`pr_debug/dev_dbg`输出的模块开头，直接#define DEBUG即可

	例子：
	```c++
	/*linux\init\main.c*/
	#define DEBUG		/* Enable initcall_debug */
	...
	```

- 模块级生效debug

	在编译kernel的时候，通过KCFLAGS直接传递，例如：

    ```diff
	diff --git a/Makefile b/Makefile
	index 0835b1c..59625f4 100644
	--- a/Makefile
	+++ b/Makefile
	@@ -83,7 +83,7 @@ kernel-config:
	kernel:
			mkdir -p $(KERNEL_OUT_DIR)
			make -C $(KERNEL_DIR) CROSS_COMPILE=$(CROSS_COMPILE) KBUILD_OUTPUT=$(KERNEL_OUT_DIR) ARCH=$(BOARD_ARCH) $(KERNEL_D
	-       make -C $(KERNEL_DIR) CROSS_COMPILE=$(CROSS_COMPILE) KBUILD_OUTPUT=$(KERNEL_OUT_DIR) ARCH=$(BOARD_ARCH) $(KERNEL_T
	+       make -C $(KERNEL_DIR) CROSS_COMPILE=$(CROSS_COMPILE) KBUILD_OUTPUT=$(KERNEL_OUT_DIR) KCFLAGS=-DDEBUG ARCH=$(BOARD_
	``` 
	注意：打印太多可能会开机卡死，最好不要在顶层的Makefile中添加，比如在”`kernel\Makefile`“.



# 2.基本概念

内核下的`Documentation/CodingStyle` 描述了Linux 内核对编码风格的要求，内核下的`scripts/checkpatch.pl` 提供了1 个检查代码风格的脚本。

### 应用程序 与设备驱动

应用程序和 VFS 之间的接口是系统调用． 而VFS与文件系统以及设备文件之间的接口是自file_operations 结构体成员函数．这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数．
```text
          系统调用            file_opertion
应用程序 -------------> VFS -------------------> 设备驱动 -------->  硬件
```

###  devfs vs  udev

 注意devfs已经在3.26以后的内核被废弃， udev取代了devfs。udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。

mdev是udev的简化版本,是busybox中所带的程序,最适合用在嵌入式系统,而udev一般用在PC上.它们都是用户空间程序，两者实现原理不一样：

- udev: udev 是基于netlink 机制的，它在系统启动时运行了一个deamon 程序udevd，通过监听内核发送的uevent 来执行相应的热拔插动作，包括创建/删除设备节点，加载/卸载驱动模块等等。
- mdev：mdev是基于uevent_helper 机制的，它在系统启动时修改了内核中的uevnet_helper 变量（通过写/proc/sys/kernel/hotplug），值为“/sbin/mdev”。这样内核产生uevent 时会调用uevent_helper 所指的用户级程序，也就是mdev，来执行相应的热拔插动作



使用devfs， 驱动在设备初始化时在`/dev`目录下创建设备文件，显然如果采用devfs，当打开一个并不存在的`/dev/节点`，devfs会自动加载对应的驱动。：
```c++
/* 创建设备目录*/
devfs_handle_t devfs_mk_dir(devfs_handle_t dir, const char *name, void *info);
/* 创建设备文件*/
devfs_handle_t devfs_register(devfs_handle_t dir, const char *name, unsigned int flags,
                              unsigned int major, unsigned int minor, umde_t mode,
                              void * ops, void *info);
/* 撤销设备文件*/
void devfs_unregister(devfs_handle_t de);
```

相反，udev思想是应该在设备被发现时加载驱动模块。系统中所有的设备都应该产生热插拔事件并加载恰当的驱动．而udev 能注意到这点并且为它创建对应的的设备节点。
udev 完全在用户态工作，利用设备加入或移除时内核所发送的热插拔 netlink事件来工作。
```shell
$ ps -aux | grep udev
root         431  0.0  0.0  24168  7684 ?        Ss   8月30   0:00 /lib/systemd/systemd-udevd
```
对于在udev启动前，开机时已经存在的冷插拔设备，如果没有特别处理，udev就会漏掉它们的事件。 为解决这个我问题。linux内核提供了sysfs下面的一个uevent节点（例如 `/sys/module/psmouse/uevent`）,在该节点中增加"add",会导致内核重新发送冷插拔的netlink事件.


udev的配置文件位于 `/etc/udev/ 和 /lib/udev/ `. udev的规则文件一般位于 `/lib/udev/rules.d/`，也可以位于  `/etc/udev/rules.d/`。规则文件是按照字母顺序处理的，不管放在哪个目录。对于相同名字的规则文件， /etc/udev/rules.d 比  /lib/udev/rules.d 优先。

规则文件里的规则有一系列的键/值对组成，键/值对之间用逗号(,)分割。每一个键或者是用户匹配键，或者是一个赋值键。这些值将影响udev创建的设备文件。
- 匹配键："`!=`,`==`"匹配键确定规则是否被应用
- 赋值键："`=`,`+=`,`:=`"赋值键表示分配某值给该键

```
...
ACTION!="add|change|move", GOTO="mm_candidate_end"
SUBSYSTEM=="tty", ENV{ID_MM_CANDIDATE}="1"
SUBSYSTEM=="net", ENV{ID_MM_CANDIDATE}="1"
KERNEL=="cdc-wdm*", SUBSYSTEM=="usb", ENV{ID_MM_CANDIDATE}="1"
KERNEL=="cdc-wdm*", SUBSYSTEM=="usbmisc", ENV{ID_MM_CANDIDATE}="1"
...
```
### uevent 
Uevent提供了“用户空间通知”的功能实现，通过该功能，当内核中有Kobject的增加、删除、修改等动作时，会通知用户空间。

Uevent是Kobject的一部分，用于在Kobject状态发生改变时，例如增加、移除等，通知用户空间程序。

同时，uevent机制也可用于kernel和应用之间的通讯，比如一个红外或senser的驱动里，把红外电平或senser的方向发到应用层，那么在driver里如何发送一个uevent呢？很简单，示例如下：
```c++
static void send_uevent(struct device *dev ，unsigned long code)
{
char event_string[128];
char *envp[] = { event_string, NULL }; 
//printk("----uevent send \n");
sprintf(event_string, "EVENT=%ld",code); 
kobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);

}
```

### sysfs与procfs

内核的结构化设备模型在用户空间就称为sysfs 。与procfs类似。sysfs 虚拟文件系统提供了一种比 proc 更为理想的访问内核数据的途径。新设计的内核机制应该尽量使用 sysfs 机制，而将 proc 保留给纯净的“进程文件系统”。

sysfs 文件系统总是被挂载在 /sys 挂载点上。

[使用 /sys 文件系统访问 Linux 内核](https://blog.csdn.net/halazi100/article/details/39961467)

在Linux 内核中． 设备和驱动是分开注册的. 注册1个设备的时候． 并不需要驱动已经存在．而l个驱动被注册的时候． 也不需要对应的设备设备已经被注册。设备和驱动各自涌向内核；而每个设备和驱动涌入内核的时候，都会去寻找自己的另一半．而正是bus_type 的match（）成员函数将两者捆绑在一起。简单地说．设备和驱动就是红尘中漂浮的男女，而bus_type的malch（）则是牵引红线的月老．它可以识别什么设备与什么驱动是可以配对的。一旦配对成功，xxx_driver的probe()就会被执行, xxx是总线名，例如platform,pci,i2c,spi,usb...

### DTS （device tree source）

document： `/usr/src/linux-source/Documentation/devicetree`



## 字符设备： 顺序存取设备数据

比如时钟/磁带，打印件, 没有和任何物理硬件相连接但需要顺序访问的伪字符设备...

```shell
# c表示字符设备驱动程序， b表示块设备驱动程序， l表示符号链接
$ ls -lh  /dev
total 0
crw-r--r--  1 root root     10, 235 8月  30 09:17 autofs
drwxr-xr-x  2 root root         480 8月  30 09:18 block
...
```

字符驱动程序并不仅仅在`drivers/char/`目录下 。下面是一些“超级”字符驱动程序的例子，它们受到特别的对待，其目录位置也很特殊。
- 串行驱动程序是管理计算机串行端口的字符驱动程序． 然而，它们不仅仅是简单的字符驱动程序，因此被放在`drivers/serial/` 目录下．
- 输入驱动程序负责像键盘、鼠标和操纵杆这样的设备。它们位于单独的源文件目录：`drivers/input/`。
- 帧缓冲区(`/dev/fb*`)提供对显存的访问， `/dev/mem` 提供对系统内存的访问途径。
- －些设备类支持少量采用字符接口的硬件。例如SCSI设备一般是块设备，但SCSI磁带是字符设备。
- 一些内核层提供钩子，通过导出相应的字符接口实现用户空间的设备驱动程序。例如  `drivers/scsi/sg.c, i2c-dev`

关键数据结构: `struct cdev`, struct file_operations

linux内核操作`struct cdev`的函数：
```c++
/* 初始化cdev成员，并建立cdev与file_operations之间的连接*/
void cdev_init(struct cdev *, struct file_operations *);
struct cdev *cdev_alloc();
void cdev_put(struct cdev *p);
/* 向系统添加/删除一个cdev，完成字符设备的注册/注销*/
int cdev_add(struct cdev*, dev_t, unsigned);
void cdev_del(struct cdev*);
```
注意，在调用`cdev_add`前，应首先调用`register_chrdev_region or alloc_chrdev_region`向系统申请设备号。
注意，在调用`cdev_del`后，应调用`unregister_chrdev_region`向系统释放原来申请的设备号。

下面的例子，演示了一个简单的字符设备驱动加载/卸载
```c++
static int major;		/* default to dynamic major */
module_param(major, int, 0);
MODULE_PARM_DESC(major, "Major device number");

struct xxx_dev_t {
	struct cdev  cdev;
	...
} 
static xxx_dev_t xxx_dev;

dev_t devid;
static int xxx_init(void){
    ...
	if (major) {
		devid = MKDEV(major, 0);
		rc = register_chrdev_region(devid, 1, DEVNAME);
	} else {
		rc = alloc_chrdev_region(&devid, 0, 1, DEVNAME);
		major = MAJOR(devid);
	}

	/* ignore minor errs, and succeed */
	cdev_init(&xxx_dev.cdev, &xxx_fileops);
	cdev_add(&xxx_dev.cdev, devid, 1);
    ...
};
static void xxx_exit(){
    unregister_chrdev_region(devid, 1);
    cdev_del(&xxx_dev.cdev);
}

module_init(xxx_init);
module_exit(xxx_exit);
```

## 模块调试

21

第6章讲解了两种设备： 一个PC衍生器件上的触摸控制器和一个手机上的UART 。第8章则讲解了PC系统中的EEPROM和嵌入式设备中的实时钟。

第21章讨论了设备驱动秤，序的调试技术，开·扯驱动程序的时候，提前阅读该章会很有用。

[USB厂家ID](http://www.linux-usb.org/usb.ids)

## 操作系统是如何知道硬件参数的

[发现新硬件的前前后后](https://www.docin.com/p-1291428941.html)

作者：子者阳生之初
链接：https://www.zhihu.com/question/389774365/answer/1578725483
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

IBM、Sun等厂家的服务器最初都在硬件设备中嵌入了相应的程序，称为固件(Firmware)，用于初始化系统配置，提供操作系统软件和硬件之间的接口，启动和运行系统。
后来为了标准化和兼容性，IBM、Sun等联合推出了固件接口IEEE 1275标准，让他们的服务器如IBM PowerPC pSeries，Apple PowerPC，Sun SPARC等均采用Open Firmware，在运行时构建系统硬件的设备树信息传递给内核，进行系统的启动运行。

这样做的好处有，减少内核对系统硬件的严重依赖，利于加速支持包的开发，降低硬件带来的变化需求和成本，降低对内核设计和编译的要求。随着Linux内核的发展，在内核代码中引入了Open Firmware API以使用标准固件接口。在嵌入式PowerPC中，一般使用U-Boot之类的系统引导代码，而不采用Open Firmware。

早期的U-Boot使用include/asm-ppc/u-boot.h中的静态数据结构struct bd_t将板子基本信息传递给内核。这样的接口不够灵活，硬件发生变化就需要重新定制编译烧写引导代码和内核，而且也不再适应于现在的内核。为了适应内核的发展及嵌入式PowerPC平台的千变万化，吸收标准Open Firmware的优点，U-Boot引入了扁平设备树FDT这样的动态接口，使用一个单独的FDT blob存储传递给内核的参数。一些确定信息，例如cache大小、中断路由等直接由设备树提供，而其他的信息，例如eTSEC的MAC地址、频率、PCI总线数目等由U-Boot在运行时修改。从上述描述来看，首先要了解设备树的相关知识。在Linux 2.6中，ARM架构的板极硬件细节过多地被硬编码在arch/arm/plat-xxx和arch/arm/mach-xxx，比如板上的platform设备、 resource、i2c_board_info、spi_board_info以及各种硬件的platform_data，这些板级细节代码对内核来讲只不过是垃圾代码。 而采用Device Tree后，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。……（后来）ARM SOC board specific的代码被移除，由DeviceTree机制来负责传递硬件拓扑和硬件资源信息。本质上，Device Tree改变了原来用hardcode方式将HW 配置信息嵌入到内核代码的方法，改用bootloader传递一个DB的形式。

如果我们认为kernel是一个black box，那么其输入参数应该包括：

- 1. 识别platform的信息
- 2. runtime的配置参数
- 3. 设备的拓扑结构以及特性对于嵌入式系统，在系统启动阶段，bootloader会加载内核并将控制权转交给内核，此外， 还需要把上述的三个参数信息传递给kernel，以便kernel可以有较大的灵活性。
 
在linux kernel中，Device Tree的设计目标就是如此。……Device Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性， 其实就是成对出现的name和value。在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）：

- o CPU的数量和类别
- o 内存基地址和大小
- o 总线和桥o 外设连接
- o 中断控制器和中断使用情况
- o GPIO控制器和GPIO使用情况
- o Clock控制器和Clock使用情况
 
它基本上就是画一棵电路板上CPU、总线、设备组成的树，Bootloader会将这棵树传递给内核，然后内核可以识别这棵树， 并根据它展开出Linux内核中的platform_device、i2c_client、spi_device等设备，而这些设备用到的内存、IRQ等资源， 也被传递给了内核，内核会将这些资源绑定给展开的相应的设备。是否Device Tree要描述系统中的所有硬件信息？答案是否定的。基本上，那些可以动态探测到的设备是不需要描述的， 例如USB device。不过对于SOC上的usb hostcontroller，它是无法动态识别的，需要在device tree中描述。同样的道理， 在computersystem中，PCI device可以被动态探测到，不需要在device tree中描述，但是PCI bridge如果不能被探测，那么就需要描述之。看来，操作系统不是通过和硬件通信获得硬件参数，而是直接被写好读取的。同时也有一些信息是可以动态获取的。用于实现驱动代码与设备信息相分离。在设备树出现以前，所有关于设备的具体信息都要写在驱动里，一旦外围设备变化，驱动代码就要重写。引入了设备树之后，驱动代码只负责处理驱动的逻辑，而关于设备的具体信息存放到设备树文件中。固件的任务BIOS和UEFI的最主要的功能：初始化硬件和提供硬件的软件抽象。ARM体系也要初始化具体主板相关硬件如GPIO和内存等，这些一般在BSP中完成。与X86体系不同之处在于这些硬件完全定制化，初始化的时候就预先知道有哪些设备，Solder Down了哪个品牌的哪种内存颗粒，到时候就照方抓药，初始化一大堆寄存器而已。X86系统配置情况在开机时候是不知道的，需要探测（Probe）、Training(内存和PCIe)和枚举（PCIe等等即插即用设备），相对较复杂。BIOS和UEFI提供了整个主板、包括主板上外插的设备的软件抽象。通过探测、Training和枚举，BIOS就有了系统所有硬件的信息。它通过几组详细定义好的接口，把这些信息抽象后传递给操作系统，这些信息包括SMBIOS（专栏稍后介绍）、ACPI表（ACPI与UEFI），内存映射表（E820或者UEFI运行时）等等。通过这层映射，才能做到做到操作系统完全不改而能够适配到所有机型和硬件。x86从 start_kernel() 到 PID 1https://zhuanlan.zhihu.com/p/34511698内核的硬件清单：设备树和 ACPI 表在引导时，内核需要硬件信息，不仅仅是已编译过的处理器类型。代码中的指令通过单独存储的配置数据进行扩充。有两种主要的数据存储方法：a href="https://www.youtube.com/watch?v=m_NyYEBxfn8"> 设备树(device-tree) 和 高级配置和电源接口（ACPI）表。内核通过读取这些文件了解每次启动时需要运行的硬件。对于嵌入式设备，设备树是已安装硬件的清单。设备树只是一个与内核源代码同时编译的文件，通常与 vmlinux 一样位于 /boot目录中。要查看 ARM 设备上的设备树的内容，只需对名称与 /boot/*.dtb 匹配的文件执行 binutils 包中的 strings 命令即可，这里 dtb 是指 设备树二进制文件(device-tree binary)。显然，只需编辑构成它的类 JSON 的文件并重新运行随内核源代码提供的特殊 dtc 编译器即可修改设备树。虽然设备树是一个静态文件，其文件路径通常由命令行引导程序传递给内核，但近年来增加了一个 设备树覆盖 的功能，内核在启动后可以动态加载热插拔的附加设备。x86 系列和许多企业级的 ARM64 设备使用 ACPI 机制。与设备树不同的是，ACPI 信息存储在内核在启动时通过访问板载 ROM 而创建的 /sys/firmware/acpi/tables 虚拟文件系统中。读取 ACPI 表的简单方法是使用 acpica-tools 包中的 acpidump 命令。

## /sys目录下各个子目录的具体说明

### /sys/devices

该目录下是全局设备结构体系，包含所有被发现的注册在各种总线上的各种物理设备。一般来说，所有的物理设备都按其在总线上的拓扑结构来显示，但有两个例外，即platform devices和system devices。platform devices一般是挂在芯片内部的高速或者低速总线上的各种控制器和外设，它们能被CPU直接寻址；system devices不是外设，而是芯片内部的核心结构，比如CPU，timer等，它们一般没有相关的驱动，但是会有一些体系结构相关的代码来配置它们。

(sys/devices是内核对系统中所有设备的分层次表达模型，也是/sys文件系统管理设备的最重要的目录结构)


### sys/dev

该目录下维护一个按照字符设备和块设备的主次号码(major:minor)链接到真是设备(/sys/devices)的符号链接文件。


### /sys/class

该目录下包含所有注册在kernel里面的设备类型，这是按照设备功能分类的设备模型，每个设备类型表达具有一种功能的设备。每个设备类型子目录下都是这种哦哦那个设备类型的各种具体设备的符号链接，这些链接指向/sys/devices/name下的具体设备。设备类型和设备并没有一一对应的关系，一个物理设备可能具备多种设备类型；一个设备类型只表达具有一种功能的设备，比如：系统所有输入设备都会出现在/sys/class/input之下，而不论它们是以何种总线连接到系统的。(/sys/class也是构成linux统一设备模型的一部分)




### /sys/block

该目录下的所有子目录代表着系统中当前被发现的所有块设备。按照功能来说防止在/sys/class下会更合适，但由于历史遗留因素而一直存在于/sys/block，但从linux2.6.22内核开始这部分就已经标记为过去时，只有打开了CONFIG_SYSFS_DEPRECATED配置编译才会有这个目录存在，并且其中的内容在从linux2.6.26版本开始已经正式移到了/sys/class/block，旧的接口/sys/block为了向后兼容而保留存在，但其中的内容已经变为了指向它们在/sys/devices/中真实设备的符号链接文件。





### /sys/bus

该目录下的每个子目录都是kernel支持并且已经注册了的总线类型。这是内核设备按照总线类型分层放置的目录结构，/sys/devices中的所有设备都是连接于某种总线之下的，bus子目录下的每种具体总线之下可以找到每个具体设备的符号链接，

一般来说每个子目录(总线类型)下包含两个子目录，一个是devices，另一个是drivers；其中devices下是这个总线类型下的所有设备，这些设备都是符号链接，它们分别指向真正的设备(/sys/devices/name/下)；而drivers下是所有注册在这个总线上的驱动，每个driver子目录下 是一些可以观察和修改的driver参数。

(它也是构成linux统一设备模型的一部分)

### /sys/fs

按照设计，该目录使用来描述系统中所有的文件系统，包括文件系统本身和按照文件系统分类存放的已挂载点。

### /sys/kernel

这个目录下存放的是内核中所有可调整的参数

### /sys/firmware

该目录下包含对固件对象(firmware object)和属性进行操作和观察的接口，即这里是系统加载固件机制的对用户空间的接口.(关于固件有专用于固件加载的一套API)

### /sys/hypervisor

该目录是与虚拟化Xen相关的装置。(Xen是一个开放源代码的虚拟机监视器)


### /sys/module

该目录下有系统中所有的模块信息，不论这些模块是以内联(inlined)方式编译到内核映像文件中还是编译为外模块(.ko文件)，都可能出现在/sys/module中。即module目录下包含了所有的被载入kernel的模块。


### /sys/power

该目录是系统中的电源选项，对正在使用的power子系统的描述。这个目录下有几个属性文件可以用于控制整个机器的电源状态，如可以向其中写入控制命令让机器关机/重启等等。

# 3.platform 设备驱动

在Linux 2.6 以后的设备驱动模型中，需要关心： 总线/设备/驱动这三个实体． 总线将设备和驱动绑定。在系统每注册一个设备的时候． 会寻找与之匹配的驱动． 相反的，在系统每位注册一个驱动的时候． 会寻找与之匹配的设备． 而匹配由总线完成。

但是在SOC系统中，通常外设都是挂接在SOC内存空间，它们本身并不依附于类似PCI/USB/SPI/I2C..., 基于此，linux发明了一种虚拟的总线，称为platform总线，相应设备称为platform_device, 而驱动称为platform_driver.

“platform”这个概念专门为嵌入式引入。 注意所谓platform_device 并不是于字符设备/块设备/网络设备...等并列的概念。而只是一种附加的手段。

与platform_driver 地位对等的是： i2c_driver，spi_driver, usb_driver, pci_driver

通过platform_bus_type的定义可以知道， 设备和驱动的匹配是由platform_match完成的。
```c++
struct bus_type platform_bus_type = {
	.name		= "platform",
	.dev_groups	= platform_dev_groups,
	.match		= platform_match,
	.uevent		= platform_uevent,
	.dma_configure	= platform_dma_configure,
	.pm		= &platform_dev_pm_ops,
};
EXPORT_SYMBOL_GPL(platform_bus_type);
```
这个platform_match匹配有[四种方式](https://www.cnblogs.com/zhuangquan/p/12877244.html)：
```c++
static int platform_match(struct device *dev, struct device_driver *drv)
{
	...
	/* Attempt an OF style match first */
	if (of_driver_match_device(dev, drv))
		return 1;

	/* Then try ACPI style match */
	if (acpi_driver_match_device(dev, drv))
		return 1;

	/* Then try to match against the id table */
	if (pdrv->id_table)
		return platform_match_id(pdrv->id_table, pdev) != NULL;

	/* fall-back to driver name match */
	return (strcmp(pdev->name, drv->name) == 0);
}
```

为了不同的匹配支持，下面演示了怎么构建platform_driver：
```c++
static struct platform_driver  xxxx_driver = {
	.driver = {
		.name = ???,
		.owner = THIS_MODULE,
		/* to support OF style match*/
		.of_match_table = of_match_ptr(xxxx_of_matches),
		/* to support acpi style match*/
		// .acpi_match_table = ??
	},
	/* to support id table style match*/
	// .id_table = ??,
	.probe  = ???,
	.remove = ???
}
```



## 提供platform驱动
将一个驱动更改为platform驱动，在“环境准备”中提供了一个例子，这里有点需要注意的是，因为有了“struct platform_device *pdev”输入，所以建议做设备关联的malloc， 如下面：
更改的核心就是更改注册，同时有个小改动就是将
```c++
struct xxx_dev_t {
	struct cdev  cdev;
	...
} *xxx_devp;

static int xxx_init(struct platform_device *pdev){
	xxx_devp = devm_kzalloc(&pdev-dev, sizeof(xxx_dev_t));
    ...
};
// static void xxx_exit(void){
static int xxx_exit(struct platform_device *pdev){
	(VOID)pdev; // 不需要使用
	//改为操纵 xxx_devp->cdev
    ...
	return 0;
}
...
```

## 增加platform 设备

platform_device对象就是我们最终要注册到平台总线上的设备信息对象，对设备信息进行编码，其实就是创建一个platform_device对象，可以看出，platform_device和其他设备一样，都是device的子类。

要将一个设备让内核以platform设备对待，增加这个设备时，有两种方式，一种是将该设备在板文件中硬编码增加；一种是通过设备树提供必要的信息告知内核。

### 方式1：硬编码platform_device
在"arch/arm/mach-xxx/板文件"中硬编码增加。 这会使得在“`/sys/devices/platform`”目录下增加一个同名的子目录
```c++
static struct platform_device bast_device_ide1 = {
	.name		= "xxxxx",
	.id		= 1,	
	}
};

platform_add_devices(&bast_device_ide1,1);
```

### 方式2：DTS描述，kernel自动生成platform_device
在内核，是通过内核函数of_platform_default_populate_init, 遍历device_node树, 生成platform_device。这个函数对会满足以下条件的节点会处理为platform_device:
- b. 并非所有的device_node都会转换为platform_device只有以下的device_node会转换:
  - b.1 该节点必须含有compatible属性
  - b.2 根节点的子节点(节点必须含有compatible属性)
  - b.3 含有特殊compatible属性的节点的子节点(子节点必须含有compatible属性):
- 这些特殊的compatilbe属性为: “simple-bus”,“simple-mfd”,“isa”,"arm,amba-bus "
- 根节点是例外的，生成platfrom_device时，即使有compatible属性也不会处理

具体见“drivers/of/platform.c”中下面代码：
```c++
const struct of_device_id of_default_bus_match_table[] = {
	{ .compatible = "simple-bus", },
	{ .compatible = "simple-mfd", },
	{ .compatible = "isa", },
#ifdef CONFIG_ARM_AMBA
	{ .compatible = "arm,amba-bus", },
#endif /* CONFIG_ARM_AMBA */
	{} /* Empty terminated list */
};
```

对i2c/spi 总线设备，也会默认创建platorm 设备，具体见下面例子说明。
```c++
/{
   /* /mytest会被转换为platform_device,因为它兼容"simple-bus", 
      它的子节点/mytest/mytest@0 也会被转换为platform_device */	
   mytest{
       compatile = "mytest", "simple-bus";
	   mytest@0{
		   compatile = "mytest_0";
		   reg = <0>;
	   };
   };
   /* /i2c节点一般表示i2c控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;
      /i2c/at24c02节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 
	  一般是被创建为一个i2c_client。*/
   i2c{
	   compatile = "samsung, i2c";
	   at24c02 {
		   compatile = "at24c02";
	   };
   };
   /* 类似的也有/spi节点, 它一般也是用来表示SPI控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;
   /spi/flash@0节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个spi_device。*/
   spi{
	   compatile = "samsung, spi";
	   flash@0 {
		   compatile = "winbond,w25q32dw";
		   reg = <0>;
	   };
   };
};
```

##  platform设备 与platform驱动的匹配

在前面章节中，已经描述了如何让内核将某个设备当作platform_device对待，以及怎么让一个驱动称为platform_driver。 在该前提下，我们下面描述platform设备与platform驱动的匹配。

在设备树中的“compatible”属性，通过它来与驱动关联。 

下面描述了设备驱动中如何使用“compatible”来与设备关联，也称为OF style match方法：

```c++
static const struct of_device_id  xxxx_of_matches[] = {
   {.compatible = "davicom,dm9000",},
   {}
};

static struct platform_driver  xxxx_driver = {
	.driver = {
		.name = ???,
		.owner = THIS_MODULE,
		/* to support OF style match*/
		.of_match_table = of_match_ptr(xxxx_of_matches),
	},
	.probe  = ???,
	.remove = ???
}
```

补充： 
- 如果使用DT，可以在probe中增加类似"`const struct of_device_id *match= of_match_device(xxxx_of_matches, &pdev->dev);`", 得到匹配的设备，从而对该匹配设备做写特殊的动作。另外不论是否采用了设备树，都可以在驱动中通过`platform_get_xx `去获取设备树里面的属性。
- 在驱动代码中，可以利用"`if (pdev->dev->of_node) {/*DT based instantiation*/} else {/*NON-DT based instantiation*/}`"识别做些动作。


# 4.PM: 时钟(common clock framework)

D:\stm32\abc\rpi-kernels\linux\drivers\clk\clk-stm32f4.c

参考：
- [《Linux common clock framework(1)_概述》](http://www.wowotech.net/pm_subsystem/clk_overview.html)、
- [《Linux common clock framework(2)_clock provider》](http://www.wowotech.net/pm_subsystem/clock_provider.html)、
- [《Linux common clock framework(3)_实现逻辑分析》](http://www.wowotech.net/pm_subsystem/clock_framework_core.html)以及
- [《Common Clock Framework系统结构》](http://www.wowotech.net/pm_subsystem/ccf-arch.html)。

- [Linux下时钟框架实践---一款芯片的时钟树配置](https://www.cnblogs.com/arnoldlu/p/10307827.html)

## clock DTS相关

### 定义clock provider

Required properties:  `#clock-cells` 


方式1： 将系统所有的clock，抽象为一个虚拟的设备，用一个DTS node表示。

方式2：每一个可输出clock的器件，如Oscillator、PLL、Mux等等，都是一个设备，用一个DTS node表示。

```c++
/ {

	compatible = "st,stm32f429i-disco","st,stm32f429";
    ...
	systick: timer@e000e010 {
		compatible = "arm,armv7m-systick";
		reg = <0xe000e010 0x10>;
		status = "okay";
    	clocks = <&rcc 1 SYSTICK>;
	};

	soc {
		#address-cells = <0x01>;
		#size-cells = <0x01>;
		compatible = "simple-bus";
		interrupt-parent = <&nvic>;
		ranges;

		rtc: rtc@40002800 {
			compatible = "st,stm32-rtc";
			reg = <0x40002800 0x400>;
			/*有clocks属性，说明它是一个consumer。该属性描述作为“clock consumer”设备，它的input clock是哪些*/
			/*它引用clock provider的clock-cells是2，所以specifier有2个u32组成*/
			clocks = <&rcc 1 CLK_RTC>;
			/*clock-names 属性用于类似clk_get api 去获取该rtc设备input clock的句柄*/
			clock-names = "ck_rtc";
			/*设置"<&rcc 1 CLK_RTC>"clock的parent为"<&rcc 1 CLK_LSE>"*/
			assigned-clocks = <&rcc 1 CLK_RTC>;
			assigned-clock-parents = <&rcc 1 CLK_LSE>;
            ...
		};


		rcc: rcc@40023810 {
			#reset-cells = <1>;
			/*#clock-cells不为0，代表它是一个provider，有输出*/
			#clock-cells = <2>;
			compatible = "st,stm32f42xx-rcc", "st,stm32-rcc";
			reg = <0x40023800 0x400>;
			clocks = <&clk_hse>, <&clk_i2s_ckin>;
			st,syscfg = <&pwrcfg>;
			assigned-clocks = <&rcc 1 CLK_HSE_RTC>;
			assigned-clock-rates = <1000000>;
			linux,phandle = <0x01>;
			phandle = <0x01>;
		};


		pinctrl: pin-controller {
			compatible = "st,stm32f429-pinctrl";
            ...
			gpioa: gpio@40020000 {
				gpio-controller;
				clocks = <&rcc 0 STM32F4_AHB1_CLOCK(GPIOA)>;
				...
			};
            ...
		};
	};

	clocks {

    	/*"clk_hse"该clock设备的名称，clock consumer可以根据该名称引用clock；*/
		clk_hse: clk-hse {
			/*#clock-cells为0，代表是clock根，只能是provider*/
			#clock-cells = <0x00>;
			compatible = "fixed-clock";
			clock-frequency = <0x7a1200>;
		};

		clk-lse {
			#clock-cells = <0x00>;
			compatible = "fixed-clock";
			clock-frequency = <0x8000>;
		};

		clk-lsi {
			#clock-cells = <0x00>;
			compatible = "fixed-clock";
			clock-frequency = <0x7d00>;
		};

		clk_i2s_ckin: i2s-ckin {
			#clock-cells = <0x00>;
			compatible = "fixed-clock";
			clock-frequency = <0x00>;
		};
	};
```


### 定义clock consummer

Required properties:  `clocks`

例子见上一节

### clock分类

根据clock的特点，clock framework将clock分为fixed rate、gate、devider、mux、fixed factor、composite六类

- fixed rate：
    对于fixed rate clocks，.compatible固定填充"fixed-clock"，并提供"clock-frequency"和"clock-output-names"关键字。之后不需要再driver中做任何处理，clock framework core会帮我们搞定一切。

- fixed factor：
    对于fixed factor clock，.compatible为"fixed-factor-clock"，并提供"clock-div"、"clock-mult"和"clock-output-names"关键字。clock framework core会帮我们搞定一切。

对于不能由clock framework core处理的clock，需要在driver中使用struct of_device_id进行匹配，并在初始化时，调用OF模块，查找所有的DTS匹配项，并执行合适的regitser接口，注册clock。

- gate clock：
	这一类clock只可开关（会提供.enable/.disable回调），可使用下面接口注册：
	```c++
     struct clk *clk_register_gate(struct device *dev, const char *name,
                     const char *parent_name, unsigned long flags,
                     void __iomem *reg, u8 bit_idx,
                     u8 clk_gate_flags, spinlock_t *lock);
	  struct clk_hw *clk_hw_register_gate(...)		  
	```

- divider clock:
	这一类clock可以设置分频值（因而会提供.recalc_rate/.set_rate/.round_rate回调），可通过下面两个接口注册：
	```c++
     struct clk *clk_register_divider(struct device *dev, const char *name,
                     const char *parent_name, unsigned long flags,
                     void __iomem *reg, u8 shift, u8 width,
                     u8 clk_divider_flags, spinlock_t *lock);
	  struct clk_hw *clk_hw_register_divider(...)		  

	 struct clk *clk_register_divider_table(struct device *dev, const char *name,
	        const char *parent_name, unsigned long flags,
	        void __iomem *reg, u8 shift, u8 width,
	        u8 clk_divider_flags, const struct clk_div_table *table,
	        spinlock_t *lock);
	  struct clk_hw *clk_hw_register_divider_table(...)		  
	```

- mux clock:
	这一类clock可以选择多个parent，因为会实现.get_parent/.set_parent/.recalc_rate回调，可通过下面两个接口注册：
	```c++
      struct clk *clk_register_mux(struct device *dev, const char *name,
                      const char **parent_names, u8 num_parents, unsigned long flags,
                      void __iomem *reg, u8 shift, u8 width,
                      u8 clk_mux_flags, spinlock_t *lock);
	  struct clk_hw *clk_hw_register_mux(...)		  
      
	  struct clk *clk_register_mux_table(struct device *dev, const char *name,
                      const char **parent_names, u8 num_parents, unsigned long flags,
                      void __iomem *reg, u8 shift, u32 mask,
                      u8 clk_mux_flags, u32 *table, spinlock_t *lock);
	  struct clk_hw *clk_hw_register_mux_table(...)		  
	```

- composite clock:
	顾名思义，就是mux、divider、gate等clock的组合，可通过下面接口注册：
	```c++
      struct clk *clk_register_composite(struct device *dev, const char *name,
                      const char **parent_names, int num_parents,
                      struct clk_hw *mux_hw, const struct clk_ops *mux_ops,
                      struct clk_hw *rate_hw, const struct clk_ops *rate_ops,
                      struct clk_hw *gate_hw, const struct clk_ops *gate_ops,
                      unsigned long flags);
	  struct clk_hw *clk_hw_register_composite(...)		  
	```

### 验证 

通过读取"`/sys/kernel/debug/clk/clk_summary`"信息，和时钟框图对照，可以验证DTS配置正确与否。

## BSP工程师视角使用clock子系统API

从clock driver的角度，分析怎么借助common clock framework管理系统的时钟资源。kernel称clock driver为clock provider。

clock provider的API位于include/linux/clk_provider.h。

clock framework使用"`struct clk`"结构抽象clock，但该结构对clock consumer是透明的（不需要知道它的内部细节）。同样，"`struct clk`"对clock provider也是透明的。framework提供了"`struct clk_hw`"结构，从clock provider的角度，描述clock.


api中出现“gate”， gate代表关闭clock

### A.1. 注册、取消注册clock
通用注册函数是下表。 针对特别类型clock注册，子系统提供了更为方便使用的api，见上一节“clock 分类”章节的描述：

	|API                       | 说明|
	|--------------------------|-----|
	|[devm_]clk_register       |注册|
	|[devm_]clk_hw_register    |注册|
	|[devm_]clk_unregister     |释放.|
	|[devm_]clk_hw_unregister  |释放.|
	|||

```c++
struct clk *clk_register(struct device *dev, struct clk_hw *hw);
struct clk *devm_clk_register(struct device *dev, struct clk_hw *hw);
``` 

```c++
void clk_unregister(struct clk *clk);
void devm_clk_unregister(struct device *dev, struct clk *clk);
```

### A.2.将注册的时钟加入到OF框架中

注册clock的同时，将返回的struct clk指针，保存在一个数组中，并调用of_clk_add_provider接口，告知clock framework core

  int of_clk_add_provider(struct device_node *np,
                          struct clk *(*clk_src_get)(struct of_phandle_args *args,
                                                     void *data),
                          void *data);


## 驱动工程师视角使用clock子系统API

面向的读者是使用clock的driver开发者，即在开发一个driver时，该driver是作为一个clock consumer的身份。

### A.1.clock获取有关的API


```c++
```

例子，在驱动中要获取clk就可以采用下面的方式：
```c++
    /*DTS例子：
    *This represents a device with two clock inputs, named "baud" and "register".
    *The baud clock is connected to output 1 of the &osc device, and the register
    *clock is connected to output 0 of the &ref.
    *device需要使用两个clock，“baud”和“regitser”，由clock-names关键字指定；
    *baud取自“osc”的输出1，register取自“ref”的输出0，由clocks关键字指定。
    *device {
    *    clocks = <&osc 1>, <&ref 0>;
    *    clock-names = "baud", "register";
    *};
    */
/* driver */
int xxx_probe(struct platform_device *pdev)
{
        struct clk *baud_clk = devm_clk_get(&pdev->dev, “baud”);
        ...
        int ret = clk_prepare_enable(baud_clk);
        ...
}
```

device driver在操作设备的clock之前，需要先获取和该clock关联的struct clk指针，获取的接口如下：

	|API                | 说明|
	|-------------------|-----|
	|[devm_]clk_get     |dev和id的任意一个可以为空。如果id为空，则必须有DTS的支持才能获得device对应的clk|
	|[devm_]clk_put     |释放.|
	|clk_get_sys        |类似clk_get，不过使用device的name替代device结构|
	|of_clk_get         |直接从相应的DTS node中，以index、name等为索引，获取clk|
	|of_clk_get_by_name ||
	|of_clk_get_from_provider||
	|||

```c++
   1: struct clk *clk_get(struct device *dev, const char *id);  
   2: struct clk *devm_clk_get(struct device *dev, const char *id);
   3: void clk_put(struct clk *clk);
   4: void devm_clk_put(struct device *dev, struct clk *clk);
   5: struct clk *clk_get_sys(const char *dev_id, const char *con_id);
   6: struct clk *of_clk_get(struct device_node *np, int index);
   7: struct clk *of_clk_get_by_name(struct device_node *np, const char *name);
   8: struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec);
```

### A.2.clock控制有关的API

	|API                          | 说明|
	|-----------------------------|-----|
	|clk_prepare/clk_unprepare    |启动clock前的准备工作/停止clock后的善后工作。可能会睡眠。|
	|clk_enable/clk_disable       |启动/停止clock。不会睡眠|
	|clk_[hw_]get_rate            |clock频率的获取,|
	|clk_[hw_]round_rate          |得到和需要设置的rate比较接近的那个值|
	|clk_set_rate                 |clock频率设置,调用则保障对应频率的分频比存在|
	|clk_get_parent/clk_set_parent|获取/选择clock的parent clock|
	|clk_prepare_enable           |clk_prepare和clk_enable组合|
	|clk_disable_unprepare        |clk_disable和clk_unprepare组合|
	|clk_[hw_]get_flags||
	|||

注2：prepare/unprepare，enable/disable的说明。

	这两套API的本质，是把clock的启动/停止分为atomic和non-atomic两个阶段，以方便实现和调用。因此上面所说的“不会睡眠/可能会睡眠”，有两个角度的含义：一是告诉底层的clock driver，请把可能引起睡眠的操作，放到prepare/unprepare中实现，一定不能放到enable/disable中；二是提醒上层使用clock的driver，调用prepare/unprepare接口时可能会睡眠哦，千万不能在atomic上下文（例如中断处理中）调用哦，而调用enable/disable接口则可放心。

	另外，clock的开关为什么需要睡眠呢？这里举个例子，例如enable PLL clk，在启动PLL后，需要等待它稳定。而PLL的稳定时间是很长的，这段时间要把CPU交出（进程睡眠），不然就会浪费CPU。

	最后，为什么会有合在一起的clk_prepare_enable/clk_disable_unprepare接口呢？如果调用者能确保是在non-atomic上下文中调用，就可以顺序调用prepare/enable、disable/unprepared，为了简单，framework就帮忙封装了这两个接口。

```c++
   1: int clk_prepare(struct clk *clk)
   2: void clk_unprepare(struct clk *clk)
   3:  
   4: static inline int clk_enable(struct clk *clk)
   5: static inline void clk_disable(struct clk *clk)
   6:  
   7: static inline unsigned long clk_get_rate(struct clk *clk)
   8: static inline int clk_set_rate(struct clk *clk, unsigned long rate)
   9: static inline long clk_round_rate(struct clk *clk, unsigned long rate)
  10:  
  11: static inline int clk_set_parent(struct clk *clk, struct clk *parent)
  12: static inline struct clk *clk_get_parent(struct clk *clk)
  13:  
  14: static inline int clk_prepare_enable(struct clk *clk)
  15: static inline void clk_disable_unprepare(struct clk *clk)
```  

### A.4.  clock rate改变的通知

	|API                          | 说明|
	|-----------------------------|-----|
	|clk_notifier_register        |注册 clock rate改变的通知|
	|clk_notifier_unregister      |注销 clock rate改变的通知|
	|||
```c++
1: int clk_notifier_register(struct clk *clk, struct notifier_block *nb);
2: int clk_notifier_unregister(struct clk *clk, struct notifier_block *nb);
```
这两个notify接口，用于注册/注销 clock rate改变的通知。例如某个driver关心某个clock，期望这个clock的rate改变时，通知到自己，就可以注册一个notify。


# 5.reset framework

Documentation/devicetree/bindings/reset/reset.txt

以最简单的device_reset为例说明kernel reset过程
```c++
// 对设备dev(是一个reset consumer)进行reset
int device_reset(struct device *dev)
{
	struct reset_control *rstc;
	int ret;
    /*通过dev设备的"resets属性找到reset controller(provider)"*/
	rstc = reset_control_get(dev, NULL);
	if (IS_ERR(rstc))
		return PTR_ERR(rstc);
    /*调用"rstc->rcdev->ops->reset"动作进行reset，该动作是provider driver提供*/
	ret = reset_control_reset(rstc);

	reset_control_put(rstc);

	return ret;
}
EXPORT_SYMBOL_GPL(device_reset);
```

## rewet DTS相关

### 定义Reset providers

Required properties:
- #reset-cells:	Number of cells in a reset specifier; Typically 0 for nodes with a single reset output and 1 for nodes with multiple reset outputs.
```text
For example:

	rst: reset-controller {
		#reset-cells = <1>;
	};
```
### Reset consumers

Required properties:
- resets:		List of phandle and reset specifier pairs, one pair
		for each reset signal that affects the device, or that the
		device manages. Note: if the reset provider specifies '0' for
		#reset-cells, then only the phandle portion of the pair will
		appear.

Optional properties:
- reset-names:	List of reset signal name strings sorted in the same order as
		the resets property. Consumers drivers will use reset-names to
		match reset signal names with reset specifiers.

For example:
```text
	device {
		resets = <&rst 20>;
		reset-names = "reset";
	};
This represents a device with a single reset signal named "reset".

	bus {
		resets = <&rst 10> <&rst 11> <&rst 12> <&rst 11>;
		reset-names = "i2s1", "i2s2", "dma", "mixer";
	};

This represents a bus that controls the reset signal of each of four sub-
ordinate devices. Consider for example a bus that fails to operate unless no
child device has reset asserted.
```

## BSP工程师视角（reset provider）

kernel为reset provider提供的API位于“include/linux/reset-controller.h”中，很简单，无非就是：创建并填充reset controller设备（struct reset_controller_dev），并调用相应的接口（reset_controller_register/reset_controller_unregister）注册或者注销之。

```c++
struct reset_controller_dev {                                                  
        struct reset_control_ops *ops;//ops提供reset操作的实现                                         
        struct module *owner;                                                  
        struct list_head list;                                                 
        struct device_node *of_node;      
		//of_xlate和of_reset_n_cells用于解析consumer device dts node中
		//的“resets = ; ”节点，如果reset controller比较简单（仅仅是线性的索引），
		//可以不实现，使用reset framework提供的简单版本----of_reset_simple_xlate即可。                                     
        int of_reset_n_cells;                                                  
        int (*of_xlate)(struct reset_controller_dev *rcdev,                    
                        const struct of_phandle_args *reset_spec);             
        unsigned int nr_resets;//该reset controller所控制的reset信号的个数。
};
```

## 驱动工程师视角(reset consumer)

从某一个硬件模块的驱动设计者来看，他的要求很简单：我只是想复位我的硬件，而不想知道到底用什么手段才能复位（例如控制哪个寄存器的哪个bit位，等等）。

这个要求其实体现了软件设计（甚至是任何设计）中的一个最最质朴的设计理念：封装和抽象。对设备驱动来说，它期望看到是“reset”这个通用概念，用这个通用概念去发号施令的话，这个驱动就具备了通用性和可移植性（无论在周围的环境如何变化，“reset”本身不会变化）。而至于怎么reset，是通过寄存器A的bit m，还是寄存器B的bit n，则是平台维护者需要关心的事情（就是本文的reset provider）。

看到这样的要求，Linux kernel说：OK，于是reset framework出场，提供了如下的机制（基于device tree）：

1）首先，提供描述系统中reset资源的方法（参考下面第3章的介绍），这样consumer可以基于这种描述在自己的dts node中引用所需的reset信号。

2）然后，consumer设备在自己的dts node中使用“resets”、“reset-names”等关键字声明所需的reset的资源，例如[1]（“resets”字段的具体格式由reset provider决定”）：
```text
device {                                                               
        resets = <&rst 20>;                                            
        reset-names = "reset";                                         
};
```
3）最后，consumer driver在需要的时候，可以调用下面的API复位自己（具体可参考“include/linux/reset.h“）：

3-a）只有一个reset信号的话，可以使用最简单的device_reset API "`int device_reset(struct device *dev);`"

3-b）如果需要更为复杂的控制（例如有多个reset信号、需要控制处于reset状态的长度的等），可以使用稍微复杂的API
```c++
/* 通过reset_control_get或者devm_reset_control_get获得reset句柄 */
struct reset_control *reset_control_get(struct device *dev, const char *id);   
void reset_control_put(struct reset_control *rstc);                            
struct reset_control *devm_reset_control_get(struct device *dev, const char *id);

/* 通过reset_control_reset进行复位，或者通过reset_control_assert使设备处于复位生效状态，通过reset_control_deassert使复位失效 */
int reset_control_reset(struct reset_control *rstc);                           
int reset_control_assert(struct reset_control *rstc);                          
int reset_control_deassert(struct reset_control *rstc);
```


# 6.gpio 子系统

[gpio子系统和pinctrl子系统（上）](https://www.cnblogs.com/rongpmcu/p/7662751.html)
[gpio子系统和pinctrl子系统（中）](https://www.cnblogs.com/rongpmcu/p/7662755.html)
[gpio子系统和pinctrl子系统（下）](https://www.cnblogs.com/rongpmcu/p/7662756.html)


[linux内核中的GPIO系统之（1）：软件框架](http://www.wowotech.net/gpio_subsystem/io-port-control.html)

[linux内核中的GPIO系统之（2）：pin control subsystem](http://www.wowotech.net/gpio_subsystem/pin-control-subsystem.html)

[Linux内核中的GPIO系统之（3）：pin controller driver代码分析](http://www.wowotech.net/gpio_subsystem/pin-controller-driver.html)

[linux内核中的GPIO系统之（4）：pinctrl驱动的理解和总结](http://www.wowotech.net/gpio_subsystem/pinctrl-driver-summary.html)

[ linux内核中的GPIO系统之（5）：gpio subsysem和pinctrl subsystem之间的耦合](http://www.wowotech.net/gpio_subsystem/pinctrl-and-gpio.html)


gpio子系统帮助我们管理整个系统gpio的使用情况，同时通过sys文件系统导出了调试信息和应用层控制接口。它内部实现主要提供了两类接口，一类给bsp工程师，用于注册gpio chip（也就是所谓的gpio控制器驱动），另一部分给驱动工程师使用，为驱动工程师屏蔽了不同gpio chip之间的区别，驱动工程师调用的api的最终操作流程会导向gpio对应的gpio chip的控制代码，也就是bsp的代码。

“other drivers” --------gpio subsystem --------"gpio controller dirver (BSP)" --- hardware layer

## gpio DTS相关

“Documentation\devicetree\bindings\gpio\gpio.txt”

### 定义gpio-controller节点

定义gpio-controller节点： `gpio-controller` 与`#gpio-cells` 必须，其他可选

例子：
```c++
gpio-controller@00000000 {
	compatible = "foo";
	reg = <0x00000000 0x1000>;
	// 声明该节点是一个GPIO Controller
	gpio-controller;
	// 示这个控制器下每一个引脚要用2个32位的数(cell)来描述
	#gpio-cells = <2>;
	// informs the driver that only the first 18 GPIOs, at local offset 0 .. 17, are in use.
	ngpios = <18>;
	// indicates the start and size of the GPIOs that can't be used.
	gpio-reserved-ranges = <0 4>, <12 2>;
	//  defining the names of the GPIO lines going out of the GPIO controller.
	gpio-line-names = "MMC-CD", "MMC-WP", "VDD eth", "RST eth", "LED R",
		"LED G", "LED B", "Col A", "Col B", "Col C", "Col D",
		"Row A", "Row B", "Row C", "Row D", "NMI button",
		"poweroff", "reset";
}
```

### gpio- and pin-controller interaction

在实践中，通常将gpio-controller提供的gpios路由到pin-controller，这就需要引入“gpio-ranges”属性，如下面例子演示的，`pins 20..29 on pin controller "pinctrl" is mapped to GPIO line 0..9`
```c++
/ {
	soc {
		pinctrl: pin-controller {
			compatible = "st,stm32f429-pinctrl";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges = <0 0x40020000 0x3000>;
			...
			pins-are-numbered;

			gpioa: gpio@40020000 {
				gpio-controller;
				#gpio-cells = <2>;
				reg = <0x0 0x400>;

				// The format is: <[pin controller phandle], [GPIO controller offset],
				//                 [pin controller offset], [number of pins]>;
				// This means:
				// - pins 20..29 on pin controller "pinctrl" is mapped to GPIO line 0..9 and
				// - pins 50..69 on pin controller "pinctrl" is mapped to GPIO line 10..29
                gpio-ranges = <&pinctrl 0 20 10>, <&pinctrl 10 50 20>;
				...
			};

			gpiob: gpio@40020400 {
				gpio-controller;
				#gpio-cells = <2>;
				reg = <0x400 0x400>;
				...
			};
		};
	};
};
```





### 设备树中引用gpio 引脚

在其他节点引用gpio可以使用的方式，GPIO properties should be named :
- "[<name>-]gpios", with `<name>` being the purpose of this GPIO for the device. While a non-existent `<name>` is considered valid for compatibility reasons (resolving to the "gpios" property), it is not allowed for new bindings. Also, GPIO properties named 
- "[<name>-]gpio" are valid and old bindings use it, but are only supported for compatibility reasons and should not be used for newer bindings since it has been deprecated.

GPIO properties can contain one or more GPIO phandles, but only in exceptional
cases should they contain more than one. If your device uses several GPIOs with
distinct functions, reference each of them under its own property, giving it a
meaningful name. The only case where an array of GPIOs is accepted is when
several GPIOs serve the same function (e.g. a parallel data line).

The exact purpose of each gpios property must be documented in the device tree
binding of the device.


```c++
	gpio1: gpio1 {
		gpio-controller;
		#gpio-cells = <2>;
	};
	[...]

	data-gpios = <&gpio1 12 0>,
		     <&gpio1 13 0>,
		     <&gpio1 14 0>,
		     <&gpio1 15 GPIO_ACTIVE_HIGH>;
```

In the above example, &gpio1 uses 2 cells to specify a gpio. The first cell is
a local offset to the GPIO line and the second cell represent consumer flags,
such as if the consumer desire the line to be active low (inverted) or open
drain. This is the recommended practice.


## BSP工程师视角使用GPIO子系统API

用于注册gpio chip（也就是所谓的gpio控制器驱动），即围绕gpio controller的相关API。

documents/gpio/driver.txt
documentation/driver-api/pinctrl.rst

[和device tree或者machine driver相关的接口](http://www.wowotech.net/linux_kenrel/pin-control-subsystem.html)

- 编写gpio controller驱动，主要是：构造gpio_chip, 然后通过 gpiochip_add_data/devm_gpiochip_add_data/gpiochip_add 注册它。

- 编写pinctrl驱动，主要： 构造struct pinctrl_desc用于表示一个pin控制器，然后通过`[devm_]pinctrl_register()`将其注册进pinctrl子系统；

	注：pinctrl是在linux 3.4引入的。

现在流行的编写方式是： 在设备树描述gpio信息，然后在pinctrl驱动里面顺便构造gpio_chip,并以gpiochip_add_data注册到gpio子系统。 参见“`drivers/pinctrl/stm32/pinctrl-stm32.c`”例子。

Requesting self-owned GPIO pins:

	有时候需要允许GPIO chip driver 使用GPIO description， 在这种情况下，可以使用下面的api，不过注意它们不会影响使用计数，并且它们只能在gpio chip driver自身内部使用

	```c++
	/*Descriptors requested with gpiochip_request_own_desc() must be released with
	  gpiochip_free_own_desc().*/
	struct gpio_desc *gpiochip_request_own_desc(struct gpio_desc *desc,
						    const char *label)   
	void gpiochip_free_own_desc(struct gpio_desc *desc)
	```

以"`gpiochip_add_data`"为例，它将gpio chip添加到gpio子系统中，核心是：
- 将chip添加到全局的gpio chip链表中，用于gpio管理
- 将该gpio chip对应的gpio段全部初始化
- 调用of_gpiochip_add初始化设备树相关的信息，用于后面的属性解析及向pinctrl子系统同步下
- 导出到sys



```c++
int gpiochip_add(struct gpio_chip *chip)
{
	...
	int		base = chip->base;
	//如果指定了base，也就是指定了启示gpio号，需要校验下chip的所有gpio是否有效
    //这里会用到ARCH_NR_GPIOS宏，它可以在配置的时候，通过CONFIG_ARCH_NR_GPIO修改，
    //否则采用默认值256
	if ((!gpio_is_valid(base) || !gpio_is_valid(base + chip->ngpio - 1))
			&& base >= 0) {
		status = -EINVAL;
		goto fail;
	}
    ...
	//如果没有指定base，那么需要基于该chip的gpio数量在系统支持的gpio范围里找一段区间给该chip
	if (base < 0) {
		base = gpiochip_find_base(chip->ngpio);
		if (base < 0) {
			status = base;
			goto unlock;
		}
		chip->base = base;
	}

	//到这里的时候，说明一切正常，把它加入到全局的gpiochip链表中去吧，注意，加入的时候会基于base排序
    //这也保证了gpiochip_find_base的实现
	status = gpiochip_add_to_list(chip);

	//如果加入成功，最后一步就是初始化该chip对应的那些gpio了
	if (status == 0) {
		chip->desc = &gpio_desc[chip->base];

		for (id = 0; id < chip->ngpio; id++) {
			struct gpio_desc *desc = &chip->desc[id];
            //将该chip对应的那些gpio对应的数据结构desc初始化，指向拥有它的chip
			desc->chip = chip;

			/* REVISIT:  most hardware initializes GPIOs as
			 * inputs (often with pullups enabled) so power
			 * usage is minimized.  Linux code should set the
			 * gpio direction first thing; but until it does,
			 * and in case chip->get_direction is not set,
			 * we may expose the wrong direction in sysfs.
			 */
            //如果chip driver没有指定chip->direction_input，意味着不是输入，那就设置为输出咯
			desc->flags = !chip->direction_input
				? (1 << FLAG_IS_OUT)
				: 0;
		}
	}

	spin_unlock_irqrestore(&gpio_lock, flags);
    ...
	//初始化设备树相关的信息，后面会详细讲一下这部分
	of_gpiochip_add(chip);
    ...
	//将该gpiochip导出到sys，用于调试和应用层直接操作
	status = gpiochip_export(chip);
	if (status)
		goto fail;

	pr_debug("%s: registered GPIOs %d to %d on device: %s\n", __func__,
		chip->base, chip->base + chip->ngpio - 1,
		chip->label ? : "generic");
	...
}
```

## 驱动工程师视角使用GPIO子系统API


 [GPIO和Pinctrl子系统的使用](https://www.bilibili.com/read/cv5153694)


建议使用新版的接口（documents/gpio/consumer.txt）,对应头文件使用“`#include <linux/gpio/consumer.h>`”,提供类似`gpiod_*`的API。老版的接口是“documents/gpio/gpio-legacy.txt”，对应头文件使用“`#include <linux/gpio.h>`”,提供类似`gpio_*`的API。





下面只讨论新版的接口使用。

函数名均是`gpiod_xxx`的。 内核中操作gpio的地方都是要调用该类接口。



- 基于消息机制访问GPIO
	类似I2C/SPI等，Some GPIO controllers must be accessed using message based buses like I2C or
	SPI. Commands to read or write those GPIO values require waiting to get to the
	head of a queue to transmit a command and get its response. This requires
	sleeping, which can't be done from inside IRQ handlers.

	Accessing such GPIOs requires a context which may sleep, for example a threaded
	IRQ handler, and those accessors must be used instead of spinlock-safe
	accessors without the cansleep() name suffix.

	Other than the fact that these accessors might sleep, and will work on GPIOs
	that can't be accessed from hardIRQ handlers, these calls act the same as the
	spinlock-safe calls.

	```c++
	/* Platforms that support this type of GPIO distinguish them from other GPIOs by
	   returning nonzero from this call:*/
	int gpiod_cansleep(const struct gpio_desc *desc)

    /* To access such GPIOs, a different set of accessors is defined:
	*/
	int gpiod_get_value_cansleep(const struct gpio_desc *desc)
	void gpiod_set_value_cansleep(struct gpio_desc *desc, int value)
    ```

- Interacting With the Legacy GPIO Subsystem

	“Documentation\gpio\consumer.txt”

	Many kernel subsystems still handle GPIOs using the legacy integer-based
	interface. Although it is strongly encouraged to upgrade them to the safer
	descriptor-based API, the following two functions allow you to convert a GPIO
	descriptor into the GPIO integer namespace and vice-versa:

		int desc_to_gpio(const struct gpio_desc *desc)
		struct gpio_desc *gpio_to_desc(unsigned gpio)

	The GPIO number returned by desc_to_gpio() can be safely used as long as the
	GPIO descriptor has not been freed. All the same, a GPIO number passed to
	gpio_to_desc() must have been properly acquired, and usage of the returned GPIO
	descriptor is only possible after the GPIO number has been released.

	Freeing a GPIO obtained by one API with the other API is forbidden and an
	unchecked error.


### A.1.请求gpio

//请求一个/一组gpio

- 获得GPIO：
	|descriptor-based         |legacy             | 说明|
	|-------------------------|-------------------|-----|
	|gpiod_get                |gpio_request       ||
	|gpiod_get_optional       |gpio_request_one   ||	
	|gpiod_get_index          |                   ||
	|gpiod_get_array          |gpio_request_array |处理多个gpio|
	|devm_gpiod_get           |devm_gpio_request  ||
	|devm_gpiod_get_optional  |gpio_request_one   ||	
	|devm_gpiod_get_index     |                   ||
	|devm_gpiod_get_array     |                   |处理多个gpio|
	||||

注：有前缀“devm_”的含义是“设备资源管理”(Managed Device Resource)，这是一种自动释放资源的机制。它的思想是“资源是属于设备的，设备不存在时资源就可以自动释放”。 

以"`int gpio_request(unsigned gpio, const char *label)`"为例，gpio_request主要做了以下动作：

- 检查是否已经被申请，没有的话，标记为已申请
- 填充label到该pin数据结构，用于debug
- 如果chip　driver提供了request回调，调用它
- 如果chip　driver提供了get_direction回调，调用它,通过它更新pin数据结构，标明gpio方向

gpio_request_one多一个flags参数，通过该参数，可以指定GPIOF_OPEN_DRAIN、GPIOF_OPEN_SOURCE、GPIOF_DIR_IN、GPIOF_EXPORT等标志，如果指定了GPIOF_DIR_IN，那么后面就不需要自己再额外调用gpio_direction_input或者gpio_direction_output了，如果指定了GPIOF_EXPORT，后面就不需要自己调用gpio_export了。

在下面例子中，演示了如何使用con_id参数，与idx参数：
```c++
	/*
	*struct gpio_desc *__must_check gpiod_get(struct device *dev, const char *con_id)
	*struct gpio_desc *gpiod_get_index(struct device *dev,
	*					  const char *con_id, unsigned int idx,
	*					  enum gpiod_flags flags)
	*/
	/* dts sample:
	*device_node {
	*                ...
	*              gpio_name = <&msm_gpio 99 0>;    //gpio_99
	*                ...
	*              led-gpios = <&gpio 15 GPIO_ACTIVE_HIGH>, // red 
	*                         <&gpio 16 GPIO_ACTIVE_HIGH>, // green 
	*                         <&gpio 17 GPIO_ACTIVE_HIGH>; // blue 
	*              power-gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
	*}
	*/

  //legacy method
　int gpio_99 = of_get_named_gpio_flags(dev->of_node, "gpio_name", 0, NULL);    //从设备数节点, 可选
  gpio_request(gpio_99, "gpio_name");        //通过gpio号申请gpio
  gpio_direction_output(gpio_99, 1);         //设置gpio_99输出，初始值为1
  gpio_set_value(gpio_99, 0);                //设置gpio_99值为0
  gpio_free(gpio_99);                        //gpio_99不再使用后应当释放
  // gpio的申请和设置都可能会出现失败的情况，应该做好异常处理;；

  //descriptor method
  struct gpio_desc *red, *green, *blue, *power;
  red = gpiod_get_index(dev, "led", 0, GPIOD_OUT_HIGH); //内部会调用of_get_named_gpiod_flags
  green = gpiod_get_index(dev, "led", 1, GPIOD_OUT_HIGH);
  blue = gpiod_get_index(dev, "led", 2, GPIOD_OUT_HIGH);
  power = gpiod_get(dev, "power", GPIOD_OUT_HIGH); 
```
 
<!-- 
extern int pinctrl_gpio_request(unsigned gpio);
extern void pinctrl_gpio_free(unsigned gpio);
extern int pinctrl_gpio_direction_input(unsigned gpio);
extern int pinctrl_gpio_direction_output(unsigned gpio); -->

### A.2.设置gpio方向

//设置gpio方向为输入/输出
gpio_direction_input或者gpio_direction_output        ---------<2>

- 设置方向：
	|descriptor-based       |legacy               | 说明|
	|-----------------------|---------------------|-----|
	|gpiod_direction_input  |gpio_direction_input ||
	|gpiod_direction_output |gpio_direction_output||
	||||

gpio_direction_input或者gpio_direction_output用来设置该gpio为输入还是输出，它们主要是回调gpio chip driver提供的direction_input或者direction_output来设置该gpio寄存器为输入、输出。

- 通过"gpiod_direction_*()" 设置方向，如果已经通过"gpiod_get*()"设置了方向，也可以省略:
	```c++
	/* return value is zero for success, else a negative errno.*/
	int gpiod_direction_input(struct gpio_desc *desc)
	int gpiod_direction_output(struct gpio_desc *desc, int value)
	...
	/* return either GPIOF_DIR_IN or GPIOF_DIR_OUT.*/
	int gpiod_get_direction(const struct gpio_desc *desc);
    ```



### A.3.sysfs文件系统导出gpio

“Documentation\gpio\sysfs.txt”

//将该gpio通过sys文件系统导出，应用层可以通过文件操作gpio
                                          ---------<3>

	|descriptor-based       |legacy               | 说明|
	|-----------------------|---------------------|-----|
	|gpiod_export           |gpio_export          ||
	|gpiod_unexport         |gpio_unexport        ||
	|gpiod_export_link      |gpio_export_link     ||


Exporting from Kernel code

	Kernel code can explicitly manage exports of GPIOs which have already been
	requested using gpio_request():

		/* export the GPIO to userspace */
		int gpiod_export(struct gpio_desc *desc, bool direction_may_change);

		/* reverse gpio_export() */
		void gpiod_unexport(struct gpio_desc *desc);

		/* create a sysfs link to an exported GPIO node */
		int gpiod_export_link(struct device *dev, const char *name,
				struct gpio_desc *desc);

	After a kernel driver requests a GPIO, it may only be made available in
	the sysfs interface by gpiod_export(). The driver can control whether the
	signal direction may change. This helps drivers prevent userspace code
	from accidentally clobbering important system state.

	This explicit exporting can help with debugging (by making some kinds
	of experiments easier), or can provide an always-there interface that's
	suitable for documenting as part of a board support package.

	After the GPIO has been exported, gpiod_export_link() allows creating
	symlinks from elsewhere in sysfs to the GPIO sysfs node. Drivers can
	use this to provide the interface under their own device in sysfs with
	a descriptive name.

一旦导出到sysfs文件空间，下面演示了如何通过sysfs来操纵gpio

```shell
# show overview information
$ gpiodetect 
gpiochip0 [pinctrl-bcm2835] (54 lines)
gpiochip1 [brcmexp-gpio] (8 lines)
gpiochip2 [brcmvirt-gpio] (2 lines)

$ cd /sys/class/gpio 
/sys/class/gpio$ ls
export  gpiochip0  gpiochip100  gpiochip128  unexport
# export gpio4 from kernel to user space
$echo 4 > /sys/class/gpio/export
# set direction
$echo out >/sys/class/gpio/gpio4/direction
# set value to 1
$echo 1 >/sys/class/gpio/gpio4/value
# unregister gpio4 
$echo 4 > /sys/class/gpio/unexport

```


### A.4.读写gpio

//如果gpio为输入，获取gpio值，如果gpio为输出，可以设置gpio高低电平

内部也是调用gpio chip driver提供的get、set

- 读写：
	|descriptor-based |legacy         | 说明|
	|-----------------|---------------|-----|
	|gpiod_get_value  |gpio_get_value ||
	|gpiod_set_value  |gpio_set_value ||
	||||

-  access GPIOs from an atomic context:
	```c++
	/* The values are boolean, zero for low, nonzero for high.*/
	int gpiod_get_value(const struct gpio_desc *desc);
	void gpiod_set_value(struct gpio_desc *desc, int value);
	```


### A.5.注册gpio irq

"`request_irq(gpio_to_irq(gpio_num)...)`"将gpio转为对应的irq，然后注册该irq的中断handler

	|descriptor-based |legacy         | 说明|
	|-----------------|---------------|-----|
	|gpiod_to_irq     |gpiod_to_irq   ||
	||||


用于获取该gpio对应的中断号，这个需要设备树里的该gpio节点描述使用哪个中断号（并不是所有的gpio都可以触发中断的）。它里面的实现就是回调gpio chip driver提供的“gpio_chip.to_irq"

### A.5.释放gpio

//释放请求的一个或者一组gpio
gpio_free/devm_gpio_free、gpio_free_array                           ---------<6>

- 释放GPIO：
	|descriptor-based    |legacy             | 说明|
	|--------------------|-------------------|-----|
	|gpiod_free          |gpio_free          ||
	|gpiod_put           |gpio_free_array    ||
	|gpiod_put_array     |                   ||
	|dvm_gpiod_get       |                   ||
	|dvm_gpiod_put       |                   ||
	|dvm_gpiod_put_array |                   ||
	||||

# 7.pinctrl 子系统

注意： pinctrl的实现不许用我们在驱动里调用任何它提供的api，pinctrl api对于驱动工程师是透明的，对于驱动工程师只需要通过设备树文件就可以起到配置整个系统pin的目的。。pinctrl在代码层级只与bsp工程师有关。

“other drivers” --------> gpio subsystem --------"pin controller dirver (BSP)" --- hardware layer

## pinctrl DTS相关

"Documentation\devicetree\bindings\pinctrl\pinctrl-bindings.txt"

== Generic pin multiplexing node content ==

See pinmux-node.yaml

== Generic pin configuration node content ==

See pincfg-node.yaml

### A.1.定义Pin controller节点，client device节点

- pin controller：前者提供服务：可以用它来复用引脚、配置引脚。

- client device： 后者使用服务：声明自己要使用哪些引脚的哪些功能，怎么配置它们。 Pinctrl系统的客户，那就是使用Pinctrl系统的设备，使用引脚的设备。它在设备树里会被定义为一个节点，在节点里声明要用哪些引脚。

Required properties: See the pin controller driver specific documentation

Pin controller devices should contain the pin configuration nodes that client
devices reference.

```c++
/{
	soc {
		compatible = "simple-bus";
        //定义pinctrl client device节点
		usart1: serial@40011000 {
			compatible = "st,stm32-usart\0st,stm32-uart";
			reg = <0x40011000 0x400>;
			...
			//refer pin configuration nodes <&usart1_pins_a>, the pin configuration nodes 
			// must be child nodes of the pin controller that they configure.
			pinctrl-0 = <&usart1_pins_a>;
			// 	The list of names to assign states(pinctrl-x)
			pinctrl-names = "default";
		};

        // 定义pinctrl节点
		pinctrl: pin-controller {
			#address-cells = <0x01>;
			#size-cells = <0x01>;
			ranges = <0x00 0x40020000 0x3000>;
			interrupt-parent = <0x03>;
			st,syscfg = <0x0c 0x08>;
			pins-are-numbered;
			compatible = "st,stm32f429-pinctrl";
			linux,phandle = <0x0f>;
			phandle = <0x0f>;
            //定义gpio controller节点
			gpioa: gpio@40020000 {
				gpio-controller;
				#gpio-cells = <0x02>;
				interrupt-controller;
				#interrupt-cells = <0x02>;
				reg = <0x00 0x400>;
				clocks = <0x01 0x00 0x00>;
				st,bank-name = "GPIOA";
				gpio-ranges = <&pinctrl 0x00 0x00 0x10>;
				linux,phandle = <0x11>;
				phandle = <0x11>;
			};
            //定义pin configuration nodes
			// supported attrs: Documentation\devicetree\bindings\pinctrl\pincfg-node.yaml
			usart1_pins_a: usart1@0 {
				linux,phandle = <0x08>;
				phandle = <0x08>;
				pins1 {
					pinmux = <STM32F429_PA9_FUNC_USART1_TX>;
					bias-disable;
					drive-push-pull;
					slew-rate = <0>;
				};
				pins2 {
					pinmux = <STM32F429_PA10_FUNC_USART1_RX>;
					bias-disable;
				};
			};
		};
	};
};
```

### A.3.定义pin configuration节点
见“\Documentation\devicetree\bindings\pinctrl\pinctrl-bindings.txt”中“Generic pin configuration node content”章节

例子见上章节

### A.4.解析pin configuration nodes
注意：kernel pinctrl subsystem并不关心configuration的具体内容是什么，它只提供pin configuration get/set的通用机制，至于get到的东西，以及set的东西，到底是什么，是pinctrl driver自己的事情。

通常是在pinctrl probe中调用"`pinconf_generic_parse_dt_config`"来解析pin-configuration节点，比如出现了属性“bias-bus-hold”，那该api会解析它为字典值“PIN_CONFIG_BIAS_BUS_HOLD”。该类节点支持的参数见“\Documentation\devicetree\bindings\pinctrl\pinctrl-bindings.txt”中“Generic pin configuration node content”章节 

- pin-configuration节点默认支持解析的参数（不包括“`pins`,`group`,`pinmux`”）：
```c++
//defined in "drivers\pinctrl\pinconf-generic.c"
static const struct pinconf_generic_params dt_params[] = {
	{ "bias-bus-hold", PIN_CONFIG_BIAS_BUS_HOLD, 0 },
	{ "bias-disable", PIN_CONFIG_BIAS_DISABLE, 0 },
	{ "bias-high-impedance", PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 },
	{ "bias-pull-up", PIN_CONFIG_BIAS_PULL_UP, 1 },
	{ "bias-pull-pin-default", PIN_CONFIG_BIAS_PULL_PIN_DEFAULT, 1 },
	{ "bias-pull-down", PIN_CONFIG_BIAS_PULL_DOWN, 1 },
	{ "drive-open-drain", PIN_CONFIG_DRIVE_OPEN_DRAIN, 0 },
	{ "drive-open-source", PIN_CONFIG_DRIVE_OPEN_SOURCE, 0 },
	{ "drive-push-pull", PIN_CONFIG_DRIVE_PUSH_PULL, 0 },
	{ "drive-strength", PIN_CONFIG_DRIVE_STRENGTH, 0 },
	{ "input-debounce", PIN_CONFIG_INPUT_DEBOUNCE, 0 },
	{ "input-disable", PIN_CONFIG_INPUT_ENABLE, 0 },
	{ "input-enable", PIN_CONFIG_INPUT_ENABLE, 1 },
	{ "input-schmitt", PIN_CONFIG_INPUT_SCHMITT, 0 },
	{ "input-schmitt-disable", PIN_CONFIG_INPUT_SCHMITT_ENABLE, 0 },
	{ "input-schmitt-enable", PIN_CONFIG_INPUT_SCHMITT_ENABLE, 1 },
	{ "low-power-disable", PIN_CONFIG_LOW_POWER_MODE, 0 },
	{ "low-power-enable", PIN_CONFIG_LOW_POWER_MODE, 1 },
	{ "output-disable", PIN_CONFIG_OUTPUT_ENABLE, 0 },
	{ "output-enable", PIN_CONFIG_OUTPUT_ENABLE, 1 },
	{ "output-high", PIN_CONFIG_OUTPUT, 1, },
	{ "output-low", PIN_CONFIG_OUTPUT, 0, },
	{ "power-source", PIN_CONFIG_POWER_SOURCE, 0 },
	{ "sleep-hardware-state", PIN_CONFIG_SLEEP_HARDWARE_STATE, 0 },
	{ "slew-rate", PIN_CONFIG_SLEW_RATE, 0 },
};
```

- 如果pin-configuration节点默认支持解析的参数不满足，希望新增其他参数,可以通过pinctrl_desc向内核传递，下面代码片段演示了例子：
	```c++
	...
	enum lpc18xx_pin_config_param {
		PIN_CONFIG_GPIO_PIN_INT = PIN_CONFIG_END + 1,
	};
	static const struct pinconf_generic_params lpc18xx_params[] = {
		{"nxp,gpio-pin-interrupt", PIN_CONFIG_GPIO_PIN_INT, 0},
	};
	static struct pinctrl_desc lpc18xx_scu_desc = {
		...
		.num_custom_params = ARRAY_SIZE(lpc18xx_params),
		.custom_params = lpc18xx_params,
		...
	};
	...
	```

### 2.2 pinctrl子系统设备树：

```c++
device_node {
                    ...
                    pinctrl-names = "gpio_active", "gpio_sleep";    //分别对用pinctrl-0和pinctrl-1
                    pinctrl-0 = <&gpio_active>;                               //引用
                    pinctrl-1 = <&gpio_sleep>;                                //引用
                    ...
        };
```

```c++
static int xxxxxxxxxx(struct platform_device *pdev){
　struct pinctrl *pinctrl = devm_pinctrl_get(&pdev->dev);    //获取device对应节点下的pinctrl
  struct pinctrl_state = pinctrl_lookup_state(pinctrl, "gpio_active");    //通过pinctrl名获取pinctrl对应状态
  pinctrl_select_state(pinctrl, pinctrl_state);        //设置pinctrl的状态为'gpio_active
  devm_pinctrl_put(pinctrl);          //使用完了释放资源

  //pinctrl_get_select 相当于pinctrl_get 与 pinctrl_select_state的结合。
}
```

```c++
//drivers/pinctrl/core.c
/**
 * pinctrl_select_state() - select/activate/program a pinctrl state to HW
 * @p: the pinctrl handle for the device that requests configuration
 * @state: the state handle to select/activate/program
 */
int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)
{
	...
	/* Apply all the settings for the new state */
	list_for_each_entry(setting, &state->settings, node) {
		switch (setting->type) {
		case PIN_MAP_TYPE_MUX_GROUP:
			ret = pinmux_enable_setting(setting);
			break;
		case PIN_MAP_TYPE_CONFIGS_PIN:
		case PIN_MAP_TYPE_CONFIGS_GROUP:
			ret = pinconf_apply_setting(setting);
			break;
		default:
			ret = -EINVAL;
			...;
		}
	}
    ...
}
```

```c++
//drivers/pinctrl/pinmux.c
int pinmux_enable_setting(const struct pinctrl_setting *setting)
{
	struct pinctrl_dev *pctldev = setting->pctldev;
	...
	if (pctlops->get_group_pins)
		ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,
					      &pins, &num_pins);
	...
	/* Try to allocate all pins in this group, one by one */
	for (i = 0; i < num_pins; i++) {
		ret = pin_request(pctldev, pins[i], setting->dev_name, NULL);
		...
	}

	/* Now that we have acquired the pins, encode the mux setting */
	...
	ret = ops->set_mux(pctldev, setting->data.mux.func,
			   setting->data.mux.group);
    ...
}
```

# 8.pwm子系统

linux\Documentation\pwm.txt

[Linux pwm子系统分析之一 系统框架说明](https://blog.csdn.net/lickylin/article/details/106449647)

[Linux pwm子系统分析之二 gpio-pwm驱动实践](https://blog.csdn.net/lickylin/article/details/106449675)


## BSP工程师视角使用PWM子系统API

pwm_chip层主要对应一个pwm控制器，一个pwm控制器可包含多个pwm_device，针对一个pwm_chip，提供了访问pwm 控制器的方法，通过pwm_chip提供的方法，实现对pwm 控制器的配置；

- 编写pwm controller驱动，主要是：构造pwm_chip, 然后通过 pwmchip_add注册它。简要来说就是：

    - 创建platform device，用于存储该pwm chip相关的配置参数，如pwm base index、pwm num、pwm操作相关的寄存器参数等  等；
    - 创建platform driver，在该driver的probe接口中完成pwm chip的注册，主要包括：
    - 申请struct pwm_chip类型的内存空间；
    - 实现struct pwm_ops中各成员接口，主要实现与pwm 控制器的通信；根据“linux\Documentation\pwm.txt”建议：
       - a.实现pwm_chip.apply。 Drivers are encouraged to implement ->apply() instead of the legacy
        ->enable(), ->disable() and ->config() methods. Doing that should provide
        atomicity in the PWM config workflow, which is required when the PWM controls
        a critical device (like a regulator).

       - b.推荐实现pwm_chip.get_state。 The implementation of ->get_state() (a method used to retrieve initial PWM state) is also encouraged for the same reason: letting the PWM user know about the current PWM state would allow him to avoid glitches.
    - 调用pwmchip_add，完成pwm chip的添加。

	实现以上几步，即可完成pwm chip的注册。


- When implementing polarity support in a PWM driver, make sure to respect the
signal conventions in the PWM framework. By definition, normal polarity
characterizes a signal starts high for the duration of the duty cycle and
goes low for the remainder of the period. Conversely, a signal with inversed
polarity starts low for the duration of the duty cycle and goes high for the
remainder of the period.


## 驱动工程师视角使用PWM子系统API

api通过pwm号在pwm_tree基数树中找到对应的pwm_device（所有注册的pwm device均会添加至pwm_tree中，另外一个pwm_chip可包含多个pwm_device，因此pwm_chip与pwm_device之间也存在关联），并借助pwm_chip提供的方法配置pwm控制器，实现pwm配置等操作；

https://gitee.com/low-level-of-logic/RaspberryPi/blob/master/docs/0025_硬件PWM控制风扇.md

### A.1.使能pwm

//请求pwm

- 获得pwm：
	|descriptor-based         |legacy          | 说明|
	|-----------------------|------------------|-----|
	|pwm_get                |pwm_request       |to request a PWM device|
	|devm_pwm_get           |                  ||
	||||

### A.2.配置pwm（配置pwm的占空比、频率等）

After being requested, a PWM has to be configured using::

	int pwm_apply_state(struct pwm_device *pwm, struct pwm_state *state);

This API controls both the PWM period/duty_cycle config and the
enable/disable state.

The pwm_config(), pwm_enable() and pwm_disable() functions are just wrappers
around pwm_apply_state() and should not be used if the user wants to change
several parameter at once. For example, if you see pwm_config() and
pwm_{enable,disable}() calls in the same function, this probably means you
should switch to pwm_apply_state().

The PWM user API also allows one to query the PWM state with pwm_get_state().

In addition to the PWM state, the PWM API also exposes PWM arguments, which
are the reference PWM config one should use on this PWM.
PWM arguments are usually platform-specific and allows the PWM user to only
care about dutycycle relatively to the full period (like, duty = 50% of the
period). struct pwm_args contains 2 fields (period and polarity) and should
be used to set the initial PWM config (usually done in the probe function
of the PWM user). PWM arguments are retrieved with pwm_get_args().

### A.3.去使能pwm

	|descriptor-based         |legacy          | 说明|
	|-----------------------|------------------|-----|
	|pwm_put                |pwm_free          |to free the PWM device|	
	|devm_pwm_put           |                  ||
	||||




### Using PWMs with the sysfs interface
-----------------------------------

If CONFIG_SYSFS is enabled in your kernel configuration a simple sysfs
interface is provided to use the PWMs from userspace. It is exposed at
/sys/class/pwm/. Each probed PWM controller/chip will be exported as
pwmchipN, where N is the base of the PWM chip. Inside the directory you
will find:

  npwm
    The number of PWM channels this chip supports (read-only).

  export
    Exports a PWM channel for use with sysfs (write-only).

  unexport
   Unexports a PWM channel from sysfs (write-only).

The PWM channels are numbered using a per-chip index from 0 to npwm-1.

When a PWM channel is exported a pwmX directory will be created in the
pwmchipN directory it is associated with, where X is the number of the
channel that was exported. The following properties will then be available:

  period
    The total period of the PWM signal (read/write).
    Value is in nanoseconds and is the sum of the active and inactive
    time of the PWM.

  duty_cycle
    The active time of the PWM signal (read/write).
    Value is in nanoseconds and must be less than the period.

  polarity
    Changes the polarity of the PWM signal (read/write).
    Writes to this property only work if the PWM chip supports changing
    the polarity. The polarity can only be changed if the PWM is not
    enabled. Value is the string "normal" or "inversed".

  enable
    Enable/disable the PWM signal (read/write).

	- 0 - disabled
	- 1 - enabled

# 9. IRQ子系统

查看系统当前的中断统计信息：`cat /proc/interrupts`, 他能统计每个终端号在每个cpu上的发生次数

[LINUX 中断子系统专栏之一 子系统架构简述](https://blog.csdn.net/lickylin/article/details/108031868)

针对一个irq controller而言，一个irq controller可以包含多个hw irq line，而一个hw irq line上可以由多个外设共用（共享中断），因此针对一个hw irq line，需支持提供多个action，实现针对不同外设的中断响应。

 “irq-controller”级联扩展概念示意：
```text
soc--> “irq-controller” ------> “irq-controller”
             |                           |
             |                           |------> “irq-controller”
             |-------> “irq-controller”
             |-------> “irq-controller”
        	 |-------> ...
```

```c++
/dts-v1/;

/ {
	#address-cells = <0x01>;
	#size-cells = <0x01>;
	compatible = "st,stm32f429i-disco\0st,stm32f429";
	...
	nvic: interrupt-controller@e000e100 {
		compatible = "arm,armv7m-nvic";
		interrupt-controller;
		#interrupt-cells = <0x01>;
		...
	};

	soc {
		compatible = "simple-bus";
		interrupt-parent = <&nvic>;
		ranges;

		timer@40000000 {
			compatible = "st,stm32-timer";
			interrupts = <0x1c>;
			...;
		};

		rtc: rtc@40002800 {
			compatible = "st,stm32-rtc";
			interrupt-parent = <&exti>;
			interrupts = <17 1>;
			interrupt-names = "alarm";
			...
		};

		usart1: serial@40011000 {
			compatible = "st,stm32-usart\0st,stm32-uart";
			interrupts = <0x25>;
			...
		};

		adc: adc@40012000 {
			compatible = "st,stm32f4-adc-core";
			interrupts = <0x12>;
			interrupt-controller;
			#interrupt-cells = <0x01>;

			adc1: adc@0 {
				compatible = "st,stm32f4-adc";
				interrupt-parent = <&adc>;
				interrupts = <0>;
			};
		};

		exti: interrupt-controller@40013c00 {
			compatible = "st,stm32-exti";
			interrupt-controller;
			#interrupt-cells = <0x02>;
			interrupts = <1>, <2>, <3>, <6>, <7>, <8>, <9>, <10>, <23>, <40>, <41>, <42>, <62>, <76>;
		};
	};

};
```
根据上面DTS所表达的级联关系，我们可以知道“级联多个irq controller”如下所示：
```text
        nvic-controoler  === usart1-device 
            |      |
            |      |----->exti-controller  === rtc-device
            |
		    |------> adc-controller === adc1-device
```

针对系统中所有存在的hw irq line，均为其分配logic irq index，且logic irq index是系统唯一的，因此需要提供一种map机制，实现logic irq index与hw irq line的映射。另外针对一个irq controller的所有hw irq line而言，针对该hw irq line的enable、disable。

涉及数据结构：
其中：

- `struct irq_chip` ：用于操作irq controller，实现hw irq line的使能、去使能、中断触发类型等操作；
- `struct irq_desc` ：主要用于hw irq line触发后的处理操作接口的注册等，而且该struct irq_desc是IRQ子系统的最主要数据结构，其连接了irq_chip、irq_domain数据结构；
- `struct irq_domain` ：主要用于实现logic irq index与hw irq index的映射关系，以便根据logic irq index，即可找到该irq_domain下对应的hw irq index。

## irq DTS相关

中断信号与地址不一样，中断信号可以源自和终止于机器中的任何设备。因此中断信号采用与设备树无关，而是节点之间连接（as links between nodes independent of the tree. ）来表示，我们称之为中断连接（ interrupt connections）。

中断连接（ interrupt connections）具有以下4个属性：
- `interrupt-controller` - 是一个空属性， 表示将节点声明为接收中断信号的设备
- `#interrupt-cells`- 这是中断控制器节点的属性。它说明此中断控制器的中断描述符（interrupt specifier）中有多少个单元格（类似于#address-cells和#size-cells）。
- `interrupt-parent`- 设备节点的属性，其中包含到它所连接的中断控制器的phandle。没有中断父属性的节点也可以从其父节点继承该属性。
- `interrupts`- 包含中断描述符列表的设备节点的属性，列表中每个元素代表一个该设备中断输出的中断描述符。 例如`interrupts = <0 48 4>,  <0 49 4>;` ，显然该例子中，对应中断控制器的`#interrupt-cells = <3>`。 这里要注意中断描述符完全是设备自己定义的，不存在适用所有设备的中断描述符，例如对stm32，中断描述符就是IRQn_Type的合法值。
	例如，有下面的设备节点：
	```text
		exti: interrupt-controller@40013c00 {
			compatible = "st,stm32-exti";
			interrupt-controller;
			#interrupt-cells = <0x02>;
			reg = <0x40013c00 0x400>;
			interrupts = <1>, <2>, <3>, <6>, <7>, <8>, <9>, <10>, <23>, <40>, <41>, <42>, <62>, <76>;
			linux,phandle = <0x03>;
			phandle = <0x03>;
		};
    ```
	对应的IRQn_Type值是：
	```c++
	typedef enum
	{
    ...
	PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt           */
	TAMP_STAMP_IRQn             = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI lin*/
	RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line          */
	FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                              */
	//RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                */
	//EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                */
	EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                */
	EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                */
	EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                */
	EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                */
	EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                       */
	EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
	RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
	OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
    ...
	ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
	OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
	...
	} IRQn_Type;
    ```


一个中断描述符（interrupt specifier）是一个或多个`u32`（数量通过`#interrupt-cells`指定）组成，该其中断输入所述装置被附接到指定。大多数设备只有一个中断输出，如下例所示，但一个设备上可能有多个中断输出。中断描述符（interrupt specifier）的含义完全取决于中断控制器设备的绑定。每个中断控制器可以决定它需要多少个单元来唯一地定义一个中断输入。

示例见前面的级联示意。

## BSP工程师视角使用IRQ子系统API

例子： “`linux\drivers\irqchip\irq-stm32-exti.c`”

级联控制器的例子：“`linux\drivers\pinctrl\stm32\pinctrl-stm32.c`”

### A.1.创建注册IRQ Domain

"linux\Documentation\IRQ-domain.txt"

Linux使用IRQ domain来描述一个中断控制器（IRQ Controller）所管理的中断源。换句话说，每个中断控制器都有自己的domain。我们可以将IRQ Domain看作是IRQ Controller的软件抽象,

linux kernel提供irq_domain的管理框架， 将hwirq映射到虚拟中断号上。每一个中断控制器都需要注册一个irq_domain。用来操作抽象硬件IRQ domain的就是“irq_domain->gc”。

- IRQ Domain的创建：在中断源和irq_desc之间建立线性映射：
	|API                    | 说明|
	|-----------------------|-----|
	|irq_domain_add_linear  |线性映射.|
	|irq_domain_add_tree    |树映射|
	|irq_domain_add_nomap   |不映射|
	|irq_domain_create_hierarchy| 在“级联多个irq controller”中，对非根节点场景进行创建 |

   - 线性映射:线性映射保留一张固定的表,通过hwirq number来索引.当hwirq被映射后, 会相应地分配
一个irq_desc, IRQ number就被存在表中.
	当hwirqs是固定的而且小于256, 用线性映射更好.它的优势是寻找时间固定,并且irq_descs
只在in-use IRQs分配.缺点是表格和hwirq 最大numbers一样大.
   - 树映射: 此种方法使用radix tree来维护映射, 通过key来查找.此方法适合hwirq number非常大的时候, 因为它不需要分配和hwirq一样大的table. 缺点是查表效率依赖与table里的entries数量.
   - 不映射： 当有些硬件可以对hwirq number编程时,IRQ number被编进硬件寄存器里,那么就不需要映射了.这种情况下通过irq_create_direct_mapping()实现.


例子：
```c++
	struct irq_domain_ops irq_exti_domain_ops = {
		.map	= irq_map_generic_chip,
		.xlate	= irq_domain_xlate_onetwocell,
		.alloc  = stm32_exti_alloc,
		.free	= stm32_exti_free,
	};
static int __init stm32_exti_init(struct device_node *node,
				  struct device_node *parent)
{
    // 创建irq_domain
	struct irq_domain *domain = irq_domain_add_linear(node, nr_exti,
				       &irq_exti_domain_ops, NULL);
	...
    //Allocate generic chips for the irq domain
	ret = irq_alloc_domain_generic_chips(domain, nr_exti, 1, "exti",
					     handle_edge_irq, clr, 0, 0);
	...
	// fill information to generic chips
	struct irq_chip_generic *gc = domain->gc->gc[0];
	gc->reg_base                         = base;
	gc->chip_types->type               = IRQ_TYPE_EDGE_BOTH;
	gc->chip_types->chip.name          = gc->chip_types[0].chip.name;
	gc->chip_types->chip.irq_ack       = irq_gc_ack_set_bit;
	gc->chip_types->chip.irq_mask      = irq_gc_mask_clr_bit;
	gc->chip_types->chip.irq_unmask    = irq_gc_mask_set_bit;
	gc->chip_types->chip.irq_set_type  = stm32_irq_set_type;
	gc->chip_types->chip.irq_set_wake  = stm32_irq_set_wake;
	gc->chip_types->regs.ack           = EXTI_PR;
	gc->chip_types->regs.mask          = EXTI_IMR;
	gc->chip_types->handler            = handle_edge_irq;

	nr_irqs = of_irq_count(node);
	for (i = 0; i < nr_irqs; i++) {
		//Parse and map an interrupt into linux virq space
		unsigned int virq = irq_of_parse_and_map(node, i);
        //set virq handler data for an virq
		irq_set_handler_data(virq, domain);
		//Set a highlevel chained flow handler for a given IRQ.
		irq_set_chained_handler(virq, stm32_irq_handler);
	}

	return 0;

out_free_domain:
	irq_domain_remove(domain);
out_unmap:
	iounmap(base);
	return ret;	
}			
IRQCHIP_DECLARE(stm32_exti, "st,stm32-exti", stm32_exti_init);

```

### A.2.创建IRQ domain's generic chip

前面有提到操纵IRQ Domain是通过generic chip

	|API                             | 说明|
	|--------------------------------|-----|
	|irq_alloc_domain_generic_chips  |Allocate generic chips for an irq domain.|
	||||

例子见A.1节

### A.3.为抽象硬件IRQ domain's generic chip赋值操纵回调信息

例子见A.1节

### 为irq domain创建映射

上节的内容主要是向系统注册一个irq domain，具体HW interrupt ID和IRQ number的映射关系都是空的，因此，具体各个irq domain如何管理映射所需要的database还是需要建立的。例如：对于线性映射的irq domain，我们需要建立线性映射的lookup table，对于Radix Tree map，我们要把那个反应IRQ number和HW interrupt ID的Radix tree建立起来。创建映射有四个接口函数：

方式一： 
	
	需要（必须）提供HW interrupt ID，也就是意味着driver知道自己使用的HW interrupt ID，而一般情况下，HW interrupt ID其实对具体的driver应该是不可见的，不过有些场景比较特殊，例如GPIO类型的中断，它的HW interrupt ID和GPIO有着特定的关系，driver知道自己使用那个GPIO，也就是知道使用哪一个HW interrupt ID了。

   ```c++
	// 建立HW interrupt ID和IRQ number的映射关系
	// 返回IRQ number（这个IRQ number是动态分配的）
	extern unsigned int irq_create_mapping(struct irq_domain *host,
						irq_hw_number_t hwirq);
	// 为一组HW interrupt ID建立映射
	extern int irq_create_strict_mappings(struct irq_domain *domain,
						unsigned int irq_base,
						irq_hw_number_t hwirq_base, int count);
   ```

方式二：

	在使用Device tree情况下推荐使用方式

	`irq_create_of_mapping`利用device tree进行映射关系的建立。

	对于一个使用Device tree的普通驱动程序（我们推荐这样做），基本上初始化需要调用irq_of_parse_and_map获取IRQ number，然后调用request_threaded_irq申请中断handler。


	```c++
	unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
	{
		struct of_phandle_args oirq;

		if (of_irq_parse_one(dev, index, &oirq))－－－－分析device node中的interrupt相关属性
			return 0;

		return irq_create_of_mapping(&oirq);－－－－－创建映射，并返回对应的IRQ number
	}
	```

    特别的，如果编写platform device，还有一个更简单的封装使用“`irq = platform_get_irq(pdev, index)`”,它直接从platform device resoure中查找“IORESOURCE_IRQ”资源

	这里注意，在dts的“interrupts”中存放的是 hwirq 列表。

### A.5.为virq设置handler_data,chained_handler

	|API                        | 说明|
	|---------------------------|-----|
	|irq_set_handler_data       |set virq handler data for an virq.|
	|irq_set_chained_handler    |Set a highlevel chained flow handler for a given IRQ.|
	||||

例子见A.1节

## 驱动工程师视角使用IRQ子系统API

GPIO按键驱动（"\linux\drivers\input\keyboard\gpio_keys.c"）是一个放之四海皆准的驱动，比较简单，因为简单所以通过它学习中断处理是一个较好的入口。


### A.1. 注册中断ISR

	|API                           | 说明|
	|------------------------------|-----|
	|[devm_]request_irq            |legacy|
	|[devm_]request_threaded_irq   |threaded handling method.|
	|[devm_]request_any_context_irq|根据上级中断是否是treaded，决定采用hardirq or threaded handling method|
	||||



主要是`request_irq`、`[devm_]request_threaded_irq`接口等，前者是legacy，后者是线程化的中断注册函数，目的是降低ISR对系统实时延迟的影响。如果想将ISR线程化，输入“handler=NULL， thread_fn， irqflags=IRQF_ONESHOT | ...” , irqflags特别的原因是因为”handler=NULL“意味着启用“irq_default_primary_handler”，而它是用于oneshot interrupt。

而对于大多数驱动工程师而言，基本上只需要使用该接口即可完成中断处理函数的注册。

对两个参数补充说明：
- @dev_id用于共享中断，用来标识是哪个设备触发了中断，通常传入相应设备的中断状态寄存器的地址. 传入中断处理程序的参数,注册共享中断时不能为NULL,因为卸载时需要这个做参数,避免卸载其它中断服务函数
- @name 是中断ISR名称，该值可以在/proc/interrupt中看到
- @irqflags取值在"interrupt.h"有定义，常用的有`IRQF_DISABLED`和`IRQF_SHARED`，前者表示中断程序调用时屏蔽所有中断，"所有"指的是屏蔽所有中断线的中断，本中断线的中断本来就是屏蔽的，内核默认不允许中断嵌套。IRQF_SHARED表示多个设备共享中断，即该中断线上连接了多个相同或不同的设备。
除了中断类型，flags还需要"位或"上触发方式，eg：`IRQF_DISABLED|IRQF_TRIGGER_RISING`

```c++
/**
 *	request_threaded_irq - allocate an interrupt line
 *	@irq: Interrupt line to allocate
 *	@handler: Function to be called when the IRQ occurs.
 *		  Primary handler for threaded interrupts
 *		  If NULL and thread_fn != NULL the default
 *		  primary handler is installed
 *	@thread_fn: Function called from the irq handler thread
 *		    If NULL, no irq thread is created
 *	@irqflags: Interrupt type flags 
 *	@devname: An ascii name for the claiming device
 *	@dev_id: A cookie passed back to the handler function
 *
 *	This call allocates interrupt resources and enables the
 *	interrupt line and IRQ handling. From the point this
 *	call is made your handler function may be invoked. Since
 *	your handler function must clear any interrupt the board
 *	raises, you must take care both to initialise your hardware
 *	and to set up the interrupt handler in the right order.
 *
 *	If you want to set up a threaded irq handler for your device
 *	then you need to supply @handler and @thread_fn. @handler is
 *	still called in hard interrupt context and has to check
 *	whether the interrupt originates from the device. If yes it
 *	needs to disable the interrupt on the device and return
 *	IRQ_WAKE_THREAD which will wake up the handler thread and run
 *	@thread_fn. This split handler design is necessary to support
 *	shared interrupts.
 *
 *	Dev_id must be globally unique. Normally the address of the
 *	device data structure is used as the cookie. Since the handler
 *	receives this value it makes sense to use it.
 *
 *	If your interrupt is shared you must pass a non NULL dev_id
 *	as this is required when freeing the interrupt.
 *
 *	Flags:
 *
 *	IRQF_SHARED		Interrupt is shared
 *	IRQF_TRIGGER_*		Specify active edge(s) or level
 *
 */
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
			 irq_handler_t thread_fn, unsigned long irqflags,
			 const char *devname, void *dev_id)

static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
{
	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
}
```

例子：
```c++
//linux\drivers\tty\serial\stm32-usart.c
	port->irq	= platform_get_irq(pdev, 0); //或使用irq_of_parse_and_map(pdev->dev->of_node, index)
	ret = request_threaded_irq(port->irq, stm32_interrupt,
				   stm32_threaded_interrupt,
				   IRQF_NO_SUSPEND, name, port);
	free_irq(port->irq, port);
```

### A.1. 释放中断ISR

free_irq， devm_free_irq

`void free_irq(unsigned int irqno,void * dev_id);`

## 其他API
除了上述API，内核还提供了其他的中断操作API，在内核代码中被广泛使用。
```c++
raw_local_irq_save(x)   //禁止所有中断
raw_local_irq_enable    //取消禁止中断

//下面三个函数用于可编程中断控制器，对所有CPU都有效
//屏蔽一个中断
void disable_irq(int irq);  //立即返回
void disable_irq_nosync();  //等待目前中断处理返程

//使能一个中断
void enable_irq()
```

# IIO子系统

[Linux 内核](https://blog.csdn.net/lickylin/category_6104997.html)

     本章我们对IIO子系统做一个简单的概述，IIO子系统主要提供对ADC、DAC相关的设备驱动框架，该子系统的设计目的主要是驱动那些分类时处于hwmon和input子系统之间的设备。同时查看linux内核的驱动代码，其实iio、hwmon之间的界限并不是那么明显。而iio子系统所面向的设备包含：

ADC芯片；
DAC芯片；
温度传感器；
光感器；
陀螺仪；
加速度计；
CDCs；
IMUs
压力传感器等等
————————————————
版权声明：本文为CSDN博主「jerry_chg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lickylin/article/details/108177756

# 10.tty子系统

[tty驱动分析](http://www.wowotech.net/sort/tty_framework)

下面表达的是tty子系统的不同层间的交互示意：
```text
用户空间：  write()
              |
			  v
字符设备：  char device driver
              |
			  v
tty核心：   tty_write()
              |
			  v
线路规程驱动：ldisc.write()
              |
			  v
tty驱动：   tty_driver.write()
              |
			  v
硬件层：     
```

显然对于uart这种硬件，完全可以按照上面的方式来实现其驱动。但考虑到uart这类设备有其特殊的共性，为给开发者提供更多便利，针对uart硬件，linux对tty驱动支撑api（e.g.tty_register_driver...）进行了封装，提供了独有的uart驱动支撑(e.g.uart_register_driver...),这个我们可以查看“uart_register_driver”代码得知，它内部还是调用的“tty_register_driver”。 因此针对uart这类硬件上图就可以表达为：

```text
用户空间：  write()
              |
			  v
tty核心：   tty_operations.write()
              |
			  v
线路规程驱动：ldisc.write()
              |
			  v
uart驱动(tty驱动特例)： uart_driver.write()
              |
			  v
硬件层：     uart硬件 
```



## BSP工程师视角使用

### 关键数据结构

- 特定UART相关的驱动程序结构：
```c++
struct uart_driver {
	struct module		*owner;
	const char		*driver_name;
	const char		*dev_name; /*/dev node name such as ttyS*/
	...
	struct tty_driver	*tty_driver; /*tty dirver*/
};
```

- struct uart_port

- struct uart_ops  uart驱动程序硬件上可完成的操作

### uart 驱动的关键步骤



下面的例子
```c++
static const struct uart_ops xxx_uart_ops = {
	.start_tx	= xxx_start_tx,
	...
};
static const struct dev_pm_ops xxx_pm_ops = {
	SET_SYSTEM_SLEEP_PM_OPS(xxx, xxx)
};
static const struct uart_port xxx_port ={
	.ops	= &xxx_uart_ops;
	...
}
static int xxx_serial_probe(struct platform_device *pdev)
{
	...
	ret = uart_add_one_port(&stm32_usart_driver, &xxx_port);
    ...
}
static struct platform_driver xxx_serial_driver = {
	.probe		= xxx_serial_probe,
	...
	.driver	= {.pm	= &xxx_pm_ops,...,
	},
};
static struct uart_driver xxx_usart_driver = {
	...
};

static int __init usart_init(void){
	...
	ret = uart_register_driver(&xxx_usart_driver);
	...
	ret = platform_driver_register(&xxx_serial_driver);
	...
}

static void __exit usart_exit(void)
{
	platform_driver_unregister(&xxx_serial_driver);
	uart_unregister_driver(&xxx_usart_driver);
}

module_init(usart_init);
module_exit(usart_exit);
```


# PM: 供电(Power Supply)

