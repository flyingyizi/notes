
## 1.系统调用原理

系统调用是 linux 内核为用户态程序提供的主要功能接口。通过系统调用，用户态进 程能够临时切换到内核态，使用内核态才能访问的硬件和资源完成特定功能。

实现系统调用分为三部分：

- 在用户空间触发系统调用。例如X86是通过 0x80 软中断进入内核系统调用处理， 例如 arm 通过 swi 指令进入内核的系统调用处理。无论以何种方式进入内核系统 调用处理程序，内核系统调用处理程序都会由用户态切换到内核态，并根据传递的 系统调用号信息，在内核中查找系统调用的入口。

- 第二个内容就是系统调用入口。不同的架构系统调用中断处理不同，但功能都是一致 的，那就是通过传递下来的系统调用号，找到系统调用入口信息，并将系统调用传递 的参数传递给内核里系统调用实现。

- 第三个内容就是内核部分系统调用实现。这部分就是系统调用在内核的核心逻辑， 系统调用核心逻辑接收到用户空间传递的参数之后，就根据代码逻辑进行处理， 处理完毕之后系统调用可以返回结果和数据到用户空间，实现信息交换。


```

    ──────────────────────────────────────────
              Applicaton                   ▲
    ──────────────────────────┬────────    │
          ▲                   │            │
          │                   ▼            │
    ──────┴────────────────────────────    │
              libC/Glibc                   │Userspace
    ──────────────────────────┬────────    │
          ▲                   │            │
          │                   ▼            │
    ──────┴────────────────────────────    │
              syscall()                    │
    ──────────────────────────┬─────────   │
          ▲                   │            ▼
          │                   │        ───────
          │                   ▼            ▲
    ──────┴─────────────────────────────   │
                                           │Kernel
                                           │
                                           │
                                           ▼
```

## 2.系统调用用户空间实现

用户空间触发系统调用的方法很多，包括直接调用汇编命令进行触发，也可以通过 “syscall” 函数进行触发等，这里重点介绍 “syscall()” 函数。在用户空间，开发 者可以通过调用 syscall() 函数来触发指定的系统调用，其函数定义如下:

```c++
#include <sys/syscall.h>

/**
 * number: 系统调用号，例如"#define __NR_read 63"
*/
int syscall(int number, ...);
```

## 3.系统调用入口实现

用户空间的通过软件中断触发内核的系统调用处理程序之后，处理程序会在中断 向量表里根据系统调用号找到一个系统调用入口。系统调用入口用于指向内核空间 系统调用的具体实现。由于不同架构实现系统调用入口的细节不同，但至少提供 两个信息，第一个就是系统调用号，第二个是系统调用函数。下面对每种架构进行 讲解:

### ARM32 架构
ARM32架构将系统调用入口信息放置在"`arch/arm/tools/syscall.tbl`",只需在该表中填入系统调用号、abi 类型信息、系统调用名字、系统调用函数名字 信息后就可以确定一个唯一的系统调用入口.:

```
#
# Linux system call numbers and entry vectors
#
# The format is:
# <num>	<abi>	<name>			[<entry point>			[<oabi compat entry point>]]
#
# Where abi is:
#  common - for system calls shared between oabi and eabi (may have compat)
#  oabi   - for oabi-only system calls (may have compat)
#  eabi   - for eabi-only system calls
#
# For each syscall number, "common" is mutually exclusive with oabi and eabi
#
0	common	restart_syscall		sys_restart_syscall
1	common	exit			sys_exit
2	common	fork			sys_fork
3	common	read			sys_read
4	common	write			sys_write
5	common	open			sys_open
6	common	close			sys_close
# 7 was sys_waitpid
8	common	creat			sys_creat
...
```

### ARM64 架构
ARM64 架构将系统调用入口信息放置在:"`include/uapi/asm-generic/unistd.h`". 只需在该表中定义一个系统调用号，再通过调用 __SYSCALL() 函数，出入系统 调用号和系统调用函数信息就可以确定一个唯一的系统调用入口.

### i386 架构
i386 架构将系统调用入口信息放置在:"`arch/x86/entry/syscalls/syscall_32.tbl`". 只需在该表中填入系统调用号、abi 类型信息、系统调用名字、系统调用函数名字 信息后就可以确定一个唯一的系统调用入口.

### x86_64 架构
x86_64 架构将系统调用入口信息放置在:"`arch/x86/entry/syscalls/syscall_64.tbl`". 只需在该表中填入系统调用号、abi 类型信息、系统调用名字、系统调用函数名字 信息后就可以确定一个唯一的系统调用入口.

### RISC 架构
RISCV32/64 架构将系统调用入口信息放置在:"`arch/riscv/include/uapi/asm/unistd.h`". 只需在该表中定义一个系统调用号，再通过调用 __SYSCALL() 函数，出入系统 调用号和系统调用函数信息就可以确定一个唯一的系统调用入口.

## 4.系统调用内核实现


系统调用内核实现就是系统调用在内核的实现过程。在接收到来自用户空间的系统 调用参数之后，内核核心实现就根据自己的逻辑进行处理，处理完毕之后，内核可以 将结果返回给用户空间，也可以拷贝相应的数据到用户空间。内核部分的核心实现 通过一下宏进行定义:
```c++
// 宏创建名为 sys_syscall_name() 的函数
SYSCALL_DEFINE0(syscall_name)
SYSCALL_DEFINE1(syscall_name, type0, arg0)
SYSCALL_DEFINE2(syscall_name, type0, arg0, type1, arg1,)
SYSCALL_DEFINE3(syscall_name, type0, arg0, type1, arg1, type2, arg2)
SYSCALL_DEFINE4(syscall_name, type0, arg0, type1, arg1, type2, arg2, type3, arg3)
SYSCALL_DEFINE5(syscall_name, type0, arg0, type1, arg1, type2, arg2, type3, arg3, type4, arg4)
SYSCALL_DEFINE6(syscall_name, type0, arg0, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5)
```

例如下面将会创建一个名为"`sys_nice(int increment)`" 的系统调用函数。系统调用函数可以返回一个整形值到用户空间，也可以使用 copy_to_user() 等函数将内核空间的数据帮运到用户空间：

```c++
SYSCALL_DEFINE1(nice, int, increment)
{
  ...
}
```  

## 5.系统调用参数分析
在系统调用过程中，用户空间可以和内核空间相互交换数据。交换的数据类型 可以是整形数据、字符串、数组、指针、数据结构等，每种数据类型的交互存在 差异，以及传递多个参数，下面分类讨论:

### 整形数据

用户空间可用通过系统调用可以将一个或多个整形数据传递给内核空间。对于 整形参数，用户空间只是传递整形值到内核空间，因此内核部分的系统调用函数 可以利用自己的函数堆栈暂存，因此内核空间和用户空间不必进行跨区拷贝操作。 系统调用参数支持的整形包括了: char, unsigned char, short, unsigend short, int, unsigned int, long, unsigned long, long long, unsigned long long 等。

用户空间对应的系统调用，只需传递函数形参或整形常量即可，使用例子如下:
```c++
int main(void)
{
        unsigned long long integer_llong = 0x12345678abcdef88;
        unsigned long integer_long = 0x98765432;
        int integer_int = 0x12345678;
        short integer_short = 0x1234;
        char integer_char = 'B';
        bool enable = true;
        int ret;

        /*
         * sys_hello_demo: Integer paramenter
         * kernel:
         *       SYSCALL_DEFINE6(hello_demo,
         *                       bool, enable,
         *                       char, integer_char,
         *                       short, integer_short,
         *                       int, integer_int,
         *                       unsigned long, integer_long,
         *                       unsigned long long, integer_llong);
         */
        ret = syscall(__NR_hello_demo,
                                        enable,
                                        integer_char,
                                        integer_short,
                                        integer_int,
                                        integer_long,
                                        integer_llong);
        return 0;
}
```

### 字符串数据

用户空间可用通过系统调用可以将一个或多个字符串数据传递给内核空间。对于 字符串参数，用户空间必须通过指针的方式传到内核空间，由于这样的方式导致 内核空间不能直接访问用户空间的数据，会导致内核非法访问。

因此对于这种情况， 内核首先通过"`copy_from_user`"将用户空间的数据拷贝到内核空间，这样才能安全使用数据。内核也可以 将内核字符串数据传递给用户空间，此时也不能直接传，也需要通过安全的拷贝("`copy_to_user`") 操作才能完整任务。用户空间的系统调用部分传递的是一个指针，因此内核向 用户空间传递字符串时，可以使用安全的拷贝函数将字符串放置到用户空间指针 对应的位置。字符串相关的参数可以是一个字符串常量、字符数组、字符、字符 指针，字符串相关的结构体. 用户空间使用格式如下:
```c++
int main(void)
{
        const char *strings = "Hello demo";
        char *buffer[128];
        char ch = 'B';
        char *ptr;
        struct demo_node node = {
                .nr = 20,
        };
        int ret;

        /* malloc */
        ptr = (char *)malloc(128);

        /*
         * sys_hello_BiscuitOS: String paramenter
         * kernel:
         *       SYSCALL_DEFINE5(hello_demo,
         *                       char, ch,
         *                       char __user *, const_string,
         *                       char __user *, string_array,
         *                       char __user *, string_ptr,
         *                       struct demo_node __user *, string_struct);
         */
        ret = syscall(__NR_hello_demo,
                                        ch,
                                        strings,
                                        buffer,
                                        ptr,
                                        &node);
        return 0;
}
```

从上面的定义可以出，只要是从用户空间传递的指针参数，都需要添加 “`__user`” 进行强制说明，这是内核检测机制使用的符号，不影响函数的实际 功能。从上述也看到不论是字符串常量，还是数据结构都需要指针方式传递， 只有字符不需要。

### 数组数据

定义与使用同“字符串数据”章节。

### 指针数据

定义与使用同“字符串数据”章节。

### 传递零个参数

使用“`SYSCALL_DEFINE0`”,典型如 “sys_getgroups()” 、”sys_getppid()” 等的实现。

### 传递一个参数

这类系统在内核的实现 使用 “`SYSCALL_DEFINE1`” 定义，典型比如 “sys_exit()” 、”sys_close()” 等的实现。

### 传递两个参数

这类系统在内核的实现 使用 “SYSCALL_DEFINE2()” 进行定义。典型如 “sys_link()” 、”sys_chmod()” 等的实现。

### 传递三个参数
### 传递四个参数
### 传递五个参数
### 传递六个参数


