
[设备树官方文档](http://devicetree.org/Device_Tree_Usage) [最新设备树官方文档](https://www.devicetree.org/specifications/)

[how-to-program-linux-dts-device-tree-files](https://stackoverflow.com/questions/17488320/how-to-program-linux-dts-device-tree-files)

linux 内核中和设备树相关的函数 内核关于设备树的驱动都放在 `/drivers/of` 下，用户可以使用这里面的函数对设备树进行操作。

`ls /proc/device-tree/` 用于查看设备树节点


# 维护

- 在目标设备上查看设备树：`ls /sys/firmware/devicetree/base`

- 查看原始dtb文件：`hexdump -C /sys/firmware/fdt`

- 以目录结构呈现dtb文件：`/sys/firmware/devicetree // 以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件`.
  

- 在目标设备上的打印整个设备树："`$ dtc -I fs /proc/device-tree`" 或 "`$ dtc -I fs /sys/firmware/devicetree/base/`". 注1：通过"`apt-get install device-tree-compiler`"安装dtc。 注2：`/proc/device-tree` 是链接文件, 指向 `/sys/firmware/devicetree/base`

- 在linux-source 查看DTS
    我们知道，linux-source中的dts分为多个文件，有时看起来不是很方便。下面演示了如何将它们转换为一个文件，例子以rpi-3-b板子为例：

    ```shell
    $ git clone https://github.com/raspberrypi/linux.git
    $ export CROSS_COMPILE=arm-linux-gnueabihf-
    $ export ARCH=arm
    $ export KERNEL=kernel7
    $ make bcm2709_defconfig
    $ cd linux/
    $ make bcm2709_defconfig
    $ make dtbs
    $ cp arch/arm/boot/dts/bcm2710-rpi-3-b.dtb ~/
    $ make clean

    # 使用fdtdump
    ~/$ fdtdump -s ~/bcm2710-rpi-3-b.dtb 
    # 使用dtc， dtc建议使用linux/scripts/dtc/dtc
    ~/$ dtc -I dtb -O dts -o output.dts  ~/bcm2710-rpi-3-b.dtb 
    ```
- 安装gpio工具  `sudo apt-get install gpiod`


# rpi3 分析

https://gitee.com/low-level-of-logic/RaspberryPi/blob/master/docs/0001_%E6%97%A0%E5%B1%8F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE.md

[BCM2835 datasheet](https://www.alldatasheet.com/datasheet-pdf/pdf/502533/BOARDCOM/BCM2835.html)

~/rpi-kernels$ cd linux
~/rpi-kernels/linux$ git checkout d9db059cb982c5478a464c1ff8ce8b17f7768dcc # --> (4.14.21)

rpi-kernels/linux/arch/arm/boot/dts/bcm2710-rpi-3-b.dts

## gpiomem为例 分析用户空间使用

由“linux\drivers\char\broadcom\bcm2835-gpiomem.c”可知道，“/dev/gpiomem”提供了gpio空间的mem-map。同时我们也知道，直接访问内存空间的方法如下：
```go
	file, err := os.OpenFile("/dev/gpiomem", os.O_RDWR|os.O_SYNC, 0660) //|os.O_CLOEXEC
	...
	gpio, err := syscall.Mmap(int(file.Fd()), GPIO_BASE, uint32BlockSize,
	...
```
这里关键的是如何知道“GPIO_BASE”应该填写什么值。 下面我们以raspberry pi 3b为例，说明如何从设备树中来得到它。

下面是rpi3 设备数的一个片段（在目标设备上的打印整个设备树可以通过："`$ dtc -I fs /proc/device-tree`"得到）
```text
/ {
	compatible = "raspberrypi,3-model-b", "brcm,bcm2837";
	soc {
		compatible = "simple-bus";
		ranges = <0x7e000000 0x3f000000 0x1000000 0x40000000 0x40000000 0x1000>;
        ...
		gpiomem@7e200000 {
			compatible = "brcm,bcm2835-gpiomem";
			reg = <0x7e200000 0x1000>;
		};
        ...
		gpio: gpio@7e200000 {
			compatible = "brcm,bcm2835-gpio";
			gpio-controller;
			reg = <0x7e200000 0xb4>;
            ...
        }；
    };
};
```

- 首先根据“linux\drivers\char\broadcom\bcm2835-gpiomem.c”中的match compatible，确认该驱动对应的设备节点是"`/soc/gpiomem@7e200000`"
- gpiomem 节点的unit-address是“`0x7e200000`”. 
- gpiomem 节点的父节点（soc）有ranges属性（"`ranges = <0x7e000000 0x3f000000 0x1000000 0x40000000 0x40000000 0x1000>;`"），根据定义`ranges = <child-bus-address1 parent-bus-address1  length1 [child-bus-address2 parent-bus-address2 length2] ... >`,结合上面gpiomem unit-address信息，在soc层面gpiomem对应的地址应该是"`0x3f000000 + 0x200000`"

- 在soc层面gpiomem对应的地址,也就是我们前面要求解的“GPIO_BASE”

