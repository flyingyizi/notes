[设备树官方文档](http://devicetree.org/Device_Tree_Usage) [最新设备树官方文档](https://www.devicetree.org/specifications/)

[how-to-program-linux-dts-device-tree-files](https://stackoverflow.com/questions/17488320/how-to-program-linux-dts-device-tree-files)

linux 内核中和设备树相关的函数 内核关于设备树的驱动都放在 `/drivers/of` 下，用户可以使用这里面的函数对设备树进行操作。

`ls /proc/device-tree/` 用于查看设备树节点

# 1.内核与设备树

[系统启动时, dts 是怎么被加载的](https://blog.csdn.net/lichengtongxiazai/article/details/38941913)

## 1.1.加载linux os （有/无设备树）


### 无设备树：
    bootloader在加载kernel image前，会将单板型号（machine type，一个整型数）放在r1寄存器里，内核启动时获取到machine type integer，进而找到用于描述单板的machine_desc，machine_desc定义是“`const struct machine_desc *machine_desc;`”. 它里面包含了所有硬件信息.

    所有单板相关的硬件信息都是hard-coded，例如“`arch/arm/mach-*`”

### 有设备树：

    ”linux/arch/arm/kernel/head.S“文件定义了bootloader和kernel的参数传递要求：
    ```c++
    /*
    * Kernel startup entry point.
    * ---------------------------
    *
    * This is normally called from the decompressor code.  The requirements
    * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
    * r1 = machine nr, r2 = atags or dtb pointer.
    *
    * This code is mostly position independent, so if you link the kernel at
    * 0xc0008000, you call this at __pa(0xc0008000).
    *
    * See linux/arch/arm/tools/mach-types for the complete list of machine
    * numbers for r1.
    *
    * We're trying to keep crap to a minimum; DO NOT add any machine specific
    * crap here - that's what the boot loader (or in extreme, well justified
    * circumstances, zImage) is for.
    */
    ```

    目前的kernel支持旧的tag list的方式，同时也支持device tree的方式。r2可能是device tree binary file的指针（bootloader要传递给内核之前要copy到memory中），也可以能是tag list的指针。在ARM的汇编部分的启动代码中（主要是head.S和head-common.S），machine type ID和指向DTB或者atags的指针被保存在变量__machine_arch_type和__atags_pointer中，这么做是为了后续c代码进行处理。与DTS相关具体的c代码都是在setup_arch中处理

    单板相关的硬件信息保存到dtb里面，bootloader启动内核需要加载kernel image and dtb。machine_desc由内核自己解析dtb构造得到，该构造由`setup_machine_fdt(__atags_pointer)`。这里的__atags_pointer = r2寄存器 = dt_phys = DTB文件的地址。

    后面就是内核对设备树的处理，过程为：`start_kernel -> setup_arch -> unflatten_device_tree -> __unflatten_device_tree`。

    注意，在setup_arch中，通过early_init_dt_reserve_memory_arch/memblock_reserve 把dtb所占区域保留下来。 保留大小信息是通过 在设备树文件中“/memreserve/”指定一块内存，这块内存就是保留的内存，内核不会占用它。即使我们没有指定这块内存，当我们内核启动时，他也会把设备树所占用的区域保留下来，但大小就不是我们控制的了。

## 1.2.采用设备树移植板，板级最小修改

- 对设备板级源文件，最小改动要求见“`arch/arm/mach-stm32/board-dt.c`”例子.

    ```c++
    static const char *const stm32_compat[] __initconst = {
        "st,stm32f429",
        "st,stm32f469",
        "st,stm32f746",
        "st,stm32h743",
        NULL
    };

    DT_MACHINE_START(STM32DT, "STM32 (Device Tree Support)")
        .dt_compat = stm32_compat,
        .restart = armv7m_restart,
    MACHINE_END
    ```

    “linux\arch\arm\include\asm\mach\arch.h”文件中宏"`DT_MACHINE_START(_name, _namestr)`"定义用于在"`__section__(".arch.info.init")`"段中,用于编译时填充数据，数据是编译静态平台对象“`static const struct machine_desc __mach_desc_##_name`”。在linux启动时，“setup_machine_fdt”会识别DT compatible是否与该平台对象匹配，如果不匹配，会失败并中断启动过程。

- 确保"`menuconfig--boot options--flattened device tree`" enable

### 平台对象machine_desc说明

平台对象类型“`struct machine_desc`”,针对不同的平台（例如x86与arm），结构定义不同。
内核会维护一个全局平台对象“`machine_desc`”,在setup_arch中对他会根据编译静态平台对象信息进行赋值。
```c++
//linux\arch\arm\kernel\setup.c
const struct machine_desc *machine_desc __initdata;
```

## 1.3.采用设备树描述的设备与驱动匹配

对udev下的情况，总线将设备和驱动绑定。在系统每注册一个设备的时候． 会寻找与之匹配的驱动． 相反的，在系统每注册一个驱动的时候． 会寻找与之匹配的设备． 而匹配由总线完成。冷插拔的情况特殊些，linux是通过sysfs里面的uevent节点中新增“add”，来触发内核重新发送冷插拔的netlink事件，udev处理该事件，从而完成上面提到的匹配。

匹配逻辑见“驱动开发.md-->platform 设备驱动”章节描述， 对于其他总线，类似i2c_bus_type, pci_bus_type...原理类似。

## 1.4.获取采用设备树描述设备的资源

加载内核模块驱动程序后，是时候控制硬件资源了。例如，能够读取和写入寄存器，并接收其中断。

- of.h : 设备树的一般处理函数
- of_address.h :  地址相关函数，比如 of_get_address用来获得reg属性中的addr/size
- of_dma.h   :
- of_gpio.h  :
- of_graph.h :  gpu相关
- of_iommu.h :  很少用到
- of_irq.h   :  中断相关
- of_mdio.h  :  MDIO(ethernet phy)
- of_net.h   :  OF helper for network devices
- of_pci.h   :  
- of_pdt.h   :  很少用到
- of_reserved_mem.h :


以下面设备树中的节点为例，我们演示如何获取该节点设备的资源：
```c++
    xillybus_0: xillybus@50000000 {
      compatible = "xlnx,xillybus-1.00.a";
      reg = < 0x50000000 0x1000 >;
      interrupts = < 0 59 1 >;
      interrupt-parent = <&gic>;

      ...
    } ;
```

### Accessing registers
注意： 访问寄存器应使用iowrite32(), ioread32() and other io-something functions and macros. All device drivers demonstrate this.
```c++
static int __devinit xilly_drv_probe(struct platform_device *op)
{
  const struct of_device_id *match;

  match = of_match_device(xillybus_of_match, &op->dev);
  /* The first operation is a sanity check, verifying that the probe was called on
     a device that is relevant. This is probably not really necessary, but this check appears in many drivers*/
  if (!match)
    return -EINVAL;

  int rc = 0;
  struct resource res;
  void *registers;
  /* populates the “res” structure with the memory segment given by the first “reg” assignment (hence the second argument = 0) 
     in the peripheral’s device tree entry. In our example it’s “reg = < 0x50000000 0x1000 >”, meaning that 
     the allocated chunk starts at physical address 0x50000000 and has the size of 0x1000 bytes. 
     of_address_to_resource() will therefore set res.start = 0x50000000 and res.end = 0x50000fff.*/
  rc = of_address_to_resource(&op->dev.of_node, 0, &res);
  if (rc) {
    /* Fail */
  }
  /* Then request_mem_region() is called in order to register the specific memory segment, like any device driver. 
     The purpose is just to avoid clashes between two drivers accessing the same register space (which should 
     never happen anyhow). The resource_size() inline function returns the size of the segment, as one would expect (0x1000 in this case).*/
  if  (!request_mem_region(res.start, resource_size(&res), "xillybus")) {
    /* Fail */
  }
  /* The of_iomap() function is a combination of of_address_to_resource() and ioremap(), and is essentially 
     equivalent to ioremap(res.start, resource_size(&res)). It makes sure that the physical memory segment has a 
     virtual memory mapping, and returns the virtual address of the beginning of that segment.*/
  /* The correct way to access hardware registers is with iowrite32(), ioread32() and other io-something 
     functions and macros. All device drivers demonstrate this.*/     
  registers = of_iomap(op->dev.of_node, 0);

  if (!registers) {
    /* Fail */
  }
```

### Attaching the interrupt handler
在驱动中关联ISR(中断处理程序)是比较简单的，例如：
```c++
static int __devinit xilly_drv_probe(struct platform_device *op)
{
  ...  
  /* The irq_of_parse_and_map() call merely looks up the interrupt’s specification in the device tree (more about this below) 
     and returns its identifying number, as request_irq() expects to have it (”irq” matches the enumeration in /proc/interrupts as well). 
     The second argument, zero, says that the first interrupt given in the device tree should be taken.*/  
  irq = irq_of_parse_and_map(op->dev.of_node, 0);
  /* then request_irq() registers the interrupt handler. */
  rc = request_irq(irq, xillybus_isr, 0, "xillybus", op->dev);

}
```

### Application-specific data

例如，有个LCD设备，关于它的尺寸信息可以放在设备树中。例如对UART，FREQ可以放在设备树中。

假设设备树中有如下的信息
```c++
    lcd: lcd@50000000 {
      compatible = "xlnx,lcd";
      reg = < 0x50000000 0x1000 >;
      xlnx,slv-awidth = <0x20>;
      ...
    } ;
```
可以通过类似下面的方式来获取到该尺寸信息：
```c++
  void *ptr;
  /* The third argument in the call, NULL, is possibly a pointer to an int variable, to which the length of the data is written.*/
  ptr = of_get_property(op->dev.of_node, "xlnx,slv-awidth", NULL);

  if (!ptr) {
    /* Couldn't find the entry */
  }
  /* To access the actual data, assuming that it’s a number, go*/
  /* The be32_to_cpup reads the data from the address given by “ptr”, converts from Big Endian to the processor’s 
     native Little Endian, so “value” will contain the integer one expects it to contain.*/
  int value = be32_to_cpup(ptr);
```




For example, if the hardware is an LCD display driver, the information about its pixel dimensions and maybe even physical dimensions may appear in the device tree. Serial port interface hardware (i.e. RS-232, UART) is likely to inform the driver about what clock frequency is driving the logic, so that the driver can set up the clock division registers correctly. And so on.

# 2.DTS规范解读

## device tree usage

- 一个dts文件中就是若干嵌套组成的node，property以及child note、child note property描述。
- 在DTS中，涉及到"property"属性，格式是"`<property>[=<value>];`." 值：
  - 可能没有，
  - 可能一个或多个u32值(e.g. `<0x40014000 0x400>`)，
  - 可能为字符串(e.g. `"memory"`)，
  - 可能为字符串列表(e.g. `"PowerPC,970"`) 

- 在DTS中，涉及到"cell"这个术语，在Device Tree表示32bit的信息单位
- 在DTS中，每个设备(device)在设备树中是一个节点(node)。一个node定义为：
```text
[label:] node-name[@unit-address] {
   [properties definitions]
   [child nodes]
}
```
node names:
    值得花点时间讨论一下命名约定。每个节点都必须有一个格式为<name>[@<unit-address>]的名称。
    
    `<name>`是一个简单的 ascii 字符串，最长可达 31 个字符。通常，节点根据它代表的设备类型来命名。例如3com 以太网适配器的节点将使用名称ethernet，而不是3com509.

    如果节点描述具有地址的设备，则包括单元地址。通常，单元地址是用于访问设备的主要地址，并列在节点的reg属性中。我们将在本文档后面介绍 reg 属性。

    The unit-address must match the first address specified in the reg property of the node. If the node has no reg property, the `@` and `unit-address` must be omitted and the node-name alone differentiates the node from other nodes at the same level in the tree.
    
    兄弟节点必须唯一命名，但只要地址不同（即serial@101f1000 & serial@101f2000），多个节点使用相同的通用名称是正常的。有关节点命名的完整详细信息，请参阅 ePAPR 规范的第 2.2.1 节。

注意： 根节点没有“node name”，适用slash "/"指示。


假设有下面一台由"Acme"制造名为 "Coyote's Revenge"的机器:

- One 32bit ARM CPU
- processor local bus attached to memory mapped serial port, spi bus controller, i2c controller, interrupt controller, and external bus bridge
- 256MB of SDRAM based at 0
- 2 Serial ports based at 0x101F1000 and 0x101F2000
- GPIO controller based at 0x101F3000
- SPI controller based at 0x10170000 with following devices
    - MMC slot with SS pin attached to GPIO #1
- External bus bridge with following devices
    - SMC SMC91111 Ethernet device attached to external bus based at 0x10100000
    - i2c controller based at 0x10160000 with following devices
      - Maxim DS1338 real time clock. Responds to slave address 1101000 (0x58)
    - 64MB of NOR flash based at 0x30000000

基于上面的信息,我们将每个节点来填充设备树，当前每个节点还是空的。
```text
/dts-v1/;

/ {
    compatible = "acme,coyotes-revenge";

    cpus {
        cpu@0 {            compatible = "arm,cortex-a9";        };
        cpu@1 {            compatible = "arm,cortex-a9";        };
    };

    serial@101F0000 {        compatible = "arm,pl011";    };

    serial@101F2000 {        compatible = "arm,pl011";    };

    gpio@101F3000 {        compatible = "arm,pl061";    };

    interrupt-controller@10140000 {        compatible = "arm,pl190";    };

    spi@10115000 {        compatible = "arm,pl022";    };

    external-bus {
        ethernet@0,0 {            compatible = "smc,smc91c111";        };

        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            rtc@58 {                compatible = "maxim,ds1338";            };
        };

        flash@2,0 {            compatible = "samsung,k8f1315ebm", "cfi-flash";        };
    };
};
```

### 寻址原理

如果一个device node中包含了有寻址需求（要定义reg property）的sub node（后文也许会用child node，和sub node是一样的意思），那么该device node就必须要定义这两个属性:“#address-cells”/“#size-cells”

可寻址设备（device）使用以下属性将地址信息编码在设备树里面：
- `reg`  ： 格式是`reg = <address1 length1 [address2 length2] [address3 length3] ... >`. 每个“address1 length”代表被设备使用的address range。每个address 是x个u32的list，每个length是y个u32的list.
  总结来说就是reg信息怎么解析，由reg所在子节点的关联父节点的“#address-cells”/“#size-cells”规定来确定。
- `#address-cells=<x>`  : 表示用x 个u32 来描述地址
- `#size-cells=<y>`     ：表示用y 个u32 来描述大小（长度）

注意： 按照惯例，如果节点具有reg属性，则节点名称必须包含单元地址，这是reg属性中的第一个地址值。 这不是强制性的。

例如：
```c++
/ {
        #address-cells = <0x1>;    // 在 root node 下的sub-node使用 1 个 u32 來代表 address。
        #size-cells = <0x0>;       // 在 root node 下的sub-node使用 0 个 u32 來代表 size。
        ...
        memory {        // memory device
                ... 
                reg = <0x90000000>; // 0x90000000 是存取 memory 的 address 
                ... 
        }; 
        ... 
  }
```

```c++
/ {
        #address-cells = <0x2>;    // 在 root node 下的sub-node使用 2 个 u32 來代表 address。
        #size-cells = <0x1>;       // 在 root node 下的sub-node使用 1 个 u32 來代表 size。
        ...
        ...
        memory@90000000,00000000 {        // memory device
            ... 
            reg = <0x90000000 00000000 0x800000>; // 0x90000000 00000000 是存取 memory 的 address // 0x800000 是 memory 的 size。 
            ... 
        }; 
        ... 
  }
```

对非内存映射设备，

### 地址转换

注意非根直接子节点设备分配的地址仅仅是设备域（device domain）的，和CPU使用的地址（cpu domain）是不同的域，因此涉及设备地址到CPU可以使用地址的转换。

约定：
- 不是根的直接子节点的节点不使用 CPU 的地址域。为了获得内存映射地址，设备树必须指定如何将地址从一个域转换为另一个域。ranges物业用于此目的。

- 根节点总是描述 CPU 对地址空间的看法。根的直接子节点已经在使用 CPU 的地址域，因此不需要任何显式映射。

- 如果父地址空间和子地址空间相同，则节点可以改为添加空ranges属性。空范围属性的存在意味着子地址空间中的地址按 1:1 映射到父地址空间。

我们已经讨论了如何为设备分配地址，但此时这些地址仅适用于设备节点。它还没有描述如何从这些地址映射到 CPU 可以使用的地址。

ranges是地址转换列表。范围表中的每个条目都是一个元组，包含子地址、父地址和子地址空间中区域的大小。每个字段的大小是通过取子#address-cells值、父#address-cells值和子#size-cells值来确定的。对于我们示例中的external-bus，子地址为 2 个单元格，父地址为 1 个单元格，大小也是 1 个单元格。 参见下面例子中的注释说明。

例子：添加了 range 属性的示例设备树。

```c++
/dts-v1/;

/ {
    compatible = "acme,coyotes-revenge";
    #address-cells = <1>;
    #size-cells = <1>;
    /* 根直接子节点，因此直接分配地址 0x101f0000 */
    serial@101f0000 { 
        compatible = "arm,pl011"; reg = <0x101f0000 0x1000>; 
    };     
    ...
    external-bus {
        #address-cells = <2>;
        #size-cells = <1>;
        /*  <the child address, the parent address, and the size of the region in the child address space>.*/
        /* 设备地址"0 0"映射到CPU可访问地址0x10100000..0x1010ffff*/
        /* 设备地址"1 0"映射到CPU可访问地址0x10160000..0x1016ffff*/
        /* 设备地址"2 0"映射到CPU可访问地址0x30000000..0x30ffffff*/
        ranges = <0 0  0x10100000   0x10000     // Chipselect 1, Ethernet
                  1 0  0x10160000   0x10000     // Chipselect 2, i2c controller
                  2 0  0x30000000   0x1000000>; // Chipselect 3, NOR Flash

        ethernet@0,0 {
            compatible = "smc,smc91c111";
            reg = <0 0 0x1000>;
        };
        
        /* You should also notice that there is no ranges property in the i2c@1,0 node. The reason for 
           this is that unlike the external bus, devices on the i2c bus are not memory mapped on the CPU's 
           address domain. Instead, the CPU indirectly accesses the rtc@58 device via the i2c@1,0 device. 
           The lack of a ranges property means that a device cannot be directly accessed by any device other than it's parent.*/
        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            #address-cells = <1>;
            #size-cells = <0>;
            reg = <1 0 0x1000>;
            rtc@58 {
                compatible = "maxim,ds1338";
                reg = <58>;
            };
        };

        flash@2,0 {
            compatible = "samsung,k8f1315ebm", "cfi-flash";
            reg = <2 0 0x4000000>;
        };
    };
};
```

### 传递runtime parameter

chosen node主要用来描述由系统firmware指定的runtime parameter。如果存在chosen这个node，其parent node必须是名字是“/”的根节点。原来通过tag list传递的一些linux kernel的运行时参数可以通过Device Tree传递。属性包括:
- bootargs : command line可以通过bootargs这个property这个属性传递；
- `linux,initrd-start` 与 `linux,initrd-end`: initrd的开始地址也可以通过linux,initrd-start这个property这个属性传递。在本例中，chosen节点是空的，在实际中，建议增加一个bootargs的属性，例如：

- stdout-path : A string that specifies the full path to the node representing the device to be used for boot console output. If the character “:” is present in the value it terminates the path. The value may be an alias. If the stdin-path property is not specified, stdout-path should be assumed
to define the input device.

- stdin-path ： used for boot console input
例子：
```c++
	chosen {
		bootargs = "root=/dev/ram";
		stdout-path = "serial0:115200n8";
		linux,initrd-start = <0x4500040>;
		linux,initrd-end   = <0x4800000>;
	};
```

### 别名 (/aliases 节点)

alias节点必须位于根，而且名字必须是aliases，即该节点全路径必须是"`/aliases`". 该节点的每条属性的格式是“`alias-name = string-of-full-path-to-a-node;`”, 其中“`alias-name`”的格式是“`<stem><id>`”, 例如对“spi0 = "/spi@13920000";”，stem是"spi",id是0.

例子如下：

```c++
/ {
	...

	aliases {
		serial0 = &uart0;
        spi0 = "/spi@13920000";
	};

	fpga {
		...
		uart0: serial@f0000000 {
            ...
		};
    };
};    
```

### 列表

下面两种列表表达方式是等效的
```text
			clocks = <&clk_osc>,
				<&dsi0 0>, <&dsi0 1>, <&dsi0 2>,
				<&dsi1 0>, <&dsi1 1>, <&dsi1 2>;
```
```text
			clocks = <&clk_osc &dsi0 0 &dsi0 1 &dsi0 2 &dsi1 0 &dsi1 1 &dsi1 2>;
```


## 设备树标准属性介绍

该内容来自EPAPR 规范

### compatible

用于选择设备驱动。 建议格式是：`“manufacturer1,model1” [, “manufacturer2,model2”]...` . 选择匹配时从左到右扫描，一旦匹配立即终止匹配。

例子：`compatible = “fsl,mpc8641-uart”, “ns16550"; `

### model

用于指示设备制造商的型号(model)。 见格式是：`“manufacturer,model”`

例子： `model = “fsl,MPC8349EMITX”;`


### phandle

用于在设备数中为一个节点分配一个数字ID。 其他节点可以适用该phandle来引用该节点。  在老版本中也有适用`linux,phandle`的。

编写DTS时，强烈不建议显示适用phandle， 它的目的应仅仅是DTS后台编译所使用。

```c++
pic@10000000 { 
   phandle = <1>; 
   interrupt-controller; 19
}; 

/* A phandle value of 1 is defined. Another device node could reference the pic node with a 22 phandle value of 1: */
xyz {
    ...
    interrupt-parent = <1>;
    ...
};
```

### status 

用于定义设备的运行状态。 从linux-source看，几乎没有使用该属性。

Table 2-4 Values for status property 8

|Value      |  Description           |
|-----------|------------------------|
|“okay”     |  指示设备处于运行态     |
|“disabled” |  指示设备处于disable态  |
|“fail”     |  指示设备处于失败态，如果不修复不会变为运行态 |
|“fail-sss” |  指示设备处于特定失败条件的失败态，sss代表条件。如果不修复不会变为运行态 |

例子：
```c++
&i2c2 {
	...
	status = "okay";

	ltc3676: pmic@3c {
        ...
    };
```

### #address-cells and #size-cells 

`#address-cells and #size-cells` 属性可用于在设备树中具有子节点的任何设备节点，这些属性用于描述设备节点中的子节点如何寻址。 

- `#address-cells`属性定义子节点中`reg`属性中的address由几个u32构成。
- `#size-cells`属性定义子节点中`reg`属性中的size(length)由几个u32构成。

注意`#address-cells and #size-cells` 属性并不会有继承处理，它们必须需要使用它们的节点中显示的定义。

虽然有上面的规范要求，为了安全起见，约定如果缺失，则应假定`#address-cells = <2>; #size-cells=<1>;`

### reg 

`reg`属性用于描述 在其父总线域中的 设备资源的地址,通常理解为`<offset, length>`。

格式是`reg = <address1 length1 [address2 length2] [address3 length3] ... >`. 其中address，length 各由几个u32组成，由该属性所在节点的父节点中的`#address-cells and #size-cells`指定。特别的，如果`#size-cells=<0>;`, 则length应省略。

Example: 
Suppose a device within a system-on-a-chip had two blocks of registers—a 32-byte block at offset 0x3000 in the SOC and a 256-byte block at offset 0xFE00. The reg property would be encoded as follows (assuming #address-cells and #size-cells values of 1): `reg = <0x3000 0x20 0xFE00 0x100>;`

### ranges

用于提供节点地址域，与其父节点地址域的转换。
The ranges property provides a means of defining a mapping or translation between the address space of the bus (the child address space) and the address space of the bus node's parent (the parent address space). 

格式是`ranges = <child-bus-address1 parent-bus-address1  length1 [child-bus-address2 parent-bus-address2 length2] ... >`

- `child-bus-address` : is a physical address within the child bus’ address space. The number of cells to represent the address is bus dependent and can be determined from the #address-cells of this node (the node in which the ranges property appears). 
- `parent-bus-address`: is a physical address within the parent bus’ address space. The number of cells to represent the parent address is bus dependent and can be determined from the #address-cells property of the node that defines the parent’s address space. 
- `length` : specifies the size of the range in the child’s address space. The number of cells to represent the size can be determined from the #size-cells of this node (the node in which the ranges property appears). 

If the property is defined with an <empty> value, it specifies that the parent and child address space is identical, and no address translation is required. 
例子：
```c++
	reserved-memory {
		#address-cells = <2>;
		#size-cells = <2>;
		ranges;
		/*
		 * We just move frame buffer area to the very end of
		 * available DDR. And even though in case of ARC770 there's
		 * no strict requirement for a frame-buffer to be in any
		 * particular location it allows us to use the same
		 * base board's DT node for ARC PGU as for ARc HS38.
		 */
		frame_buffer: frame_buffer@9e000000 {
			compatible = "shared-dma-pool";
			reg = <0x0 0x9e000000 0x0 0x2000000>;
			no-map;
		};
	};
```

If the property is not present in a bus node, it is assumed that no mapping exists between children of the node and the parent address space.

例子：
```c++
/{
   soc {
        compatible = "simple-bus";
        #address-cells = <1>;
        #size-cells = <1>;
        /* specifies that for an 1024KB(0x00100000) range of address space, a child node addressed at physical 0x0 maps to a 
           parent address of physical 0xe0000000. */
        /* With this mapping, the serial device node can be addressed by a load or store at address 0xe0004600, 
           an offset of 0x4600 (specified in reg) plus the 0xe0000000 mapping specified in ranges*/
        ranges = <0x0 0xe0000000 0x00100000>;       
        ...
        serial@4600 {
            device_type = "serial";
            compatible = "ns16550";
            reg = <0x4600 0x100>;
            clock-frequency = <0>;
            interrupts = <0xA 0x8>;
            interrupt-parent = < &ipic >;            
        };
   }
};
```

## device bindings

bindings这个概念的理解：

- 当通过设备树来描述一个设备时，bindings应是该设备树所有属性的一个子集。 该子集能为该设备驱动提供所需的足够信息。

- 在设备树规范中，对每个设备，提出了device bindings规范要求。比如对Serial devices，要求有clock-frequency Property。

- 在linux-source中，每一个内核子系统或者framework都有自己的bindings要求，所有内核支持的bindings说明文档都位于Documentation/devicetree/bindings。这里面的内容就是内核所支持设备的支持代码所需要的设备树属性要求。

总结： DTS规范（devicetree-specification-v0.3.pdf）是basic，定义了通用的属性、规则，以及某些设备（比如serial devices）的bindings，它不可能罗列所有设备。比如对特定设备（比如gpio），它需要哪些属性？比如`gpio-controller`就是在linux下的bindings里面定义的。

# 设备树overlay

## A.1.静态设置 

静态overlay指分include文件编写DTS

### 规则1：对于同一个节点的设置情况，可以覆盖

    对类似下面，不同的内容叠加，相同的属性以dts中为准。
    ```c++
    //file :xxxx.dts
    #include "xxxx.dtsi"
    ...
    ```

    但假如`#include `在最后，那就是：不同的内容叠加，相同的属性以dtsi中为准。

    显然这和我们在C中的include经验是一致的。

    下面的例子演示了覆盖dtsi的场景 .[例子图片版](https://img-blog.csdnimg.cn/20200301215648492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpa3VuYmFpNTcwOA==,size_16,color_FFFFFF,t_70)：

    xx.dtsi 内容：
    ```c++
    /{
    compatible = "ti,am33xx";
    ocp {
        uart0 : serial@44e09000 {
            compatible = "ti,omap3-uart";
            reg = <0x44e09000 0x2000>;
            interrupts = <72>;
            status = "disabled";
        }
    };
    };
    ```

    xx.dts 内容：
    ```c++
    #include "xx.dtsi"
    /{
    compatible = "ti,am335x-bone","ti,am33xx";
    ocp {
        uart0 : serial@44e09000 {
            pinctrl-name = "default";
            pinctrl-0 = <&uart0_pins>;
            status = "disabled";
        }
    };
    };
    ```
    最终 xx.dts 内容将会是：
    ```c++
    /{
    compatible = "ti,am335x-bone","ti,am33xx";
    ocp {
        uart0 : serial@44e09000 {
            compatible = "ti,omap3-uart";
            reg = <0x44e09000 0x2000>;
            interrupts = <72>;

            pinctrl-name = "default";
            pinctrl-0 = <&uart0_pins>;
            status = "disabled";
        };
    };
    };
    ```



### 规则2：对于节点的修改，先引用后修改；例如原生节点定义如下：

    ```c++
    reserved_memory : reserved-memory {
    #address-cells = <2>;
    #size-cells = <2>;
    ranges;
    hyp_mem : hyp_region@45700000 {
        compatible = "removed-dma-pool";
        no-map;
        reg = <0x0 0x45700000 0x0 0x600000>;
    };
    };
    ```
    需要在reserved-memory节点中添加一个新的节点或者直接修改reserved-memory节点的属性，都需要先引用reserved_memory节点（注意节点的引用名与节点名可以不一致）.如下面案例中，引用reserved-memory节点，并删除了ranges属性，删除了hyp_mem节点，新增了kboot_uboot_logmem节点；
    ```c++
    @reserved_memory {
    /delete-property/ ranges;
    /delete-property/ hyp_mem;
    kboot_uboot_logmem : kboot_uboot_logmem@0x5FC00000 {
        ....
    };
    };
    ```

## A.2.动态设置

ref：linux\Documentation\devicetree\overlay-notes.txt

官方overlay例子： linux\arch\arm\boot\dts\overlays， 或 https://github.com/raspberrypi/linux/tree/rpi-5.4.y/arch/arm/boot/dts/overlays

### Overlay DTS Format

The DTS of an overlay should have the following format:
```c++
{
	/* ignored properties by the overlay */

	fragment@0 {	/* first child node */

		target=<phandle>;	/* phandle target of the overlay */
	or
		target-path="/path";	/* target path of the overlay */

		__overlay__ {
			property-a;	/* add property-a to the target */
			node-a {	/* add to an existing, or create a node-a */
				...
			};
		};
	}
	fragment@1 {	/* second child node */
		...
	};
	/* more fragments follow */
}
```
Using the non-phandle based target method allows one to use a base DT which does
not contain a __symbols__ node, i.e. it was not compiled with the -@ option.
The __symbols__ node is only required for the target=<phandle> method, since it
contains the information required to map from a phandle to a tree location.

例子：
```c++
//----base: foo.dts -----------------------------------------------------------------
	/* FOO platform */
	/ {
		compatible = "corp,foo";

		/* shared resources */
		res: res {
		};

		/* On chip peripherals */
		ocp: ocp {
			/* peripherals that are always instantiated */
			peripheral1 { ... };
		}
	};
//---- foo.dts -----------------------------------------------------------------

//The overlay bar.dts, when loaded (and resolved as described in [1]) should

//----overlay: bar.dts -----------------------------------------------------------------
/plugin/;	/* allow undefined label references and record them */
/ {
	....	/* various properties for loader use; i.e. part id etc. */
	fragment@0 {
		target = <&ocp>;
		__overlay__ {
			/* bar peripheral */
			bar {
				compatible = "corp,bar";
				... /* various properties and child nodes */
			}
		};
	};
};
//---- bar.dts -----------------------------------------------------------------

//----result: foo+bar.dts -------------------------------------------------------------
	/* FOO platform + bar peripheral */
	/ {
		compatible = "corp,foo";

		/* shared resources */
		res: res {
		};

		/* On chip peripherals */
		ocp: ocp {
			/* peripherals that are always instantiated */
			peripheral1 { ... };

			/* bar peripheral */
			bar {
				compatible = "corp,bar";
				... /* various properties and child nodes */
			}
		}
	};
//---- foo+bar.dts -------------------------------------------------------------

As a result of the overlay, a new device node (bar) has been created
so a bar platform device will be registered and if a matching device driver
is loaded the device will be created as expected.
```

```shell
# generate the system base dtb
dtc -I fs -O dtb -o base.dtb /proc/device-tree
# generate overlay dtbo and apply the overlay
dtc -I dts bar.dts -o bar.dtbo
dtoverlay  bar.dtbo
```


### kernel支持原理

对DTS overlay是通过linux configfs进行支持的，使用的核心API是：
overlays 的调用位置
```c++
drivers/of/overlay.c 核心代码。
// Create and apply an overlay
int of_overlay_create(struct device_node *tree);
// Removes an overlay
int of_overlay_destroy(int id);
// Removes all overlays from the system
int of_overlay_destroy_all(void);
```
`of_overlay_create` 被 drivers/of/configfs.c 使用。
在`configfs.c` 最后一行是 `late_initcall(of_cfs_init)`. 作用是标记 of_cfs_init 加入到 内核 .init 段。

"`.init`" 段被调用位置是：`start_kernel -->rest_init() -->kernel_init()-->kernel_init() --> kernel_init_freeable() -->do_basic_setup() -->do_initcalls()`. kernel_init 在完成一系列初始化之后启动第一个用户进程。内核启动过程就结束了。

调用 of_cfs_init 会在 /sys/kernel/config/ 目录下创建 /sys/kernel/config/device-tree/overlay 文件(内存文件系统)。

详细分析过程见[【Linux configfs机制】](https://blog.csdn.net/liujiliei/article/details/105276551)

Device Tree Overlays 核心定义：
在 kernel 启动以后系统加载时候修改或者增加部分dts，最终把整个系统需要的设备驱动全部加载进去。




## A.3.手工使用 device tree overlays

### 直接操作
通过外文网站获取到一些内容：
device tree overlays 的实际用法是，系统启动后 root 用户修改dtb文件，不需要重启！即可生效。
在 /sys/kernel/config/device-tree/overlays/ 目录下创建目录，创建完成后目录内自动会有三个文件 dtbo path status
直接复制 已经编译好的 *.dtbo 文件覆盖 dtbo 文件.
并对 status 赋值 1 即可(好像是不需要的，cp文件覆盖直接生效,如果 status 是只读文件 获取当前 dtbo 是否OK)。
```shell
root@npi:/sys/kernel/config/device-tree/overlays# mkdir test
root@npi:/sys/kernel/config/device-tree/overlays# cd test
root@npi:/sys/kernel/config/device-tree/overlays/test# ls
root@npi:/sys/kernel/config/device-tree/overlays/test# dtbo path status
root@npi:/sys/kernel/config/device-tree/overlays/test# cat status
root@npi:/sys/kernel/config/device-tree/overlays/test# unapplied
root@npi:/sys/kernel/config/device-tree/overlays/test# cp /lib/firmware/test.dtbo dtbo
root@npi:/sys/kernel/config/device-tree/overlays/test# cat status
root@npi:/sys/kernel/config/device-tree/overlays/test# applied
```
加载完成后，dtbo 内的设备会自动由系统安装。可以在 /dev 看到具体内容。

### 工具操作
参考树莓派的使用方式：
https://www.raspberrypi.org/documentation/configuration/device-tree.md

dtdiff dtoverlay dtparam 应该是一组工具。 这里不再描述。

### 工具操作：dtoverlay

loads and removes overlays while the system is running

[dtoverlay source](https://github.com/raspberrypi/userland)

### 工具操作：dtoverlay



# 3.bindings分类介绍

## 3.1.clock binding

“Documentation\devicetree\bindings\clock\clock-bindings.txt”

对一个clock器件，既可以是consumer身份 或是provider身份；也可能是consumer，同时是provider。因为它需要接受clock输入，经过处理后，输出clock。 但对根节点除外，根节点只能是provider身份。



### Clock providers

Required properties:
- `#clock-cells` ：Number of cells in a clock specifier; Typically 0 for nodes with a single clock output and 1 for nodes with multiple clock outputs. 典型使用方式是“0表示该clock仅有一个输出，1表示该clock有多个输出。”，但有些芯片不是采用典型用法，例如stm32就使用“`#clock-cells=2`表示多个输出，其中specifier要使用2个u32表达”

Optional properties， 这几个可选属性被"`of_clk_get_parent_name api`"使用:

- clock-output-names: 时钟输出信号名称列表，特别注意，在“clock consumer”不能直接使用它，仅仅会使用列表索引。
    Recommended to be a list of strings of clock output signal
	names indexed by the first cell in the clock specifier.
	However, the meaning of clock-output-names is domain
	specific to the clock provider, and is only provided to
	encourage using the same meaning for the majority of clock
	providers.  This format may not work for clock providers
	using a complex clock specifier format.  In those cases it
	is recommended to omit this property and create a binding
	specific names property.

	Clock consumer nodes must never directly reference
	the provider's clock-output-names property.

    For example:

        oscillator {
            #clock-cells = <1>;
            clock-output-names = "ckil", "ckih";
        };

    - this node defines a device with two clock outputs, the first named
    "ckil" and the second named "ckih".  Consumer nodes always reference
    clocks by index. The names should reflect the clock output signal
    names for the device.

- clock-indices: If the identifying number for the clocks in the node
		   is not linear from zero, then this allows the mapping of
		   identifiers into the clock-output-names array.

           配合“`clock-output-names`”属性使用

    For example, if we have two clocks <&oscillator 1> and <&oscillator 3>:

        oscillator {
            compatible = "myclocktype";
            #clock-cells = <1>;
            clock-indices = <1>, <3>;
            clock-output-names = "clka", "clkb";
        }

        This ensures we do not have any empty strings in clock-output-names


### Clock consumers

Required properties:

- `clocks` 属性: 它用来描述某“clock consumer”设备的input clock是哪些。 格式为"`clocks = <phandle1 specifier1 [phandle2 specifier2] [phandle3 specifier3] ... >`"，其中specifier是多少个u32构成由“`#clock-cells`”确定。对specifier的解释由各个芯片的clock binding文档确定，例如对stm32是由“\Documentation\ devicetree\bindings\ clock\st,stm32-rcc.txt”确定的.


例子：
```c++
// 确定时钟个数
int nr_pclks = of_count_phandle_with_args(dev->of_node,"clocks","#clock-cells");
// 获取时钟
for(int i=0;i<nr_pclks;i++){
    struct clk *clk = of_clk_get(dev->of_node,i);
}
//使能时钟
clk_prepare_enable(clk);
//禁止时钟clk_disable_unprepare(clk);
```


Optional properties:

- `clock-names`:	List of clock input name strings sorted in the same
		order as the clocks property.  Consumers drivers
		will use clock-names to match clock input names
		with clocks specifiers.
- `clock-ranges`:	Empty property indicating that child nodes can inherit named
		clocks from this node. Useful for bus nodes to provide a
		clock to their children.

"`clock-names`"与"`clock-ranges`"这两个属性被"`struct clk *clk_get(struct device *dev, const char *con_id)`"使用，使用规则就是：
- 查找起点定为`np=dev->of_node`，
- step1：如果np为空，则退出，否则继续step2
- step2：在`np`中查过该节点的“`clock-names`”，找到则退出。找不到继续step3
- step3：赋值"`np=dev->of_node->parent`",如果np不为空，并且具有“`clock-ranges`”属性，回到step2。

DTS例子：
```c++
    /*
    *This represents a device with two clock inputs, named "baud" and "register".
    *The baud clock is connected to output 1 of the &osc device, and the register
    *clock is connected to output 0 of the &ref.
    *device需要使用两个clock，“baud”和“regitser”，由clock-names关键字指定；
    *baud取自“osc”的输出1，register取自“ref”的输出0，由clocks关键字指定。
    */
    device {
        clocks = <&osc 1>, <&ref 0>;
        clock-names = "baud", "register";
    };
```

针对上面的DTS例子，在驱动中要获取clk就可以采用下面的方式：
```c++
/* driver */
int xxx_probe(struct platform_device *pdev)
{
        struct clk *baud_clk = devm_clk_get(&pdev->dev, “baud”);
        ...
        int ret = clk_prepare_enable(baud_clk);
        ...
}
```



==Example==

    /* external oscillator */
    osc: oscillator {
        compatible = "fixed-clock";
        #clock-cells = <1>;
        clock-frequency  = <32678>;
        clock-output-names = "osc";
    };

    /* phase-locked-loop device, generates a higher frequency clock
     * from the external oscillator reference */
    pll: pll@4c000 {
        compatible = "vendor,some-pll-interface"
        #clock-cells = <1>;
        clocks = <&osc 0>;
        clock-names = "ref";
        reg = <0x4c000 0x1000>;
        clock-output-names = "pll", "pll-switched";
    };

    /* UART, using the low frequency oscillator for the baud clock,
     * and the high frequency switched PLL output for register
     * clocking */
    uart@a000 {
        compatible = "fsl,imx-uart";
        reg = <0xa000 0x1000>;
        interrupts = <33>;
        clocks = <&osc 0>, <&pll 1>;
        clock-names = "baud", "register";
    };

This DT fragment defines three devices: an external oscillator to provide a
low-frequency reference clock, a PLL device to generate a higher frequency
clock signal, and a UART.

* The oscillator is fixed-frequency, and provides one clock output, named "osc".
* The PLL is both a clock provider and a clock consumer. It uses the clock
  signal generated by the external oscillator, and provides two output signals
  ("pll" and "pll-switched").
* The UART has its baud clock connected the external oscillator and its
  register clock connected to the PLL clock (the "pll-switched" signal)

### Assigned clock parents and rates

Some platforms may require initial configuration of default parent clocks
and clock frequencies. Such a configuration can be specified in a device tree
node through assigned-clocks, assigned-clock-parents and assigned-clock-rates
properties. The assigned-clock-parents property should contain a list of parent
clocks in the form of a phandle and clock specifier pair and the
assigned-clock-rates property should contain a list of frequencies in Hz. Both
these properties should correspond to the clocks listed in the assigned-clocks
property.

To skip setting parent or rate of a clock its corresponding entry should be
set to 0, or can be omitted if it is not followed by any non-zero entry.

    uart@a000 {
        compatible = "fsl,imx-uart";
        reg = <0xa000 0x1000>;
        ...
        clocks = <&osc 0>, <&pll 1>;
        clock-names = "baud", "register";

        assigned-clocks = <&clkcon 0>, <&pll 2>;
        assigned-clock-parents = <&pll 2>;
        assigned-clock-rates = <0>, <460800>;
    };

In this example the <&pll 2> clock is set as parent of clock <&clkcon 0> and
the <&pll 2> clock is assigned a frequency value of 460800 Hz.

Configuring a clock's parent and rate through the device node that consumes
the clock can be done only for clocks that have a single user. Specifying
conflicting parent or rate configuration in multiple consumer nodes for
a shared clock is forbidden.

Configuration of common clocks, which affect multiple consumer devices can
be similarly specified in the clock provider node.


# 维护

- 在目标设备上查看设备树：`ls /sys/firmware/devicetree/base`

- 查看原始dtb文件：`hexdump -C /sys/firmware/fdt`

- 以目录结构呈现dtb文件：`/sys/firmware/devicetree // 以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件`.
  

- 在目标设备上的打印整个设备树："`$ dtc -I fs /proc/device-tree`" 或 "`$ dtc -I fs /sys/firmware/devicetree/base/`". 注1：通过"`apt-get install device-tree-compiler`"安装dtc。 注2：`/proc/device-tree` 是链接文件, 指向 `/sys/firmware/devicetree/base`

- 在linux-source 查看DTS
    我们知道，linux-source中的dts分为多个文件，有时看起来不是很方便。下面演示了如何将它们转换为一个文件，例子以rpi-3-b板子为例：

    ```shell
    $ git clone https://github.com/raspberrypi/linux.git
    $ export CROSS_COMPILE=arm-linux-gnueabihf-
    $ export ARCH=arm
    $ export KERNEL=kernel7
    $ make bcm2709_defconfig
    $ cd linux/
    $ make bcm2709_defconfig
    $ make dtbs
    $ cp arch/arm/boot/dts/bcm2710-rpi-3-b.dtb ~/
    $ make clean

    # 使用fdtdump
    ~/$ fdtdump -s ~/bcm2710-rpi-3-b.dtb 
    # 使用dtc， dtc建议使用linux/scripts/dtc/dtc
    ~/$ dtc -I dtb -O dts -o output.dts  ~/bcm2710-rpi-3-b.dtb 
    ```
- 安装gpio工具  `sudo apt-get install gpiod`

# DTS API

[Linux设备树学习笔记(四、设备树常用 OF 操作函数)](https://blog.csdn.net/qq_35031421/article/details/105107629)

`#include <linux/of.h>`

## of_parse_phandle
```c++
/**
 * of_parse_phandle - Resolve a phandle property to a device_node pointer
 * @np: Pointer to device node holding phandle property
 * @phandle_name: Name of property holding a phandle value
 * @index: For properties holding a table of phandles, this is the index into
 *         the table
 *
 * Returns the device_node pointer with refcount incremented.  Use
 * of_node_put() on it when done.
 */
struct device_node *of_parse_phandle(const struct device_node *np,
				     const char *phandle_name, int index);

/*
* dts sample:
*		firmware {
*			compatible = "raspberrypi,bcm2835-firmware";
*			mboxes = <0x1b>;
*			phandle = <0x7>;
*		};
* using sample:
* 	struct device_node *fw_node = of_parse_phandle(pdev->dev->of_node, "firmware", 0);
*    int len;
*    struct property *pp=of_find_property(fw_node, "compatible",len);
*    pp->name=compatible  pp->value="raspberrypi,bcm2835-firmware"  len=
*/
```

## of_find_property, of_property_read_u32_index
```c++
/**
 * of_property_read_u32_index - Find and read a u32 from a multi-value property.
 *
 * @np:		device node from which the property value is to be read.
 * @propname:	name of the property to be searched.
 * @index:	index of the u32 in the list of values
 * @out_value:	pointer to return value, modified only if no error.
 *
 * Search for a property in a device node and read nth 32-bit value from
 * it. Returns 0 on success, -EINVAL if the property does not exist,
 * -ENODATA if property does not have a value, and -EOVERFLOW if the
 * property data isn't large enough.
 *
 * The out_value is modified only if a valid u32 value can be decoded.
 */
int of_property_read_u32_index(const struct device_node *np,
				       const char *propname,
				       u32 index, u32 *out_value)
/*
 *dts sample:
 *			uart0_ctsrts_gpio30 {
 *				brcm,pins = <0x1e 0x1f>;
 *				phandle = <0x54>;
 *				brcm,function = <0x7>;
 *			};
 *using sample:
 *	struct property pins = of_find_property(np, "brcm,pins", NULL);
 *    int 	num_pins = pins->length / 4;
 *	for (i = 0; i < num_pins; i++) {
 *        u32 pin;
 *		int err = of_property_read_u32_index(np, "brcm,pins", i, &pin);
 *        ...
 *    }
 */
```


## of_address_to_resource

of_address_to_resource 函数是从设备树里面提取资源值，但是本质上就是将 reg 属性值，然后将其转换为 resource 结构体类型

reg属性格式是`reg = <address1 length1 [address2 length2] [address3 length3] ... >`， 在下面例子中index=0，因此是获取`<address1 length1>`转换到resource里面去。

```c++
/**
 * of_address_to_resource - Translate device tree address and return as resource
 *
 * Note that if your address is a PIO address, the conversion will fail if
 * the physical address can't be internally converted to an IO token with
 * pci_address_to_pio(), that is because it's either called too early or it
 * can't be matched to any host bridge IO space
 */
int of_address_to_resource(struct device_node *dev, int index,
			   struct resource *r)

    /* dts sample
    *	gpio: gpio@7e200000 {
    *		compatible = "brcm,bcm2835-gpio";
    *		gpio-controller;
    *		reg = <0x7e200000 0xb4>;
    *     ...
    */
   /*using sample:
	*struct device_node *np = pdev->dev->of_node;
	*struct bcm2835_pinctrl *pc;
    *
	*struct resource iomem;
	*int err = of_address_to_resource(np, 0, &iomem);
	*-----writeb is 8bit, writew is 16bit, writel is 32bit val, writeq is 64-bit quantities 
    *writel(val, base + reg);    
    */
```

上面演示了如何从DTS中得到某个地址的“struct resource”结构，那我们是否可以手工构造这个结构体呢？ 是可以的，因为linux支持设备信息不但可以通过DTS表达，也可以手工编码在kernel代码中，手工构造resource如下：
```c++
struct resource res = {
        .start = 0x7e200000,
        .end = 0x7e200000+0xb4-1,
        .flags = IORESOURCE_MEM,
    };
// 或
// struct resource res = DEFINE_RES_MEM(0x7e200000,0xb4),
};
```

### devm_ioremap_resource 与 devm_ioremap 区别

devm_ioremap 就是直接映射， devm_ioremap_resource 是先申请，后映射。

在`/proc/iomem`可以查看到已经申请并映射的device resource. 一旦已经申请、映射后的，在使用时直接devm_ioremap 就可以。

# rpi3 分析

https://gitee.com/low-level-of-logic/RaspberryPi/blob/master/docs/0001_%E6%97%A0%E5%B1%8F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE.md

[BCM2835 datasheet](https://www.alldatasheet.com/datasheet-pdf/pdf/502533/BOARDCOM/BCM2835.html)

~/rpi-kernels$ cd linux
~/rpi-kernels/linux$ git checkout d9db059cb982c5478a464c1ff8ce8b17f7768dcc # --> (4.14.21)

rpi-kernels/linux/arch/arm/boot/dts/bcm2710-rpi-3-b.dts

## gpiomem为例 分析用户空间使用

由“linux\drivers\char\broadcom\bcm2835-gpiomem.c”可知道，“/dev/gpiomem”提供了gpio空间的mem-map。同时我们也知道，直接访问内存空间的方法如下：
```go
	file, err := os.OpenFile("/dev/gpiomem", os.O_RDWR|os.O_SYNC, 0660) //|os.O_CLOEXEC
	...
	gpio, err := syscall.Mmap(int(file.Fd()), GPIO_BASE, uint32BlockSize,
	...
```
这里关键的是如何知道“GPIO_BASE”应该填写什么值。 下面我们以raspberry pi 3b为例，说明如何从设备树中来得到它。

下面是rpi3 设备数的一个片段（在目标设备上的打印整个设备树可以通过："`$ dtc -I fs /proc/device-tree`"得到）
```text
/ {
	compatible = "raspberrypi,3-model-b", "brcm,bcm2837";
	soc {
		compatible = "simple-bus";
		ranges = <0x7e000000 0x3f000000 0x1000000 0x40000000 0x40000000 0x1000>;
        ...
		gpiomem@7e200000 {
			compatible = "brcm,bcm2835-gpiomem";
			reg = <0x7e200000 0x1000>;
		};
        ...
		gpio: gpio@7e200000 {
			compatible = "brcm,bcm2835-gpio";
			gpio-controller;
			reg = <0x7e200000 0xb4>;
            ...
        }；
    };
};
```

- 首先根据“linux\drivers\char\broadcom\bcm2835-gpiomem.c”中的match compatible，确认该驱动对应的设备节点是"`/soc/gpiomem@7e200000`"
- gpiomem 节点的unit-address是“`0x7e200000`”. 
- gpiomem 节点的父节点（soc）有ranges属性（"`ranges = <0x7e000000 0x3f000000 0x1000000 0x40000000 0x40000000 0x1000>;`"），根据定义`ranges = <child-bus-address1 parent-bus-address1  length1 [child-bus-address2 parent-bus-address2 length2] ... >`,结合上面gpiomem unit-address信息，在soc层面gpiomem对应的地址应该是"`0x3f000000 + 0x200000`"

- 在soc层面gpiomem对应的地址,也就是我们前面要求解的“GPIO_BASE”

