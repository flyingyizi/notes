[设备树官方文档](http://devicetree.org/Device_Tree_Usage) [最新设备树官方文档](https://www.devicetree.org/specifications/)

[how-to-program-linux-dts-device-tree-files](https://stackoverflow.com/questions/17488320/how-to-program-linux-dts-device-tree-files)

linux 内核中和设备树相关的函数 内核关于设备树的驱动都放在 `/drivers/of` 下，用户可以使用这里面的函数对设备树进行操作。

`ls /proc/device-tree/` 用于查看设备树节点

# 内核与设备树

## 1.加载linux os （有/无设备树）


### 无设备树：
    bootloader在加载kernel image前，会将单板型号（machine type，一个整型数）放在r1寄存器里，内核启动时获取到machine type integer，进而找到用于描述单板的machine_desc，machine_desc定义是“`const struct machine_desc *machine_desc;`”. 它里面包含了所有硬件信息.

    所有单板相关的硬件信息都是hard-coded，例如“`arch/arm/mach-*`”

### 有设备树：
    单板相关的硬件信息保存到dtb里面，bootloader启动内核需要加载kernel image and dtb。machine_desc由内核自己解析dtb构造得到，该构造由`setup_machine_fdt(__atags_pointer)`。这里的__atags_pointer = r2寄存器 = dt_phys = DTB文件的地址。

    后面就是内核对设备树的处理，过程为：`start_kernel -> setup_arch -> unflatten_device_tree -> __unflatten_device_tree`。

    注意，在setup_arch中，通过early_init_dt_reserve_memory_arch/memblock_reserve 把dtb所占区域保留下来。 保留大小信息是通过 在设备树文件中“/memreserve/”指定一块内存，这块内存就是保留的内存，内核不会占用它。即使我们没有指定这块内存，当我们内核启动时，他也会把设备树所占用的区域保留下来，但大小就不是我们控制的了。

## 2.采用设备树移植板，板级最小修改

- 对设备板级源文件，最小改动要求见“`arch/arm/mach-stm32/board-dt.c`”例子.

    ```c++
    static const char *const stm32_compat[] __initconst = {
        "st,stm32f429",
        "st,stm32f469",
        "st,stm32f746",
        "st,stm32h743",
        NULL
    };

    DT_MACHINE_START(STM32DT, "STM32 (Device Tree Support)")
        .dt_compat = stm32_compat,
        .restart = armv7m_restart,
    MACHINE_END
    ```
- 确保"`menuconfig--boot options--flattened device tree`" enable



## 3.采用设备树描述的设备与驱动匹配

对udev下的情况，总线将设备和驱动绑定。在系统每注册一个设备的时候． 会寻找与之匹配的驱动． 相反的，在系统每注册一个驱动的时候． 会寻找与之匹配的设备． 而匹配由总线完成。冷插拔的情况特殊些，linux是通过sysfs里面的uevent节点中新增“add”，来触发内核重新发送冷插拔的netlink事件，udev处理该事件，从而完成上面提到的匹配。

匹配逻辑见“驱动开发.md-->platform 设备驱动”章节描述， 对于其他总线，类似i2c_bus_type, pci_bus_type...原理类似。

## 4.获取采用设备树描述设备的资源

加载内核模块驱动程序后，是时候控制硬件资源了。例如，能够读取和写入寄存器，并接收其中断。

- of.h : 设备树的一般处理函数
- of_address.h :  地址相关函数，比如 of_get_address用来获得reg属性中的addr/size
- of_dma.h   :
- of_gpio.h  :
- of_graph.h :  gpu相关
- of_iommu.h :  很少用到
- of_irq.h   :  中断相关
- of_mdio.h  :  MDIO(ethernet phy)
- of_net.h   :  OF helper for network devices
- of_pci.h   :  
- of_pdt.h   :  很少用到
- of_reserved_mem.h :


以下面设备树中的节点为例，我们演示如何获取该节点设备的资源：
```c++
    xillybus_0: xillybus@50000000 {
      compatible = "xlnx,xillybus-1.00.a";
      reg = < 0x50000000 0x1000 >;
      interrupts = < 0 59 1 >;
      interrupt-parent = <&gic>;

      ...
    } ;
```

### Accessing registers
注意： 访问寄存器应使用iowrite32(), ioread32() and other io-something functions and macros. All device drivers demonstrate this.
```c++
static int __devinit xilly_drv_probe(struct platform_device *op)
{
  const struct of_device_id *match;

  match = of_match_device(xillybus_of_match, &op->dev);
  /* The first operation is a sanity check, verifying that the probe was called on
     a device that is relevant. This is probably not really necessary, but this check appears in many drivers*/
  if (!match)
    return -EINVAL;

  int rc = 0;
  struct resource res;
  void *registers;
  /* populates the “res” structure with the memory segment given by the first “reg” assignment (hence the second argument = 0) 
     in the peripheral’s device tree entry. In our example it’s “reg = < 0x50000000 0x1000 >”, meaning that 
     the allocated chunk starts at physical address 0x50000000 and has the size of 0x1000 bytes. 
     of_address_to_resource() will therefore set res.start = 0x50000000 and res.end = 0x50000fff.*/
  rc = of_address_to_resource(&op->dev.of_node, 0, &res);
  if (rc) {
    /* Fail */
  }
  /* Then request_mem_region() is called in order to register the specific memory segment, like any device driver. 
     The purpose is just to avoid clashes between two drivers accessing the same register space (which should 
     never happen anyhow). The resource_size() inline function returns the size of the segment, as one would expect (0x1000 in this case).*/
  if  (!request_mem_region(res.start, resource_size(&res), "xillybus")) {
    /* Fail */
  }
  /* The of_iomap() function is a combination of of_address_to_resource() and ioremap(), and is essentially 
     equivalent to ioremap(res.start, resource_size(&res)). It makes sure that the physical memory segment has a 
     virtual memory mapping, and returns the virtual address of the beginning of that segment.*/
  /* The correct way to access hardware registers is with iowrite32(), ioread32() and other io-something 
     functions and macros. All device drivers demonstrate this.*/     
  registers = of_iomap(op->dev.of_node, 0);

  if (!registers) {
    /* Fail */
  }
```

### Attaching the interrupt handler
在驱动中关联ISR(中断处理程序)是比较简单的，例如：
```c++
static int __devinit xilly_drv_probe(struct platform_device *op)
{
  ...  
  /* The irq_of_parse_and_map() call merely looks up the interrupt’s specification in the device tree (more about this below) 
     and returns its identifying number, as request_irq() expects to have it (”irq” matches the enumeration in /proc/interrupts as well). 
     The second argument, zero, says that the first interrupt given in the device tree should be taken.*/  
  irq = irq_of_parse_and_map(op->dev.of_node, 0);
  /* then request_irq() registers the interrupt handler. */
  rc = request_irq(irq, xillybus_isr, 0, "xillybus", op->dev);

}
```

### Application-specific data

例如，有个LCD设备，关于它的尺寸信息可以放在设备树中。例如对UART，FREQ可以放在设备树中。

假设设备树中有如下的信息
```c++
    lcd: lcd@50000000 {
      compatible = "xlnx,lcd";
      reg = < 0x50000000 0x1000 >;
      xlnx,slv-awidth = <0x20>;
      ...
    } ;
```
可以通过类似下面的方式来获取到该尺寸信息：
```c++
  void *ptr;
  /* The third argument in the call, NULL, is possibly a pointer to an int variable, to which the length of the data is written.*/
  ptr = of_get_property(op->dev.of_node, "xlnx,slv-awidth", NULL);

  if (!ptr) {
    /* Couldn't find the entry */
  }
  /* To access the actual data, assuming that it’s a number, go*/
  /* The be32_to_cpup reads the data from the address given by “ptr”, converts from Big Endian to the processor’s 
     native Little Endian, so “value” will contain the integer one expects it to contain.*/
  int value = be32_to_cpup(ptr);
```




For example, if the hardware is an LCD display driver, the information about its pixel dimensions and maybe even physical dimensions may appear in the device tree. Serial port interface hardware (i.e. RS-232, UART) is likely to inform the driver about what clock frequency is driving the logic, so that the driver can set up the clock division registers correctly. And so on.

# DTS规范解读

## device tree usage

node names:
    值得花点时间讨论一下命名约定。每个节点都必须有一个格式为<name>[@<unit-address>]的名称。
    
    `<name>`是一个简单的 ascii 字符串，最长可达 31 个字符。通常，节点根据它代表的设备类型来命名。例如3com 以太网适配器的节点将使用名称ethernet，而不是3com509.

    如果节点描述具有地址的设备，则包括单元地址。通常，单元地址是用于访问设备的主要地址，并列在节点的reg属性中。我们将在本文档后面介绍 reg 属性。

    The unit-address must match the first address specified in the reg property of the node. If the node has no reg property, the `@` and `unit-address` must be omitted and the node-name alone differentiates the node from other nodes at the same level in the tree.
    
    兄弟节点必须唯一命名，但只要地址不同（即serial@101f1000 & serial@101f2000），多个节点使用相同的通用名称是正常的。有关节点命名的完整详细信息，请参阅 ePAPR 规范的第 2.2.1 节。

注意： 根节点没有“node name”，适用slash "/"指示。


devices:
    每个设备(device)在设备树中是一个节点(node).

假设有下面一台由"Acme"制造名为 "Coyote's Revenge"的机器:

- One 32bit ARM CPU
- processor local bus attached to memory mapped serial port, spi bus controller, i2c controller, interrupt controller, and external bus bridge
- 256MB of SDRAM based at 0
- 2 Serial ports based at 0x101F1000 and 0x101F2000
- GPIO controller based at 0x101F3000
- SPI controller based at 0x10170000 with following devices
    - MMC slot with SS pin attached to GPIO #1
- External bus bridge with following devices
    - SMC SMC91111 Ethernet device attached to external bus based at 0x10100000
    - i2c controller based at 0x10160000 with following devices
      - Maxim DS1338 real time clock. Responds to slave address 1101000 (0x58)
    - 64MB of NOR flash based at 0x30000000

基于上面的信息,我们将每个节点来填充设备树，当前每个节点还是空的。
```c++
/dts-v1/;

/ {
    compatible = "acme,coyotes-revenge";

    cpus {
        cpu@0 {            compatible = "arm,cortex-a9";        };
        cpu@1 {            compatible = "arm,cortex-a9";        };
    };

    serial@101F0000 {        compatible = "arm,pl011";    };

    serial@101F2000 {        compatible = "arm,pl011";    };

    gpio@101F3000 {        compatible = "arm,pl061";    };

    interrupt-controller@10140000 {        compatible = "arm,pl190";    };

    spi@10115000 {        compatible = "arm,pl022";    };

    external-bus {
        ethernet@0,0 {            compatible = "smc,smc91c111";        };

        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            rtc@58 {                compatible = "maxim,ds1338";            };
        };

        flash@2,0 {            compatible = "samsung,k8f1315ebm", "cfi-flash";        };
    };
};
```

### 寻址原理

可寻址设备（device）使用以下属性将地址信息编码在设备树里面：
- `reg`  ： 格式是`reg = <address1 length1 [address2 length2] [address3 length3] ... >`. 每个“address1 length”代表被设备使用的address range。每个address 是x个u32的list，每个length是y个u32的list.
  总结来说就是reg信息怎么解析，由reg所在子节点的关联父节点的“#address-cells”/“#size-cells”规定来确定。
- `#address-cells=<x>`  : 表示用x 个u32 来描述地址
- `#size-cells=<y>`     ：表示用y 个u32 来描述大小（长度）

注意： 按照惯例，如果节点具有reg属性，则节点名称必须包含单元地址，这是reg属性中的第一个地址值。 这不是强制性的。

例如：
```c++
/ {
        #address-cells = <0x1>;    // 在 root node 下使用 1 个 u32 來代表 address。
        #size-cells = <0x0>;       // 在 root node 下使用 0 个 u32 來代表 size。
        ...
        memory {        // memory device
                ... 
                reg = <0x90000000>; // 0x90000000 是存取 memory 的 address 
                ... 
        }; 
        ... 
  }
```

```c++
/ {
        #address-cells = <0x2>;    // 在 root node 下使用 2 个 u32 來代表 address。
        #size-cells = <0x1>;       // 在 root node 下使用 1 个 u32 來代表 size。
        ...
        ...
        memory@90000000,00000000 {        // memory device
            ... 
            reg = <0x90000000 00000000 0x800000>; // 0x90000000 00000000 是存取 memory 的 address // 0x800000 是 memory 的 size。 
            ... 
        }; 
        ... 
  }
```

对非内存映射设备，

### 地址转换

注意非根直接子节点设备分配的地址仅仅是设备域（device domain）的，和CPU使用的地址（cpu domain）是不同的域，因此涉及设备地址到CPU可以使用地址的转换。

约定：
- 不是根的直接子节点的节点不使用 CPU 的地址域。为了获得内存映射地址，设备树必须指定如何将地址从一个域转换为另一个域。ranges物业用于此目的。

- 根节点总是描述 CPU 对地址空间的看法。根的直接子节点已经在使用 CPU 的地址域，因此不需要任何显式映射。

- 如果父地址空间和子地址空间相同，则节点可以改为添加空ranges属性。空范围属性的存在意味着子地址空间中的地址按 1:1 映射到父地址空间。

我们已经讨论了如何为设备分配地址，但此时这些地址仅适用于设备节点。它还没有描述如何从这些地址映射到 CPU 可以使用的地址。

ranges是地址转换列表。范围表中的每个条目都是一个元组，包含子地址、父地址和子地址空间中区域的大小。每个字段的大小是通过取子#address-cells值、父#address-cells值和子#size-cells值来确定的。对于我们示例中的external-bus，子地址为 2 个单元格，父地址为 1 个单元格，大小也是 1 个单元格。 参见下面例子中的注释说明。

例子：添加了 range 属性的示例设备树。

```c++
/dts-v1/;

/ {
    compatible = "acme,coyotes-revenge";
    #address-cells = <1>;
    #size-cells = <1>;
    /* 根直接子节点，因此直接分配地址 0x101f0000 */
    serial@101f0000 { 
        compatible = "arm,pl011"; reg = <0x101f0000 0x1000>; 
    };     
    ...
    external-bus {
        #address-cells = <2>;
        #size-cells = <1>;
        /*  <the child address, the parent address, and the size of the region in the child address space>.*/
        /* 设备地址"0 0"映射到CPU可访问地址0x10100000..0x1010ffff*/
        /* 设备地址"1 0"映射到CPU可访问地址0x10160000..0x1016ffff*/
        /* 设备地址"2 0"映射到CPU可访问地址0x30000000..0x30ffffff*/
        ranges = <0 0  0x10100000   0x10000     // Chipselect 1, Ethernet
                  1 0  0x10160000   0x10000     // Chipselect 2, i2c controller
                  2 0  0x30000000   0x1000000>; // Chipselect 3, NOR Flash

        ethernet@0,0 {
            compatible = "smc,smc91c111";
            reg = <0 0 0x1000>;
        };
        
        /* You should also notice that there is no ranges property in the i2c@1,0 node. The reason for 
           this is that unlike the external bus, devices on the i2c bus are not memory mapped on the CPU's 
           address domain. Instead, the CPU indirectly accesses the rtc@58 device via the i2c@1,0 device. 
           The lack of a ranges property means that a device cannot be directly accessed by any device other than it's parent.*/
        i2c@1,0 {
            compatible = "acme,a1234-i2c-bus";
            #address-cells = <1>;
            #size-cells = <0>;
            reg = <1 0 0x1000>;
            rtc@58 {
                compatible = "maxim,ds1338";
                reg = <58>;
            };
        };

        flash@2,0 {
            compatible = "samsung,k8f1315ebm", "cfi-flash";
            reg = <2 0 0x4000000>;
        };
    };
};
```

### 中断原理

中断信号与地址不一样，中断信号可以源自和终止于机器中的任何设备。因此中断信号采用与设备树无关，而是节点之间连接（as links between nodes independent of the tree. ）来表示，我们称之为中断连接（ interrupt connections）。

中断连接（ interrupt connections）具有以下4个属性：
- `interrupt-controller` - 是一个空属性， 表示将节点声明为接收中断信号的设备
- `#interrupt-cells`- 这是中断控制器节点的属性。它说明此中断控制器的中断描述符（interrupt specifier）中有多少个单元格（类似于#address-cells和#size-cells）。
- `interrupt-parent`- 设备节点的属性，其中包含到它所连接的中断控制器的phandle。没有中断父属性的节点也可以从其父节点继承该属性。
- `interrupts`- 包含中断描述符列表的设备节点的属性，列表中每个元素代表一个该设备中断输出的中断描述符。 例如`interrupts = <0 48 4>,  <0 49 4>;` ，显然该例子中，对应中断控制器的`#interrupt-cells = <3>`。 这里要注意中断描述符完全是设备自己定义的，不存在适用所有设备的中断描述符，例如对stm32，中断描述符就是IRQn_Type的合法值。


一个中断符是数据的一个或多个细胞（如通过＃中断细胞指定的），该其中断输入所述装置被附接到指定。大多数设备只有一个中断输出，如下例所示，但一个设备上可能有多个中断输出。中断说明符的含义完全取决于中断控制器设备的绑定。每个中断控制器可以决定它需要多少个单元来唯一地定义一个中断输入。

```c++
/dts-v1/;

/ {
    compatible = "acme,coyotes-revenge";
    #address-cells = <1>;
    #size-cells = <1>;
    /* 指示中断控制器为&intc*/
    interrupt-parent = <&intc>;
    ...
    intc: interrupt-controller@10140000 {
        compatible = "arm,pl190";
        reg = <0x10140000 0x1000 >;
        /* 表示该节点设备为接收中断信号的设备，即为中断控制器*/
        interrupt-controller;
        /* 该中断控制器的interrupt specifier 由2个u32构成*/
        #interrupt-cells = <2>;
    };

    spi@10115000 {
        compatible = "arm,pl022";
        reg = <0x10115000 0x1000 >;
        /* 中断描述符是<20 2>,与<4 0>*/
		interrupts = <20 2>, < 4 0 >;
		interrupt-names = "cmd_irq", "event_irq";

    };

    external-bus {
        ...
        ethernet@0,0 {
            compatible = "smc,smc91c111";
            reg = <0 0 0x1000>;
            /* 中断描述符是<5 2>*/
            interrupts = < 5 2 >;
        };
    };
};
```

### 别名

设置别名的语法是"`property = &label;`",  例子如下：

```c++
/ {
	...

	aliases {
		serial0 = &uart0;
	};

	fpga {
		...
		uart0: serial@f0000000 {
            ...
		};
    };
};    
```

### 维护

- 在目标设备上查看设备树：`ls /sys/firmware/devicetree/base`

- 查看原始dtb文件：`hexdump -C /sys/firmware/fdt`

- 以目录结构呈现dtb文件：`/sys/firmware/devicetree // 以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件`.
  

- 在目标设备上的打印整个设备树："`$ dtc -I fs /proc/device-tree`" 或 "`$ dtc -I fs /sys/firmware/devicetree/base/`". 注1：通过"`apt-get install device-tree-compiler`"安装dtc。 注2：`/proc/device-tree` 是链接文件, 指向 `/sys/firmware/devicetree/base`

- 在linux-source 查看DTS
    我们知道，linux-source中的dts分为多个文件，有时看起来不是很方便。下面演示了如何将它们转换为一个文件，例子以rpi-3-b板子为例：

    ```shell
    $ git clone https://github.com/raspberrypi/linux.git
    $ export CROSS_COMPILE=arm-linux-gnueabihf-
    $ export ARCH=arm
    $ export KERNEL=kernel7
    $ make bcm2709_defconfig
    $ cd linux/
    $ make bcm2709_defconfig
    $ make dtbs
    $ cp arch/arm/boot/dts/bcm2710-rpi-3-b.dtb ~/
    $ make clean

    # 使用fdtdump
    ~/$ fdtdump -s ~/bcm2710-rpi-3-b.dtb 
    # 使用dtc， dtc建议使用linux/scripts/dtc/dtc
    ~/$ dtc -I dtb -O dts -o output.dts  ~/bcm2710-rpi-3-b.dtb 
    ```



## 设备树标准属性介绍

该内容来自EPAPR 规范

### compatible

用于选择设备驱动。 建议格式是：`“manufacturer1,model1” [, “manufacturer2,model2”]...` . 选择匹配时从左到右扫描，一旦匹配立即终止匹配。

例子：`compatible = “fsl,mpc8641-uart”, “ns16550"; `

### model

用于指示设备制造商的型号(model)。 见格式是：`“manufacturer,model”`

例子： `model = “fsl,MPC8349EMITX”;`


### phandle

用于在设备数中为一个节点分配一个数字ID。 其他节点可以适用该phandle来引用该节点。  在老版本中也有适用`linux,phandle`的。

编写DTS时，强烈不建议显示适用phandle， 它的目的应仅仅是DTS后台编译所使用。

```c++
pic@10000000 { 
   phandle = <1>; 
   interrupt-controller; 19
}; 

/* A phandle value of 1 is defined. Another device node could reference the pic node with a 22 phandle value of 1: */
xyz {
    ...
    interrupt-parent = <1>;
    ...
};
```

### status 

用于定义设备的运行状态。 从linux-source看，几乎没有使用该属性。

Table 2-4 Values for status property 8

|Value      |  Description           |
|-----------|------------------------|
|“okay”     |  指示设备处于运行态     |
|“disabled” |  指示设备处于disable态  |
|“fail”     |  指示设备处于失败态，如果不修复不会变为运行态 |
|“fail-sss” |  指示设备处于特定失败条件的失败态，sss代表条件。如果不修复不会变为运行态 |

例子：
```c++
&i2c2 {
	...
	status = "okay";

	ltc3676: pmic@3c {
        ...
    };
```

### #address-cells and #size-cells 

`#address-cells and #size-cells` 属性可用于在设备树中具有子节点的任何设备节点，这些属性用于描述设备节点中的子节点如何寻址。 

- `#address-cells`属性定义子节点中`reg`属性中的address由几个u32构成。
- `#size-cells`属性定义子节点中`reg`属性中的size(length)由几个u32构成。

注意`#address-cells and #size-cells` 属性并不会有继承处理，它们必须需要使用它们的节点中显示的定义。

虽然有上面的规范要求，为了安全起见，约定如果缺失，则应假定`#address-cells = <2>; #size-cells=<1>;`

### reg 

`reg`属性用于描述 在其父总线域中的 设备资源的地址,通常理解为`<offset, length>`。

格式是`reg = <address1 length1 [address2 length2] [address3 length3] ... >`. 其中address，length 各由几个u32组成，由该属性所在节点的父节点中的`#address-cells and #size-cells`指定。特别的，如果`#size-cells=<0>;`, 则length应省略。

Example: 
Suppose a device within a system-on-a-chip had two blocks of registers—a 32-byte block at offset 0x3000 in the SOC and a 256-byte block at offset 0xFE00. The reg property would be encoded as follows (assuming #address-cells and #size-cells values of 1): `reg = <0x3000 0x20 0xFE00 0x100>;`

### ranges

用于提供节点地址域父节点地址域的转换。
The ranges property provides a means of defining a mapping or translation between the address space of the bus (the child address space) and the address space of the bus node's parent (the parent address space). 

格式是`reg = <child-bus-address1 parent-bus-address1  length1 [child-bus-address2 parent-bus-address2 length2] ... >`

- `child-bus-address` : is a physical address within the child bus’ address space. The number of cells to represent the address is bus dependent and can be determined from the #address-cells of this node (the node in which the ranges property appears). 
- `parent-bus-address`: is a physical address within the parent bus’ address space. The number of cells to represent the parent address is bus dependent and can be determined from the #address-cells property of the node that defines the parent’s address space. 
- `length` : specifies the size of the range in the child’s address space. The number of cells to represent the size can be determined from the #size-cells of this node (the node in which the ranges property appears). 

If the property is defined with an <empty> value, it specifies that the parent and child address space is identical, and no address translation is required. 
例子：
```c++
	reserved-memory {
		#address-cells = <2>;
		#size-cells = <2>;
		ranges;
		/*
		 * We just move frame buffer area to the very end of
		 * available DDR. And even though in case of ARC770 there's
		 * no strict requirement for a frame-buffer to be in any
		 * particular location it allows us to use the same
		 * base board's DT node for ARC PGU as for ARc HS38.
		 */
		frame_buffer: frame_buffer@9e000000 {
			compatible = "shared-dma-pool";
			reg = <0x0 0x9e000000 0x0 0x2000000>;
			no-map;
		};
	};
```

If the property is not present in a bus node, it is assumed that no mapping exists between children of the node and the parent address space.

例子：
```c++
/{
   soc {
        compatible = "simple-bus";
        #address-cells = <1>;
        #size-cells = <1>;
        /* specifies that for an 1024KB(0x00100000) range of address space, a child node addressed at physical 0x0 maps to a 
           parent address of physical 0xe0000000. */
        /* With this mapping, the serial device node can be addressed by a load or store at address 0xe0004600, 
           an offset of 0x4600 (specified in reg) plus the 0xe0000000 mapping specified in ranges*/
        ranges = <0x0 0xe0000000 0x00100000>;       
        ...
        serial@4600 {
            device_type = "serial";
            compatible = "ns16550";
            reg = <0x4600 0x100>;
            clock-frequency = <0>;
            interrupts = <0xA 0x8>;
            interrupt-parent = < &ipic >;            
        };
   }
};
```

## device bindings

bindings这个概念的理解：

- 当通过设备树来描述一个设备时，bindings应是该设备树所有属性的一个子集。 该子集能为该设备驱动提供所需的足够信息。

- 在设备树规范中，对每个设备，提出了device bindings规范要求。比如对Serial devices，要求有clock-frequency Property。

- 在linux-source中，每一个内核子系统或者framework都有自己的bindings要求，所有内核支持的bindings说明文档都位于Documentation/devicetree/bindings。这里面的内容就是内核所支持设备的支持代码所需要的设备树属性要求。



# rpi3 分析

~/rpi-kernels$ cd linux
~/rpi-kernels/linux$ git checkout d9db059cb982c5478a464c1ff8ce8b17f7768dcc # --> (4.14.21)

rpi-kernels/linux/arch/arm/boot/dts/bcm2710-rpi-3-b.dts




