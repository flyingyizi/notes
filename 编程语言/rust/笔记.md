
Cargo 是 Rust 的构建系统和包管理器。[The Cargo Book](https://doc.rust-lang.org/cargo/index.html), [crate std](https://doc.rust-lang.org/std/index.html)

## 书籍

[The Rust Reference](https://doc.rust-lang.org/reference/introduction.html)

[rust语言圣经](https://course.rs/)；它可以本地运行左习题，配置环境如下：

```shell
$git clone https://github.com/sunface/rust-by-practice.git
$ $ cargo +stable install mdbook
$ cd rust-by-practice/zh-CN && mdbook serve 
\rust-by-practice\zh-CN>mdbook serve
2022-04-04 01:59:46 [INFO] (mdbook::book): Book building has started
2022-04-04 01:59:46 [INFO] (mdbook::book): Running the html backend
2022-04-04 01:59:49 [INFO] (mdbook::cmd::serve): Serving on: http://localhost:3000
2022-04-04 01:59:49 [INFO] (mdbook::cmd::watch): Listening for changes...
2022-04-04 01:59:49 [INFO] (warp::server): Server::run; addr=[::1]:3000
2022-04-04 01:59:49 [INFO] (warp::server): listening on http://[::1]:3000
```

[The Rust Programming Language](https://doc.rust-lang.org/book/),在本地可以通过` rustup docs --book`来阅读，另外还有[中文版](https://github.com/KaiserY/trpl-zh-cn)；[RustPrimer 中文版](https://www.bookstack.cn/read/RustPrimer/README.md)

[Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/)

[Rust宏小册 中文版](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/README.md)

[Rust 高级编程 ](https://learnku.com/docs/nomicon/2018)

# 1.Installing Rust

在不安装rust情况下，可以尝试[Rust Playground](https://play.integer32.com/)

installer：
  - windows: [installer](https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe)
  - linux: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`。如果首次不希望rustup-init安装初始工具链,而是后面自己去选择合适的toolchain版本，可以改为:
    - 在交互中采用none toolchain
    - 或改为直接调用`curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- --default-toolchain none -y`

tips：
  - which rust versions have installed? by running `rustup show`
  - Is special Rust version up to date?  by running `rustup update <toolchain-version>`
  - check install success:  `rustc -V` ， `rustup -v`。


下面是一个最简单rust binary程序，通过`rustc test.rs`进行编译。 注意rust是要依赖c编译环境的，不论msvc，mingwgcc都可以。
```rust
//file name test.rs
//$ rustc test.rs

// 使用io库，io库来自标准库std
use std::io;
// rust程序入口是main
fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");
    //creates a new variable named guess and binds it to 
    //the value of a new instance of a String.
    //The :: syntax in the ::new line indicates that new is an 
    //associated function of the String type.
    let mut guess = String::new();

    //equal to std::io::stdin
    io::stdin()
        //The & indicates that this argument is a reference, 
        //which gives you a way to let multiple parts of your 
        //code access one piece of data without needing to copy 
        //that data into memory multiple times
        //references are immutable by default. Hence, you need to 
        //write &mut guess rather than &guess to make it mutable.
        .read_line(&mut guess)
        //read_line returns a value—in this case, an io::Result
        .expect("Failed to read line");
    //The set of curly brackets, {}, is a placeholder:
    println!("You guessed: {}", guess);
}
```

注：直接使用rustc不是推荐方式，应使用cargo进行package manager



### rustup(rust toolchain installer)典型使用

- show installed rust toolchain: `rustup show`。或直接通过` ls ~/.rustup/toolchains/`查看
- 设置全局默认toolchain： `rustup default <toolchain version>` 
- 将workspace的环境修改为全局默认：在worksapce工作目录中执行`rustup override unset`,这是切换工作目录的rust环境为全局默认环境。
- 设定worsapce的环境：在worksapce工作目录中执行 `rustup override set <toolchain version>`是将该工作目录切换为指定版本。
- :卸载指定toolchain： 例如 `rustup toolchain uninstall nightly-x86_64-unknown-linux-gnu`
- 完全卸载rust: `rustup self uninstall`

## rustup cargo



# 2.编程环境准备

编程环境涉及两部分：

- 编译器与package maanager准备：需要有C环境，在windows下支持msvc与mingw； 其他rust相关部件通过前面介绍的install rust说明进行安装。

- 编辑环境准备： 建议使用vscode，并增加[rust-analyzer](https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer)插件。同时根据 [rust-analyzer manual](https://rust-analyzer.github.io/manual.html)说明，它仅正式支持stable toolchain，如果使用较旧toolchain或设置了覆盖可能无法理解源码，推荐在vscode settings.json中添加`{ "rust-analyzer.server.extraEnv": { "RUSTUP_TOOLCHAIN": "stable" } }`

在vscode中调试程序，由于我们前面已经安装了rust-analyzer扩展，因此这个和普通c程序是一样的，没有需要特别说明的地方，默认生成launch.json中使用lldb 调试程序，这个不需要变动。

如果你项目需要的toolchain与系统default toolchain不一致，需要在该项目目录中通过“`rustup override set <...>`”设置好该项目目录采用的toolchain。该信息可以通过“`rustup override list`”来确认。

## toolchain channel & rust edition

标准的发布通道toolchain名称有以下形式

    ```text
    <channel>[-<date>][-<host>]

    <channel>       = stable|beta|nightly|<version>
    <date>          = YYYY-MM-DD
    <host>          = <target-triple>
    ```
    - channel'是一个命名的发布通道或一个明确的版本号，如'1.42.0'
    - 官方发布工具链名称例子："stable-x86_64-pc-windows-msvc","nightly-2018-10-01-x86_64-pc-windows-msvc"

rust edition每三年发布一个，当前有2015（release of 1.0），2018（Release version	1.31.0），2021（Release version	1.56.0）.具体见[edition guide](https://doc.rust-lang.org/nightly/edition-guide/index.html),在这个链接中包含有将自己的项目在不同edition间迁移的方法。

## 在不同toolchain间切换

许多rustup命令都涉及到工具链，rustup支持多种类型的工具链。最基本的是跟踪官方发布渠道：stable、beta和nightly；也可以自己构建工具链。

- 方式1： `rustup default nightly`切换为将全局环境为nightly版本。 
- 方式2：在对应工作目录中执行 `rustup override set stable`是将该工作目录切换为stable版本。 另外对一个特定的工作目录，可以在里面执行`rustup override unset`,这是切换工作目录的rust环境为全局默认环境。

- 方式3：对特定cargo package，如果它对toolchain有要求，建议在package root目录下放置一个“rust-toolchain.toml”文件，下面是一个rust avr项目的例子：
    ```text
    [toolchain]
    channel = "nightly-2021-01-07"
    components = [ "rust-src" ]
    profile = "minimal"
    ```

# 3.初次rust编程

## C经验的冲突

rust因为引入了所有权概念，所以类似函数参数传递与c有明显不同。在类似实现算法数据结构时，`“core::mem::MaybeUninit::new(val)”`这个经常需要被使用。在rust embedded编程时， heapless crate需要经常被使用到，例如其中提供的String。



## 第一个程序

本次采用cargo进行package manager，而不是命令行rustc

```shell
# 当前文件下下会构建一个名叫 greeting 的 Rust 工程目录
<hi>/$ cargo greeting
<hi>/$ cd ./greeting 
# Cargo.toml是 manifest，记录编译该package所需要的所有信息
<hi>/greeting$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files

# 如果是一个git项目，cargo在build时会自动将所有依赖都下载下来
<hi>/greeting$ cargo build 
# 或执行./target/debug/greeting.exe效果一样
<hi>/greeting$ cargo run 
```

相比rustc编译rs文件，采用package管理工具cargo来编译package的好处是显而易见的。

## 概念

Rust 中，crate 是一个独立的可编译单元。具体说来，就是一个或一批文件（如果是一批文件，那么有一个文件是这个 crate 的入口）。它编译后，会对应着生成一个可执行文件或一个库。

crate类似C中的library。Rust 引用 crate 的关键字是 use

查看有哪些 crate 可供选择，可访问 [Crates - crates.io: Rust Package Registry](https://crates.io/crates)


## cargo典型使用

详细内容参见官方文档[The Cargo Book](https://doc.rust-lang.org/cargo/index.html)

- create binary program: cargo new hello_world --bin
- create lib: cargo new hello_world --lib
- build package: 在package的目录内执行cargo build 
- active manifest update： cargo update

通过cargo创建lib、bin，其实唯一区别就是一个是"src/lib.rs",一个是"src/lib.rs". 这个cargo manager会自动理解而去分别创建lib，bin。


### 配置cargo-build的编译选项参数

除了在`cargo build`命令行传递参数，还有一种方式是在crate的根目录（与Cargo.toml同级）中放置“.cargo/config”文件或文件名是“.cargo/config.toml”，在其中写参数。下面是一个例子：


```text
[target.thumbv7m-none-eabi]
rustflags = ["-C", "link-arg=-Tlink.x"]

[build]
target = "thumbv7m-none-eabi"
```
### 配置cargo-run的自定义运行器

当我们需要使用qemu来模拟运行时，我们需要输入qemu长长的参数。其实是可以通过`cargo run`运行自定义运行器来简化日常输入的。

在crate的根目录（与Cargo.toml同级）中放置“.cargo/config”文件或文件名是“.cargo/config.toml”，在其中写自定义运行器参数。下面是一个例子：

```text
[target.thumbv7m-none-eabi]
# uncomment this to make `cargo run` execute programs on QEMU
# runner = "qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel"
```
在上面配置完成后，当我们执行类似"`cargo run --example hello --release`",将会在qemu上运行它

### 配置cargo-run执行examples

cargo build/run 对crate example基于以下要求：
- 固定目录名为`<cargo_package_root>/examples`，在该目录下是一个个example，写作要求同“crate root”（即src/main.rs）。
- 编译exmple采用: `cargo build --example <NAME>`. 例如对"examples/hello.rs" sample,对应编译指令为`cargo build --example hello`
- 运行example采用：`cargo run --example <NAME>`. 考虑到嵌入式的特殊性，执行它前面应确保已经设置了正确的自定义运行器。


### cargo Build Scripts

一些package需要编译第三方非 Rust 代码，例如 C 库。其他包需要链接到 C 库，这些库可以位于系统上，也可能需要从源代码构建。其他人仍然需要功能设施，例如在构建之前生成代码（想想解析器生成器）。

build scripts与cargo manager通信：build scripts执行中向stdout的输出都会被cargo manager截获，具体来说就是会解析stdout中以"cargo:"开头的line作为编译时的指令。

详细内容见[cargo build scripts](https://doc.rust-lang.org/cargo/reference/build-scripts.html)

Cargo 的目标不是替换针对这些任务进行了良好优化的其他工具，但它确实将它们与自定义构建脚本集成在一起。将一个名为的文件build.rs放在包的根目录中将导致 Cargo 编译该脚本并在构建包之前执行它。

```rust
// Example custom build script.
fn main() {
    // Tell Cargo that if the given file changes, to rerun this build script.
    println!("cargo:rerun-if-changed=src/hello.c");
    // Use the `cc` crate to build a C file and statically link it.
    cc::Build::new()
        .file("src/hello.c")
        .compile("hello");
}
```

## 维护Cargo.toml manifest

详细内容参见官方文档[The Cargo Book](https://doc.rust-lang.org/cargo/index.html)

rust的社区library在crates.io网站。如果你的工程需要引用一个第三方的library，需要在Cargo.toml中“[dependencies]”章节中增加第三方lib描述，下面是一个小例子。
```
[package]
name = "hello_world"
version = "0.1.0"
edition = "2021"

[dependencies]
time = "0.1.12"
regex = "0.1.41"
```
在这个例子中，这个第三方库是存放在rust官方库中。如果是在第三方，则需要采用类似"`regex = { git = "https://github.com/rust-lang/regex.git", rev = "9f9f693" }`"的样式来描写依赖

需要注意的是如果更新了manifest，但没有执行“cargo update”或指定某个依赖更新的““cargo update” -p time”，那更新部分是还不会起作用的，这个机制是通过自动生成的“Cargo.lock”文件来实现的。

同时注意，一旦在dependencies中声明了，那该dependency crate就可以在该package中使用，不需要使用use去import。

### The [features] section in Cargo.toml

来源：[features](https://doc.rust-lang.org/cargo/reference/features.html)

Cargo "features" provide a mechanism to express conditional compilation and optional dependencies. 在这里面定义的命名features, 可以在cargo命令行通过“--features” enable/disable。同时可以在依赖中被开启。

例如查看stm32F4xx-hal crate可以看到，它的Cargo.toml定义了如下features:
```text
[features]
device-selected = []
rt = ["stm32f4/rt"]
stm32f401 = ["stm32f4/stm32f401", "device-selected"]
...
stm32f411 = ["stm32f4/stm32f411", "device-selected"]
...
usb_hs = ["synopsys-usb-otg", "synopsys-usb-otg/hs"]
```
其中类似"`stm32f411 = ["stm32f4/stm32f411", "device-selected"]`"语法是说：Each feature specifies an array of other features or optional dependencies that it enables. 


在它自身的代码中就引用了这些features进行调节编译，例如在“stm32f4xx-hal\src\lib.rs”中有如下的调节编译代码：
```rust
#[cfg(feature = "stm32f410")]
/// Re-export of the [svd2rust](https://crates.io/crates/svd2rust) auto-generated API for the stm32f410 peripherals.
pub use stm32f4::stm32f410 as pac;

#[cfg(feature = "stm32f411")]
/// Re-export of the [svd2rust](https://crates.io/crates/svd2rust) auto-generated API for the stm32f411 peripherals.
pub use stm32f4::stm32f411 as pac;
```

如果我们新建一个crate，其中使用了stm32f4xx-hal，并且我们的板子是stm32f411，那对应在该crate的Cargo.toml中应该含有下面的依赖描述：
```text
[dependencies.stm32f4xx-hal]
features = ["stm32f411", "rt"]
version = "0.7.0"
```
效果与下面的语法等同：
```text
[dependencies]
# Enables the `derive` feature of serde.
stm32f4xx-hal = { version = "0.7.0", features = ["stm32f411", "rt"] }
```

另外，如果我们需要将crate的默认feature去掉，就应该采用下面的方式，下面这个例子演示了在emmbed中使用void的正确引入方式，因为void crate默认是需要std支持的。
```text
[dependencies.void]
version = "1.0.2"
default-features = false
```

### [dev-dependencies] section in Cargo.toml

针对 测试 等需要的第三方依赖可以放在这里面，例如下面是对嵌入式crate中的测试引入了std下的依赖
```text
# see https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html
# Dev-dependencies are not used when compiling a package for building, but are used for compiling tests, examples, and benchmarks.
[dev-dependencies]
tagger = "4.3"
poloto = "11.1.6"
rand = "*"
```

## 持续集成

可以采用“Travis CI”进行持续集成，因此需要自己提供“.travis.yml”配置文件。 还可以采用其他方式进行持续集成，参见[continuous-integration](https://doc.rust-lang.org/cargo/guide/continuous-integration.html)

## cargo-binutils 典型使用

前置条件,需要单独进行安装：
```shell
$ cargo +stable install cargo-binutils
$ rustup +stable component add llvm-tools-preview
```

```shell
#实际调用的是llvm_objdump,因此可以通过`cargo objdump -- --help`查看llvm_objdump的选项
#例如通过该方式可以查看“-d”的作用
$ cargo objdump --bin app -- -d --no-show-raw-insn
```

## 编译诊断约束属性

当属性用于一个完整的 crate 时，它们的语法为 `#![crate_attribute]`，当它们用于模块或项时，语法为 `#[item_attribute]`（注意少了感叹号"!"）.属性可以接受参数，有不同的语法形式：

- #[attribute = "value"]
- #[attribute(key = "value")]
- #[attribute(value)]

### 诊断属性Diagnostic attributes
[Diagnostic attributes](https://doc.rust-lang.org/reference/attributes/diagnostics.html)

用于lint告警控制，可以通过“allow, warn, deny, and forbid”来对lint attributes进行控制，lint attributes列表可以参见"`rustc -W help`" to Print 'lint' options and default settings. 例如
```rust
// 隐藏未使用代码警告的属性。
#![allow(dead_code)]

pub mod m1 {
    // Missing documentation is ignored here
    #[allow(missing_docs)]
    pub fn undocumented_one() -> i32 { 1 }
```
例如
```rust
```

### 限制属性limits attributes
[limits attributes](https://doc.rust-lang.org/reference/attributes/limits.html)

例如“`#![no_std]`”

例如当用到 `crate_type` 属性时，就不再需要给 rustc 命令加上 `--crate-type` 标记
```rust
// 这个 crate 是一个库文件
#![crate_type = "lib"]
// 库的名称为 “rary”
#![crate_name = "rary"]
```

# 4.rust语言语法

let statement, which is used to create a variable.

Rust code uses snake case as the conventional style for function and variable names.


## 语法速查

### 类型

```rust
// equal to `let a:i32; a=1;` two statements. let key create varible
let a = 1;  		// 定义变量，默认不可变。
let an_integer = 5i32; // 后缀声明
let b: bool = true;				// 明确指定变量类型
let mut x = 1_000;		// 定义可变变量
const MAX_POINTS: u32 = 100_000;   // 定义常量，采用可读性写法
let i:i32 = _f as i32;		// 转数据类型
type Int = i32;  					// 用关键字 type 为i32类型创建别名Int
//The double colon (::) is an operator that allows us to namespace 
//this particular from function under the String type
let mut s = String::from("hello");


//下划线_是一个特殊的名字,表示丢弃些东西.
//以下划线开头的名称是常规名称，有一点特殊，就是如果它们未被使用的话编译器不会报警告:
// this calls `get_thing` but throws away its result
let _ = get_thing();

// 对整行进行注释
/* ..  对区块注释  */
/// 生成库文档，一般用于函数或者结构体的说明，置于说明对象的上方
//! 也生成库文档，一般用于说明整个模块的功能，置于模块文件的头部

let tup: (i32, f64, u8) = (500, 6.4, 1);	// 元组（tuple）
// 通过元组的索引来访问具体的值
println!("long tuple first value: {}", tup.0);

let (x, y, z) = tup;	// 模式匹配（pattern matching）来解构元组值
(1,)   // 当元组中只有一个元素时，需要加逗号，即 
｀()｀  // 空元组，
let arr: [i32; 3] = [1, 2, 3];  // 数组
assert_eq!((1..5), Range{ start: 1, end: 5 }); // 范围类型，左闭右开
assert_eq!((1..=5), RangeInclusive::new(1, 5)); // 范围类型，全闭
let arr: [i32; 5] = [1, 2, 3, 4, 5];	// 固定大小数组的切片
let arr = &mut [1, 2, 3];		// 可变数组的切片
let vec = vec![1, 2, 3];		// 使用 vec! 宏定义的动态数组的切片
let str_slice: &[&str] = &["one", "two", "three"];		// 字符串数组的切片
pub struct People {		// Named-Field Struct
    name: &'static str,
    gender: u32,
} // 注意这里没有分号
let alex = People::new("Alex", 1); // 用 :: 来调用new方法，默认不可变
struct Color(i32, i32, i32); // 注意这里要有分号！ Tuple-Like Struct，字段没有名字，只有类型
let color = Color(0, 1, 2);		// 直接构造，不用new方法
struct Integer(u32); // 当元组结构体只有一个字段的时候，称为 New Type 模式
struct Empty;					// 等价于  struct Empty {}，单元结构体是没有任何字段的结构体。

enum Number {		// 无参数枚举
    Zero,
    One,
    Two,
}
enum Color {		// 类C枚举
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}
enum IpAddr {		// 带参数枚举
    V4(u8, u8, u8, u8),
    V6(String),
}
let mut v1 = vec![]; 					// 用宏创建可变向量
let v2 = vec![0; 10];					// 用宏创建不可变向量
let mut v3 = Vec::new();			// 用 new 方法创建向量

let a = [1,2,3]; 
let b = &a;										// 引用操作符 &，不可变，本质上是一种非空指针
let mut c = vec![1,2,3];			// 要获取可变引用，必须先声明可变绑定
let d = &mut c;								// 通过 &mut 得到可变引用

let mut x = 10;
let ptr_x = &mut x as *mut i32;			// 可变原始指针 *&mut T
let y = Box::new(20);
let ptr_y = &*y as *const i32;			// 不可变原始指针 *const T


pub fn math(op: fn(i32, i32) -> i32, a: i32, b: i32) -> i32{			/// 将函数作为参数传递
    op(a, b)				/// 通过函数指针调用函数
}
fn true_maker() -> fn() -> bool { is_true }				/// 函数的返回值是另外一个函数

let box_point = Box::new(Point { x: 0.0, y: 0.0 });		// 智能指针

```

### 格式化输出

```rust
// 通常情况下， `{}` 会被任意变量内容所替换。// 值内容会转化成字符串。
println!("{} days", 31);

// 下面有多种可选形式。
// 可以使用的位置参数。
println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");
// 可以使用赋值语句。
println!("{subject} {verb} {object}",
            object="the lazy dog",
            subject="the quick brown fox",
            verb="jumps over");
// 特殊的格式实现可以在后面加上 `:` 符号。
println!("{} of {:b} people know binary, the other half don't", 1, 2);
// 你可以按指定宽度来右对齐文本。
// 下面语句输出" 1"，5个空格后面连着1。
println!("{number:>width$}", number=1, width=6);
// 你可以对数字左边位数上补0。下面语句输出"000001"。
println!("{number:>0width$}", number=1, width=6);
// println! 会检查使用到的参数数量是否正确。
println!("My name is {0}, {1} {0}", "Bond");//Error,需要补上漏掉的参数
// 创建一个包含` I32 `类型结构体(structure)。命名为 `Structure`。
```

### 流程

```rust
let big_n = if n < 10 && n > -10 { // if 不带括号
    10 * n
} else {
    n / 2
};

for n in 1..101 {} 			// for … in 循环
while n < 101 {}				// while 循环
loop { }								// loop 循环，相当于一个 while true，需要程序自己 break
```

### 关键字type

The type keyword in rust has a different meaning in the 2 places it can be used:

Type alias: Just another name for the same type.
Associated types: this occurs within traits and trait impl blocks. Associated types are used to define a trait that uses some type(s) without needing to know exactly what those types are until the trait is implemented.

[What is the Rust type keyword?](https://stackoverflow.com/questions/29447920/what-is-the-rust-type-keyword)

## 语句与表达式概念

表达式：表达式会进行求值，然后返回一个值。例如 5 + 6，在求值后，返回值 11，因此它就是一条表达式。例如单独的”6“是一个表达式；例如函数（函数体中有返回值）调用是表达式，如果函数体中没有返回值，那该函数调用不是表达式。如果一个“{....}块”最后是个表达式,那也是表达式。

语句：包含声明语句（声明变量，静态变量，常量，结构体，函数等，以及通过 extern 和 use 关键字引入包和模块...）,表达式语句(以分号结束的表达式,此类表达式求值结果将会被舍弃，并总是返回单元类型`()`)。

## 变量

Rust 语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变。引入了"不可变变量"与"可变变量"概念。

rust不允许精度有损失的自动数据类型转换

注意：let这个关键字是典型的“绑定”用途的关键字，绑定是“绑定语句"的简称。 绑定没有返回值的含义，所以“`let a = (let b = 2);`”是不合法的。（补充：let 作为表达式已经是试验功能了，现在先不考虑）

需要区分绑定语句与表达式的区别：“绑定”没有返回值，而表达式有返回值。

典型表达式包括：

```rust
//假设出现的标识符已经被定义：
a = 7
b + 2
c * (a + b)
```

注意上面没有";",如果有那就不是表达式而是语句。


- 声明"可变变量"
```rust
let mut a = 123;
//错误，rust不允许精度有损失的自动数据类型转换
a = 4.56; 
```

- 声明"不可变变量"
```rust
let  a = 123;
```

- 声明常量
```rust
const a: i32 = 123;
```

### 隐藏（Shadowing） 概念

可以定义一个与之前变量同名的新变量，而新变量会 隐藏(Shadowing) 之前的变量。
```rust
//当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字:
let spaces = "   ";  //类型是&str
let spaces = spaces.len();    //类型是usize
```

## 数据类型

Rust 是 静态类型（statically typed）语言，在编译时必须知道所有变量的类型，但书写代码时，如果编译器可以自动推断出类型，那代码也可以不用直接添加类型注释（type annotations）。

Rust 有两类数据类型子集：标量（scalar）和复合（compound）

scalar类型包括：
 - 32 位浮点数（f32）和 64 位浮点数（f64）;
 - 有符号8位整形(i8) 和 无符号8位整形(u8) 
 - i16/u16, i32/u32,i64/u64;i128/u128; 以及特定架构支持的其他长度
 - 布尔类型(bool)
 - 字符型(char),大小是4字节代表unicode标量值

可以使用 as 操作符将字符转为数字类型，例如`assert_eq!('%' as i8, 37)`

复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：

 - 元组（tuple）
 - 数组（array）

### 复合类型：tuple

元组（tuple）是一种异构有限序列：异构 指元组内的元素可以是不同的类型，有限 是指元组有固定长度

访问方式有两种：模式匹配解构与索引。见下面演示：
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
/// 下面演示了模式匹配解构外与使用点号（.）后跟值的索引来直接访问它们
// tup.0 等于 500
// tup.1 等于 6.4
// tup.2 等于 1
let (x, y, z) = tup;
// y 等于 6.4
```

### 符合类型：array

数组（array）与元组不同，数组中的每个元素的类型必须相同。数组的特点是：
- 数组大小固定
- 元素均为相同类型
- 默认不可变

当前rust不支持VLA（variable-length array) 数组

```rust
let a = [1, 2, 3, 4, 5];
// a 是一个长度为 5 的整型数组

let b = ["January", "February", "March"];
// b 是一个长度为 3 的字符串数组

let c: [i32; 5] = [1, 2, 3, 4, 5];
// c 是一个长度为 5 的 i32 数组

let d = [3; 5];// 所有元素可以初始化成相同的值
// 等同于 let d = [3, 3, 3, 3, 3];

let first = a[0];
let second = a[1];
// 数组访问

a[0] = 123; // 错误：数组 a 不可变
let mut a = [1, 2, 3];
a[0] = 4; // 正确

// 数组是在堆中分配
println!("array occupies {} bytes", mem::size_of_val(&a));
```



`let names = vec!["Pascal".to_string(), "Christoph".to_string()];`代码创建了一个名字的vector。Rust的vector类似一个数组(array)或者列表(list)，但是它是动态增长的。我们可以在运行时调用push()把值放进去。

### 符合类型 切片Slice

Slice 切片是对一个数组（包括固定大小数组和动态数组）的引用片段，可以安全访问数组的一部分，而不需要拷贝，slice 的类型标记为 &[T]。一定要注意是引用，声明slice的时候必须按照引用声明，同样因为是一类引用，所以它没有所有权。

```rust
fn main() {
    let s = String::from("broadcast");

    let part1 = &s[0..5];
    let part2 = &s[5..9];

    println!("{}={}+{}", s, part1, part2);
}
```

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

### 复合类型：范围Range

Rust 内置的范围类型，包括 左闭右开 和 全闭 两种区间，分别是 std::ops::Range 和 std::ops::RangeInclusive 的实例
```rust
// (1..5)是结构体std::ops::Range的一个实例
use std::ops::{Range, RangeInclusive};
assert_eq!((1..5), Range{ start: 1, end: 5 });
// (1..=5)是结构体std::ops::RangeInclusive的一个实例
assert_eq!((1..=5), RangeInclusive::new(1, 5));
// 自带的 sum 方法用于求和
assert_eq!(3+4+5, (3..6).sum());
assert_eq!(3+4+5+6, (3..=6).sum());
(3..6)

// 每个范围都是一个迭代器，可用for 循环打印范围内的元素
for i in (1..5) {
    println!("{}", i);
}
for i in (1..=5) {
    println!("{}", i);
}
```

## 自定义数据类型

### 复合类型：struct

struct，是一个自定义数据类型，允许你包装和命名多个相关的值，从而形成一个有意义的组合。

下面演示了如何定义一个自定义数据类型；演示了field init shorthand，以及“.. 语法”语法.同时对结构更新语法中设计所有权的问题也进行了说明：
```rust
//自定义一个数据类型
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        //由于参数名与字段名都完全相同，可以使用 字段初始化简
        //写语法（field init shorthand）
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
    //我们在创建 user2 后不能再使用 user1，因为 user1 的 username 字段中的 
    //String 被移到 user2 中。
    //如果我们给 user2 的 email 和 username 都赋予新的 String 值，从而只使用 user1 的 active 和 sign_in_count 值，那么 user1 在创建 user2 后仍然有效。active 和 sign_in_count 的类型是实现 Copy trait 的类型
    let user2 = User {
        email: String::from("another@example.com"),
        //.. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值
        ..user1
    };
```

它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 self，它代表调用该方法的结构体实例。

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
//使函数定义于 Rectangle 的上下文中(通过impl block来描述)
impl Rectangle {
    //定义method,作用于结构体的实例
    //&self 实际上是 self: &Self 的缩写。在一个 impl 块中，Self 类型
    //是 impl 块的类型的别名
    //这个例子是不可变引用，当然也可以获得self所有权，可变借用...,和其他参数一样
    //总之，不论是哪种，第一个参数必须是self
    fn area(&self) -> u32 {
        self.width * self.height
    }

    //定义associated functions，作用于Rectangle type scope。访问采用“::”
    //
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

### 枚举enumerations

```rust
//自定义数据类型IpAddrKind
enum IpAddrKind {
    V4,
    V6,
}
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

// 创建一个 `enum` （枚举）来划分人的类别。注意命名和类型的信息是如何一起
// 明确规定变量的：
// `Engineer != Scientist` 和 `Height(i32) != Weight(i32)`。每者都不相同且
// 相互独立。
enum Person {
    // 一个 `enum` 可能是个 `unit-like`（类单元结构体），
    Engineer,
    Scientist,
    // 或像一个元组结构体，
    Height(i32),
    Weight(i32),
    // 或像一个普通的结构体。
    Info { name: String, height: i32 }
}
// 此函数将一个 `Person` enum 作为参数，无返回值。
fn inspect(p: Person) {
    // `enum` 的使用必须覆盖所有情形（无可辩驳的），所以使用 `match`
    // 以分支方式覆盖所有类型。
    match p {
        Person::Engineer => println!("Is engineer!"),
        Person::Scientist => println!("Is scientist!"),
        // 从 `enum` 内部解构 `i`
        Person::Height(i) => println!("Has a height of {}.", i),
        Person::Weight(i) => println!("Has a weight of {}.", i),
        // 将 `Info` 解构成 `name` 和 `height`。
        Person::Info { name, height } => {
            println!("{} is {} tall!", name, height);
        },
    }
}

fn main() {
    let person = Person::Height(18);
    let amira = Person::Weight(10);
    // `to_owned()` 从一个字符串 slice 创建一个具有所有权的 `String`。
    let dave = Person::Info { name: "Dave".to_owned(), height: 72 };
    let rebecca = Person::Scientist;
    let rohan = Person::Engineer;
    inspect(person);
    inspect(amira);
    inspect(dave);
    inspect(rebecca);
    inspect(rohan);
}
```

## 函数与方法与闭包

### 函数与方法
方法是从属于对象的函数(Mathods are functions attached to objects)。方法在 impl 代码块下定义。

Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值

`fn <函数名> ( <参数> ) [->返回值]<函数体>`

- 在函数签名中，您必须声明每个参数的类型。这个与普通变量声明不一样，普通变量声明，rust提供了编译器自动推导的便利。
- 函数返回值可以通过两种方式实现： 最后一个是个表达式；最后是个return 语句。

注意： Rust 不支持自动返回值类型判断！如果没有明确声明函数返回值的类型，函数将被认为是"纯过程"，不允许产生返回值，return 后面不能有返回值表达式。

rust函数和golang函数的样子挺像的。 比如下面的：
```rust
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
```

Rust 的 never 类型（ ! ）用于表示永远不可能有返回值的计算类型。Rust 是一个类型安全的语言，所以需要将没有返回值的情况（如线程退出）纳入类型管理。

### 所有权与函数
将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。

示例使用注释展示变量何时进入和离开作用域：
```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，
                                    // 所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。没有特殊之处
```

当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 main 函数中添加使用 s 和 x 的代码来看看哪里能使用他们，以及所有权规则会在哪里阻止我们这么做。

返回值与作用域
返回值也可以转移所有权。示例 4-4 展示了一个返回了某些值的示例，与示例 4-3 一样带有类似的注释。

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 转移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 离开作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 会将
                                             // 返回值移动给
                                             // 调用它的函数

    let some_string = String::from("yours"); // some_string 进入作用域.

    some_string                              // 返回 some_string 
                                             // 并移出给调用的函数
                                             // 
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域
                                                      // 

    a_string  // 返回 a_string 并移出给调用的函数
}
```


### 闭包Closure

闭包（Closure）也叫Lambda表达式或匿名函数。

不像普通函数，闭包可以对参数和返回类型进行推断，大多数时候都不需要写出来，特别注意没有参数的闭包，返回一个 `i32` 类型。。以下定义都是合法的：
```rust
|| 42;
let r = (|x| x + 1)(2);
let f= |x:i32| x + 1;
|x:i32| -> i32 { x + 1 };
```

闭包使用外界的变量遵循"引用（`&T`）> 可变引用(`&mut T`) > 值(T)"优先级顺序:
```rust
let color = "green";
// `println!` only requires `by reference` so it doesn't
// impose anything more restrictive.）
let print = || println!("`color`: {}", color);
// 使用借用来调用闭包。
print();

let mut count = 0;
// A closure to increment `count` could take either
// `&mut count` or `count` but `&mut count` is less restrictive so
// it takes that. Immediately borrows `count`.）
//
// A `mut` is required on `inc` because a `&mut` is stored
// inside. Thus, calling the closure mutates the closure which requires
// a `mut`.）
let mut inc = || {
count += 1;
println!("`count`: {}", count);
};
// 调用闭包。
inc();
```


关于闭包的类型推断，下面例子解释了闭包首次调用后，类型推断信息会锁定在闭包中，在后续调用如果出现不同类型则会出现类型错误。
```rust
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);//Error
```    
### 高阶函数（Higher Order Function, HOF）

HOF执行一个或多个函数来产生一个用处更大的函数。

```rust
// 函数式方式（functional approach）
println!("Find the sum of all the squared odd numbers under 1000");
let upper = 1000;
let sum_of_squared_odd_numbers: u32 =
    (0..).map(|n| n * n) // 所有自然数的平方
    .take_while(|&n| n < upper) // 小于上限
    .filter(|&n| is_odd(n)) // 为奇数
    .fold(0, |sum, i| sum + i); // 最后其后
println!("functional style: {}", sum_of_squared_odd_numbers);
```

## 流程控制

### if、else语句

rust if语句和golang挺像的，也是没有“（）”。

### if let

```rust
let number = Some(7);
let letter: Option<i32> = None;
let emoticon: Option<i32> = None;
// `if let` 结构解读：若 `let` 将 `number` 能解构成 `Some(i)`，
//则执行语句块（`{}`）,此时临时变量i会自动生成并赋值
if let Some(i) = number {println!("Matched {:?}!", i);}
```

### while let


### loop、while、for


`for n in 1..101` 代表`n` 将从 1, 2, ..., 100 这些值依次获取进行每次循环

`for n in 0.. ` 从0,1, ...无穷
### match

## collections

最常见的几个集合数据结构：

- A vector allows you to store a variable number of values next to each other.
- A string is a collection of characters. We’ve mentioned the String type previously, but in this chapter we’ll talk about it in depth.
- A hash map allows you to associate a value with a particular key. It’s a particular implementation of the more general data structure called a map.

let v: Vec<i32> = Vec::new(); // or use vec! macro

### Iterator trait
Iterator trait 用来实现关于集合（collection）类型（比如数组）的迭代器。

## 特征trait

特性（trait）概念接近于 Java 中的接口（Interface），但两者不完全相同。特性与接口相同的地方在于它们都是一种行为规范，可以用于标识哪些数据类型（e.g. struct）有哪些方法。对任何数据类型实现 trait 都是可行的。 

```rust
//定义一个名为Descriptive的trait ，它必须实现describe接口方法
// trait可以为接口方法实现默认实现
trait Descriptive {
    fn describe(&self) -> String {String::from("[Object]")};
}
struct Persona {
    name: String,
    age: u8
}
struct Personb {
    name: String,
    age: u8
}
//为类型实现某个trait的格式是
//impl <特性名> for <所实现的类型名>
impl Descriptive for Persona {
    fn describe(&self) -> String {
        format!("{} {}", self.name, self.age)
    }
}
//Personb采用Descriptive的默认方法
impl Descriptive for Personb {}

//可以通过传递特性参数作为接口参数，
//调用该函数时，任何实现了 Descriptive 特性的对象都可以作为这个函数的参数
fn output(object: impl Descriptive) {
    println!("{}", object.describe());
}
```

在类似c++ interface是一种类型可以声明参数， trait也可以作为类型，但使用方面需要的是类似下面的语法
```rust
trait Servo {
    ...
}
struct TestStruct<'a> {
    fielda: &'a dyn Servo,
...
}
```

### 通用trait
通过 #[derive] 属性，编译器能够提供一些对于 trait 的基本实现。如果需要一个更复杂的业务，这些 trait 仍然可以手动实现。

下面列举了 “derivable”（可派生的）trait：

- 比较 trait:
- Eq, PartialEq, Ord, PartialOrd
- Clone, 采用复制（copy）方式从 &T 创建 T。
- Copy，给出“复制语义”（’copy semantics’）来替代“移动语义”（’move semantics’）。
- Hash，从 &T 计算哈希值（hash）。
- Default, 创建数据类型的一个空实例。
- Zero，创建数字数据类型的一个零值实例（zero instance）。
- Debug，使用 {:?} 格式化程序（formatter）格式化一个值。

```rust
// `Centimeters`，可以比较的元组结构体
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);
// `Inches`，可以打印的元组结构体
#[derive(Debug)]
struct Inches(i32);
```

## 错误处理error handling

[错误处理](https://www.wenjiangs.com/doc/tyq1mglkz)

可以显示调用panic!处理错误

# 5.rust 高级功能

## macro

在编译阶段宏展开被当作AST节点看待.

前面我们经常使用类似"`println!("{}", i);`"语句，其中“`!`”代表 to invoke the macro。因为println是一个宏。

不同于C/C++中的宏，Rust的宏并非简单的文本替换，而是在词法层面甚至语法树层面作替换.rust macro有两大类：
- Declarative Macros with macro_rules! 这种宏允许您编写类似于 Rustmatch表达式的东西
- and three kinds of procedural macros.这类宏类似函数，procedural marcros接受一些代码作为输入，对该代码进行操作，并生成一些代码作为输出

### 描述宏Declarative Macros

macro_rules!作为一个语法扩展，它的形式如下，每条“规则”(rule)都形如"`($pattern) => {$expansion}`"

```text
macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // …
    $ruleN ;
}
```

调用该宏（即需要宏展开）的方式有："`name![], name![],name!{}`"这三种。


使用`macro_rules!`来创建宏，下面是一个例子：
```rust
// This is a simple macro named `say_hello`.

//The #[macro_export] annotation indicates that this macro should 
//be made available whenever the crate in which the macro is defined 
//is brought into scope. Without this annotation, the macro can’t be 
//brought into scope.
#[macro_export]
//注意定义时name后面不带"!"
macro_rules! vec {
    //模式"$x:expr"代表它匹配任何 Rust 表达式并为表达式命名 $x
    //The * specifies that the pattern matches zero or more of 
    //whatever precedes the *.
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            //根据模式匹配的次数，为在模式中匹配零次或多次的每个部分生成temp_vec.push()
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

### 过程宏（Procedure Macro）

过程宏分为三种：

- 派生宏（Derive macro）：用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）。
- 属性宏（Attribute macro）：用在结构体、字段、函数等地方，为其指定属性等功能。如标准库中的#[inline]、#[derive(...)]等都是属性宏。
- 函数式宏（Function-like macro）：用法与普通的规则宏类似，但功能更加强大，可实现任意语法树层面的转换功能。

函数式宏的定义方法如下：
```rust
//表明这是一个函数宏
#[proc_macro]
//宏实现
pub fn seq(input: TokenStream) -> TokenStream {
    let _ = input;

    unimplemented!()
}
```
使用方法如下：
```rust
seq! { n in 0..10 {
    /* ... */
}}
```

## 命令行解析

Rust Crate 使用：clap (Rust命令行参数解析). [官方demo ](https://docs.rs/clap/2.33.3/clap/)

## 序列化与反序列化
使用serde进行序列化与反序列. 例如在嵌入式编程中常用postcard格式。
Postcard, a no_std and embedded-systems friendly - compact binary format.

先定义协议定义
```rust
#![no_std]

use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
pub enum Command {
    Step(Step),
    MoveTo(MoveTo),
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Step {
    pub direction: Direction,
    pub steps: u32,
    pub delay: u32,
}
...
```
对于要发送协议数据的一方，采用类似下面的代码：
```rust
    let command: protocol::Command = ...;
    let mut buf = [0; 1024];
    let to_send = postcard::to_slice_cobs(&command, &mut buf)
     port.write_all(to_send)?;
````
对于接收到消息的一方，采用类似下面的代码对码流buf进行反序列解码得到协议。
```rust
                    let command: Command =
                        postcard::from_bytes_cobs(&mut buf).unwrap();
```

# 6.rust 模块化组织
当你编写大型程序时，组织你的代码显得尤为重要。Rust 有许多功能可以让你管理代码的组织，这有时被称为 “模块系统（the module system）”，并在这些模块之间管理可见性（公开 public/私有 private）.模块系统包括：

- 包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate。
- Crates ：一个模块的树形结构，它形成了库或二进制项目。
- 模块（Modules）和 use： 允许你控制作用域和路径的私有性。
- 路径（path）：一个命名例如结构体、函数或模块等项的方式

## packages and crates

crate：是一个binary或一个library。“crate root”指代某个源文件，rust编译器以他为启动去构建该crate的root module

package：包含一个Cargo.toml文件，以及一个或多个create（其中至多一个library crate，任意多个binary crate）

## Modules 

module: 模块 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。module采用tree组织。

moudle as a item , has item's limit: default is private visibility. sample:
```rust
//定义模块方式是：mod关键字加模块名字. 
mod front_of_house {
    //只有pub外界才可访问
    pub mod hosting {
        //只有pub外界才可访问
        pub fn add_to_waitlist() {}
    }
    mod serving {
        fn take_payment() {}
    }
}

// 演示如何进行module访问
//将该函数作为我们crate的公共API，因此使用pub
pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    front_of_house::hosting::add_to_waitlist();
}
```

### 文件分层
 
模块可以分配到文件/目录的层次结构中。

modules do not get compiled individually, only crates get compiled

```shell
$ tree .
.
|-- my
| |-- inaccessible.rs
| |-- mod.rs
| `-- nested.rs
`-- split.rs
```

在 split.rs 文件：
```rust
// 此声明将会查找名为 `my.rs` 或 `my/mod.rs` 的文件，并将该文件的内容插入到
// 此作用域名为 `my` 的模块里面。
mod my;
fn function() {
println!("called `function()`");
}
fn main() {
my::function();
function();
my::indirect_access();
my::nested::function();
}
```

## Cargo.toml文件说明

[dependencies] section is where you tell Cargo which external crates your project depends on and which versions of those crates you require.

单独提到crate，指源文件集合。 其它还有library crate，binary crate。



Package、Crate、Module、Path：

顶层、Package 包，Cargo的特性，让你构建、测试、共享crate
第二层、Crate 单元包，一个模块数，它可以产生一个library 或可执行文件。
第三层、Module 模块，控制代码的组织、作用域、私有路径。
最后、Path 路径，为struct、function或module等项命名的方式。
Crate 相关
包（package）创建规则：
1、一个包中至多只能包含一个库Crate。
2、包中可以包含任意多个二进制Crate。
3、包中至少包含一个 crate，无论是库的还是二进制的。
4、包中应该包含一个 Cargo.toml 配置文件，用来说明如何去构建这些 crate。
Package 的特点：
1、包含一个 Cargo.toml
2、默认的项目的 `binary crate` 的入口文件是 src/main.rs 
3、默认的库 `library crate` 的入口文件是 src/lib.rs 库名称与Package的名称相同。
4、所以一个package 既可以包含一个 `main.rs` 也可以包含 一个 `lib.rs`
5、文件放置 src/bin 下面，每个文件都是单独的binary crate

## 发布配置profile

Profile 其实是一种发布配置，例如它默认包含四种: dev、 release、 test 和 bench，正常情况下，我们无需去指定，Cargo 会根据我们使用的命令来自动进行选择。

例如 cargo build 自动选择 dev profile，而 cargo test 则是 test profile，而 cargo build --release 自动选择 release profile。

profile 可以通过 Cargo.toml 中的 [profile] 部分进行设置和改变:
```ignore
[profile.dev]
opt-level = 1               # 使用稍高一些的优化级别，最低是0，最高是3
overflow-checks = false     # 关闭整数溢出检查
```

如果是工作空间的话，只有根 package 的 Cargo.toml 中的 [profile 设置才会被使用，其它成员或依赖包中的设置会被自动忽略。

更详细说明，参见[Rust Cargo使用指南 | 第十四篇 | 发布配置 Profile](https://zhuanlan.zhihu.com/p/476524365?utm_medium=social&utm_oi=1089297405844787200)

## 条件编译

使用`#[cfg(...)]`属性标注，或在条件表达式中使用`cfg!(...)`两种形式使用参数的语法都相同。. 详细说明见[“rust条件编译”](https://www.jianshu.com/p/c4d816e1442a)

常见类型条件有：
- debug_assertions - 若没有开启编译优化时就会成立。
- target_arch = "..." - 目标平台的CPU架构，包括但不限于x86, x86_64, mips, - powerpc, arm或aarch64。
- target_endian = "..." - 目标平台的大小端，包括big和little。
- target_env = "..." - 表示使用的运行库，比如musl表示使用的是MUSL的libc实现, msvc表- 示使用微软的MSVC，gnu表示使用GNU的实现。 但在部分平台这个数据是空的。
- target_family = "..." - 表示目标操作系统的类别，比如windows和unix。这个属性可以直- 接作为条件使用，如#[unix]，#[cfg(unix)]。

例子：
```rust
// 这个函数仅当操作系统是 Linux 的时候才会编译
#[cfg(target_os = "linux")]
fn are_you_on_linux() {
    println!("You are running linux!")
}
// 而这个函数仅当操作系统**不是** Linux 时才会编译
#[cfg(not(target_os = "linux"))]
fn are_you_on_linux() {
    println!("You are *not* running linux!")
}
fn main() {
    are_you_on_linux();
        println!("Are you sure?");
    if cfg!(target_os = "linux") {
        println!("Yes. It's definitely linux!");
    } else {
        println!("Yes. It's definitely *not* linux!");
    }
}
```

# 7.与其他语言交换

[Rust FFI](https://doc.rust-lang.org/nomicon/ffi.html`) 

`https://stackoverflow.com/questions/40833078/how-do-i-specify-the-linker-path-in-rust` 和 `https://doc.rust-lang.org/cargo/reference/build-script-examples.html`

# rust 选择不同的编译器

[Rust cargo.toml specify custom path for C linker and compiler](https://stackoverflow.com/questions/62371337/rust-cargo-toml-specify-custom-path-for-c-linker-and-compiler)

[Step by step instruction to install Rust and Cargo for mingw with Msys2](https://stackoverflow.com/questions/47379214/step-by-step-instruction-to-install-rust-and-cargo-for-mingw-with-msys2)


# STM32 (Cortex M3) 和 GD32 (RISC-V) 

[Rust 嵌入式教程](https://docs.rust-embedded.org/)

Rust 嵌入式列表

在 STM32F103 上用 Rust 驱动经典的 SSD1306

$ git clone https://github.com/jamwaffles/ssd1306

$ rustup target add thumbv7m-none-eabi
rustup target add riscv32imac-unknown-none-elf

# 9.自动测试

[官方自动测试说明](file:///C:/Users/atmel/.rustup/toolchains/nightly-2021-01-07-x86_64-pc-windows-msvc/share/doc/rust/html/book/ch11-00-testing.html)

如果自动测试运行target 和日常编译不一样，记得修改target设置，比如在“`.cargo/config.toml`”中的target设置。

## 单元测试

在src目录下的文件中放置类似下面的代码构成单元测试。必须：module为"`mod tests`"，并且使用“`#[cfg(test)]`”标注; 
```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
```
在类似emmbed场景下，通常都是no_std。为了在host下执行单元测试，常常在该crate中声明 “`#![cfg_attr(not(test), no_std)]`”，而不是使用“`#![no_std)]`”: 告诉 rustc 只有在禁用 test 标志时才编译为 no-std Rust，这样我们就可以在测试中使用 std，就像 std Rust 一样。

如果希望在no_std下执行单元测试， [unit-testing](https://os.phil-opp.com/unit-testing/)提供了一种方法，这个也就是"`cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart`"
生成的项目模板中的test_on_host.rs。

## 性能测试

性能测试在rust中还步包含在stable中，需要使用nightly中的 “test feature” 。编辑 `src/lib.rs` 文件，在里面添加如下代码：

```rust
// #![no_std]
// 告诉 rustc 只有在禁用 test 标志时才编译 “no-std” 
#![cfg_attr(not(test), no_std)]
// 告诉 rustc 只有在启用 test 标志时才编译 “test feature” 
#![cfg_attr(test, feature(test))]

#[cfg(test)]
mod tests {
    extern crate test;
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    fn output_trapezoidal_delays() {
        ...
    }
    fn output_scurve_delays() {
        ...    
    }

    #[bench]
    fn bench_scurve_for_steps(b: &mut Bencher) {
        b.iter(|| output_scurve_delays());
    }
    #[bench]
    fn bench_trapezoidal_for_steps(b: &mut Bencher) {
        b.iter(|| output_trapezoidal_delays());
    }
}
```

注意：

- 如果采用`cargo test`运行，带`#[bench]`属性的测试函数会当作普通测试函数，仅仅会运行一次，这样起不到性能测试的作用。需要采用`cargo bench`运行，这时就会仅仅运行带`#[bench]`属性的测试函数，并且是运行很多次，直到每次运行时间趋于稳定才会停止。即才会起到性能测试的作用。
- 性能测试输出结果：输出结果类似`test tests::bench_trapezoidal_for_steps ... bench:      16,371 ns/iter (+/- 1,686)`。 结果中包含iter执行闭包的时间，并带有误差值

- [bencher](https://crates.io/crates/bencher)是用来使Rust Nightly的性能测试功能可以在非Rust Nightly的Rust版本上的crate。该crate与Rust内置的性能测试用法差异颇大，还没有看过

- 由于bench只能在nightly toolchain中使用，为达到该设置目的，有下面三种方法：

    - 设置global toochain为nightly：`rustup default [toolchain]`
    - 设置工作目录为nightly：`rustup override set [toolchain]`
    - 在project root中放置“rust-toolchain.toml”,在其中指定toolchain 为nightly

## 集成测试

相比单元测试，集成测试不再需要“`#[cfg(test)] mod tests {...}`”标注

与src同级的tests目录中存放多个集成测试文件。 这里有个约定在tests目录中出现的的类似"xxxx/mod.s"的，xxxx将不会被对待为集成测试文件，而是作为作为集成测试中的子模块，通常使用方法提取集成测试中的公共方法.

# 问题处理

如果出现错误，执行类似`rustc --explain E0463`命令，将会得到错误码的详细解释。

## error: Unable to update registry `crates-io`

报错：
```
error: Unable to update registry `crates-io`

Caused by:
  failed to fetch `https://github.com/rust-lang/crates.io-index`
```

解决方式：

  将“~/.cargo/registry/index”或windows上的类似“C:\Users\<username>\.cargo\registry\index”删除,重新build

## error: failed to parse manifest at ... edition key

报错
```
d:\home\atmel\temp\rustdemo\greeting>cargo build
error: failed to parse manifest at `d:\home\atmel\temp\rustdemo\greeting\Cargo.toml`

Caused by:
  failed to parse the `edition` key

Caused by:
  this version of Cargo is older than the `2021` edition, and only supports `2015` and `2018` editions.
```

类似当前环境toolchain是“nightly-2021-01-07”，但project中Cargo.toml中edition为`edition = "2021"`就会产生该问题。rust edition是每隔三年发布一个edition。

解决方式：
- 如果项目的edition不可更改，比如rust avr只能支持历史版本的toolchain。调整当前rust 环境的toolchain版本，匹配项目Cargo.toml中edition
- 如果项目没有要求，则调整当前环境的toolchain

## 升级问题

类似embedded-hal等使用了alpha版本，如果是类似`version = "1.0.0-alpha.7"`的版本，一旦embedded-hal有了新的apha版本，那引用了该crate的package会自动使用最新alpha版本的embedded-hal，这可能会导致冲突问题。 有两种方式，一种是手动修改该crate的cargo.toml中对应项为`version = "=1.0.0-alpha.7"`,一种是执行`"cargo update -p embedded-hal:1.0.0-alpha.8 --precise 1.0.0-alpha.7"`



# notes:

类似`_x`的变量名字，当没有使用该变量时，不会出现“compiler warning: unused variable: `x`”

下面代码可以获取类型的名字
```rust
// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  "i8", "u8", "i32", "u32"
fn type_of<T>(_: &T) -> String {
    format!("{}", std::any::type_name::<T>())
}
    let x = 5;
    assert_eq!("i32".to_string(), type_of(&x));
```

类似"`'a'`","`'我'`"的std::mem::size_of_val 返回大小都是4

定义struct时，添加“`#[derive(Debug)]`”，调试会较方便

定义类似引用"`let y = &x;`"，使用“`println!("x 的内存地址是 {:p}", p);`”打印的是address

可变引用定义方式：“`fn change(some_string: &mut String)`”。相应的传递参数应该使用"`change(&mut s);`". 这里还需要注意一点"`s`"它自身应该就是一个mut的变量"`let mut s=...`"

平常使用"`&str`"构建的基于字节的slice，如果要构建基于字符的slice，需要使用“`utf8_slice::slice`”

方法的第一个参数一定是 self 或其变体 &self 、&mut self，self 代表了当前调用的结构体实例。

如果有个“trait Summary”，需要实现trait Summary作为参数，需要类似"`pub fn notify(item: &impl Summary)`"的定义，此参数接受任何实现指定特征(trait)的类型。 这个还有另外一种写法是"`pub fn notify<T: Summary>(item: &T)`". 显然前一种写法更方便。

