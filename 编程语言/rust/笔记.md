
Cargo 是 Rust 的构建系统和包管理器。[The Cargo Book](https://doc.rust-lang.org/cargo/index.html)



# 1.Installing Rust

- windows: [installer](https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe)
- linux: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`


- Is Rust up to date?  by running `rustup update`
- vscode support: [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer)
- check install success:  `rustc -V` 或 `rustup -v`

下面是一个最简单rust程序test.rs，通过`rustc test.rs`进行编译。 注意rust是要依赖c编译环境的，例如不论msvc，mingwgcc都可以。
```rust
fn main() {
    println!("Hello World!");
}
```


## rust nightly stable beta

nightly/stable版本切换: rust toolchain可以在“stable/nightly/beta”三个版本间切换。类似如果有安装了多个nightly版本，则必须写全toolchain的足够区分的名字

- 方式1： `rustup default nightly`切换为将全局环境为nightly版本。 
- 方式2：在对应工作目录中执行 `rustup override set stable`是将该工作目录切换为stable版本。 另外对一个特定的工作目录，可以在里面执行`rustup override unset`,这是切换工作目录的rust环境为全局默认环境。


### 在不同nightly版本间切换

假设系统上已经安装了多个nightly toolchain。如果直接执行类似“rustup default nightly”，则toolchain的切换会有以下2种场景：
- 如果当前已经是nightly，则不会改变任何东西，不论那几个installed nightly的先后关系
- 如果当前不是nightly，则会切换为nightly中newest toolchain

显然如果系统上已经安装了多个nightly toolchain，希望切换为其中特定一个，需要明确的告知nightly toolchain的全面。 在下面例子中演示了这点。

```
~$ rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/atmel/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu
nightly-x86_64-unknown-linux-gnu (default)

active toolchain
----------------

nightly-x86_64-unknown-linux-gnu (default)
rustc 1.61.0-nightly (63b8f01bb 2022-03-24)

~$ rustup install nightly-2021-01-07
~$ rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/atmel/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu
nightly-2021-01-07-x86_64-unknown-linux-gnu
nightly-x86_64-unknown-linux-gnu (default)

active toolchain
----------------

nightly-x86_64-unknown-linux-gnu (default)
rustc 1.61.0-nightly (63b8f01bb 2022-03-24)

~$ rustup default nightly-2021-01-07-x86_64-unknown-linux-gnu
info: using existing install for 'nightly-2021-01-07-x86_64-unknown-linux-gnu'
info: default toolchain set to 'nightly-2021-01-07-x86_64-unknown-linux-gnu'

  nightly-2021-01-07-x86_64-unknown-linux-gnu unchanged - rustc 1.51.0-nightly (c2de47a9a 2021-01-06)

~$ rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/atmel/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu
nightly-2021-01-07-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

nightly-2021-01-07-x86_64-unknown-linux-gnu (default)
rustc 1.51.0-nightly (c2de47a9a 2021-01-06)

~$
```

## rustup典型使用

- show installed rust toolchain: `rustup show`
- 设置全局默认toolchain： `rustup default <toolchain version>` 
- 将workspace的环境修改为全局默认：在worksapce工作目录中执行`rustup override unset`,这是切换工作目录的rust环境为全局默认环境。
- 设定worsapce的环境：在worksapce工作目录中执行 `rustup override set <toolchain version>`是将该工作目录切换为指定版本。




# 2.初次rust编程

## 第一个程序

```shell
# 当前文件下下会构建一个名叫 greeting 的 Rust 工程目录
<hi>/$ cargo greeting
<hi>/$ cd ./greeting 
# Cargo.toml是 manifest，记录编译该package所需要的所有信息
<hi>/greeting$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files

# 如果是一个git项目，cargo在build时会自动将所有依赖都下载下来
<hi>/greeting$ cargo build 
# 或执行./target/debug/greeting.exe效果一样
<hi>/greeting$ cargo run 
```

在vscode中调试程序，由于我们前面已经安装了rust-analyzer扩展，因此这个和普通c程序是一样的，没有需要特别说明的地方，默认生成launch.json中使用lldb 调试程序，这个不需要变动。

相比rustc编译rs文件，采用package管理工具cargo来编译package的好处是显而易见的。

## cargo典型使用

- create binary program: cargo new hello_world --bin
- create lib: cargo new hello_world --lib
- build package: 在package的目录内执行cargo build 
- active manifest update： cargo update

## 维护Cargo.toml manifest

rust的社区library在crates.io网站。如果你的工程需要引用一个第三方的library，需要在Cargo.toml中“[dependencies]”章节中增加第三方lib描述，下面是一个小例子。
```
[package]
name = "hello_world"
version = "0.1.0"
edition = "2021"

[dependencies]
time = "0.1.12"
regex = "0.1.41"
```
在这个例子中，这个第三方库是存放在rust官方库中。如果是在第三方，则需要采用类似"`regex = { git = "https://github.com/rust-lang/regex.git", rev = "9f9f693" }`"的样式来描写依赖

需要注意的是如果更新了manifest，但没有执行“cargo update”或指定某个依赖更新的““cargo update” -p time”，那更新部分是还不会起作用的，这个机制是通过自动生成的“Cargo.lock”文件来实现的。

## 持续集成

可以采用“Travis CI”进行持续集成，因此需要自己提供“.travis.yml”配置文件。 还可以采用其他方式进行持续集成，参见[continuous-integration](https://doc.rust-lang.org/cargo/guide/continuous-integration.html)

## 书籍

[rust语言圣经](https://course.rs/)

# 3.rust语言语法

 - 32 位浮点数（f32）和 64 位浮点数（f64）;
 - 有符号8位整形(i8) 和 无符号8位整形(u8) 
 - i16/u16, i32/u32,i64/u64;i128/u128; 以及特定架构支持的其他长度
 - 布尔类型(bool)
 - 字符型(char),大小是4字节代表unicode标量值

## 语句与表达式概念

表达式：表达式会进行求值，然后返回一个值。例如 5 + 6，在求值后，返回值 11，因此它就是一条表达式。例如单独的”6“是一个表达式；例如函数（函数体中有返回值）调用是表达式，如果函数体中没有返回值，那该函数调用不是表达式。如果一个“{....}块”最后是个表达式,那也是表达式。

语句：它完成了一个具体的操作，但是并没有返回值。它的成分中可以包含表达式。

## 变量

Rust 语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变。引入了"不可变变量"与"可变变量"概念。

rust不允许精度有损失的自动数据类型转换

注意：let这个关键字是典型的“绑定”用途的关键字，绑定是“绑定语句"的简称。 绑定没有返回值的含义，所以“`let a = (let b = 2);`”是不合法的。（补充：let 作为表达式已经是试验功能了，现在先不考虑）

需要区分绑定语句与表达式的区别：“绑定”没有返回值，而表达式有返回值。

典型表达式包括：

```rust
//假设出现的标识符已经被定义：
a = 7
b + 2
c * (a + b)
```

注意上面没有";",如果有那就不是表达式而是语句。


- 声明"可变变量"
```rust
let mut a = 123;
//错误，rust不允许精度有损失的自动数据类型转换
a = 4.56; 
```

- 声明"不可变变量"
```rust
let  a = 123;
```

- 声明常量
```rust
const a: i32 = 123;
```

### 重影（Shadowing） 概念

## tuple

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
// tup.0 等于 500
// tup.1 等于 6.4
// tup.2 等于 1
let (x, y, z) = tup;
// y 等于 6.4
```

## array

数组中的元素必须是同类型的
```rust
let a = [1, 2, 3, 4, 5];
// a 是一个长度为 5 的整型数组

let b = ["January", "February", "March"];
// b 是一个长度为 3 的字符串数组

let c: [i32; 5] = [1, 2, 3, 4, 5];
// c 是一个长度为 5 的 i32 数组

let d = [3; 5];
// 等同于 let d = [3, 3, 3, 3, 3];

let first = a[0];
let second = a[1];
// 数组访问

a[0] = 123; // 错误：数组 a 不可变
let mut a = [1, 2, 3];
a[0] = 4; // 正确
```

## 函数

Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值

`fn <函数名> ( <参数> ) <函数体>`

函数返回值可以通过两种方式实现： 最后一个是个表达式；最后是个return 语句。

注意： Rust 不支持自动返回值类型判断！如果没有明确声明函数返回值的类型，函数将被认为是"纯过程"，不允许产生返回值，return 后面不能有返回值表达式。

rust函数和golang函数的样子挺像的。 比如下面的：
```rust
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
```

## if语句

rust if语句和golang挺像的，也是没有“（）”。

# 4.内存管理

rust引入了“所有权”(Ownership)和“借用”(Borrowing)概念，

## 所有权 Ownership

所有权有以下三条规则：

- Rust 中的每个值都有一个变量，称为其所有者。
- 一次只能有一个所有者。
- 当所有者不在程序运行范围时，该值将被删除。
- 这三条规则是所有权概念的基础。

## 借用 Borrowing


# 5.与其他语言交换

[Rust FFI](https://doc.rust-lang.org/nomicon/ffi.html`) 

`https://stackoverflow.com/questions/40833078/how-do-i-specify-the-linker-path-in-rust` 和 `https://doc.rust-lang.org/cargo/reference/build-script-examples.html`

# rust 选择不同的编译器

[Rust cargo.toml specify custom path for C linker and compiler](https://stackoverflow.com/questions/62371337/rust-cargo-toml-specify-custom-path-for-c-linker-and-compiler)

[Step by step instruction to install Rust and Cargo for mingw with Msys2](https://stackoverflow.com/questions/47379214/step-by-step-instruction-to-install-rust-and-cargo-for-mingw-with-msys2)



# 问题处理

## error: Unable to update registry `crates-io`

报错：
```
error: Unable to update registry `crates-io`

Caused by:
  failed to fetch `https://github.com/rust-lang/crates.io-index`
```

解决方式：

  将“~/.cargo/registry/index”或windows上的类似“C:\Users\<username>\.cargo\registry\index”删除,重新build

  ## error: cannot find macro `llvm_asm` in this scope

  根据"https://github.com/avr-rust/blink.git"尝试rust 编写AVR程序，报错。

  解决方式：

  依据“https://github.com/avr-rust/blink/issues/38”中提示，采用：
  ```shell
  rustup override set nightly-2021-01-07
rustup component add rust-src
cargo build -Z build-std=core --target avr-atmega328p.json --release
```
Looks like it works only with nightly-2021-01-07 release.
