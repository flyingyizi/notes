
Cargo 是 Rust 的构建系统和包管理器。[The Cargo Book](https://doc.rust-lang.org/cargo/index.html)



# 1.Installing Rust

在不安装rust情况下，可以尝试[Rust Playground](https://play.integer32.com/)

installer：
  - windows: [installer](https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe)
  - linux: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`。如果首次不希望rustup-init安装初始工具链,而是后面自己去选择合适的toolchain版本，可以改为:
    - 在交互中采用none toolchain
    - 或改为直接调用`curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- --default-toolchain none -y`

tips：
  - which rust versions have installed? by running `rustup show`
  - Is special Rust version up to date?  by running `rustup update <toolchain-version>`
  - vscode support: [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer)
  - check install success:  `rustc -V` ， `rustup -v`。


下面是一个最简单rust程序，通过`rustc test.rs`进行编译。 注意rust是要依赖c编译环境的，不论msvc，mingwgcc都可以。
```rust
//file name test.rs
//$ rustc test.rs

// 使用io库，io库来自标准库std
use std::io;
// rust程序入口是main
fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");
    //creates a new variable named guess and binds it to 
    //the value of a new instance of a String.
    //The :: syntax in the ::new line indicates that new is an 
    //associated function of the String type.
    let mut guess = String::new();

    //equal to std::io::stdin
    io::stdin()
        //The & indicates that this argument is a reference, 
        //which gives you a way to let multiple parts of your 
        //code access one piece of data without needing to copy 
        //that data into memory multiple times
        //references are immutable by default. Hence, you need to 
        //write &mut guess rather than &guess to make it mutable.
        .read_line(&mut guess)
        //read_line returns a value—in this case, an io::Result
        .expect("Failed to read line");
    //The set of curly brackets, {}, is a placeholder:
    println!("You guessed: {}", guess);
}
```

注：直接使用rustc不是推荐方式，应使用cargo进行package manager



### rustup(rust toolchain installer)典型使用

- show installed rust toolchain: `rustup show`。或直接通过` ls ~/.rustup/toolchains/`查看
- 设置全局默认toolchain： `rustup default <toolchain version>` 
- 将workspace的环境修改为全局默认：在worksapce工作目录中执行`rustup override unset`,这是切换工作目录的rust环境为全局默认环境。
- 设定worsapce的环境：在worksapce工作目录中执行 `rustup override set <toolchain version>`是将该工作目录切换为指定版本。
- :卸载指定toolchain： 例如 `rustup toolchain uninstall nightly-x86_64-unknown-linux-gnu`
- 完全卸载rust: `rustup self uninstall`

## rustup cargo



# 2.编程环境准备

编程环境涉及两部分：

- 编译器与package maanager准备：需要有C环境，在windows下支持msvc与mingw； 其他rust相关部件通过前面介绍的install rust说明进行安装。

- 编辑环境准备： 建议使用vscode，并增加[rust-analyzer](https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer)插件。同时根据 [rust-analyzer manual](https://rust-analyzer.github.io/manual.html)说明，它仅正式支持stable toolchain，如果使用较旧toolchain或设置了覆盖可能无法理解源码，推荐在vscode settings.json中添加`{ "rust-analyzer.server.extraEnv": { "RUSTUP_TOOLCHAIN": "stable" } }`

在vscode中调试程序，由于我们前面已经安装了rust-analyzer扩展，因此这个和普通c程序是一样的，没有需要特别说明的地方，默认生成launch.json中使用lldb 调试程序，这个不需要变动。

如果你项目需要的toolchain与系统default toolchain不一致，需要在该项目目录中通过“`rustup override set <...>`”设置好该项目目录采用的toolchain。该信息可以通过“`rustup override list`”来确认。

## toolchain channel & rust edition

标准的发布通道toolchain名称有以下形式

    ```text
    <channel>[-<date>][-<host>]

    <channel>       = stable|beta|nightly|<version>
    <date>          = YYYY-MM-DD
    <host>          = <target-triple>
    ```
    - channel'是一个命名的发布通道或一个明确的版本号，如'1.42.0'
    - 官方发布工具链名称例子："stable-x86_64-pc-windows-msvc","nightly-2018-10-01-x86_64-pc-windows-msvc"

rust edition每三年发布一个，当前有2015（release of 1.0），2018（Release version	1.31.0），2021（Release version	1.56.0）.具体见[edition guide](https://doc.rust-lang.org/nightly/edition-guide/index.html),在这个链接中包含有将自己的项目在不同edition间迁移的方法。

## 在不同toolchain间切换

许多rustup命令都涉及到工具链，rustup支持多种类型的工具链。最基本的是跟踪官方发布渠道：stable、beta和nightly；也可以自己构建工具链。

- 方式1： `rustup default nightly`切换为将全局环境为nightly版本。 
- 方式2：在对应工作目录中执行 `rustup override set stable`是将该工作目录切换为stable版本。 另外对一个特定的工作目录，可以在里面执行`rustup override unset`,这是切换工作目录的rust环境为全局默认环境。

- 方式3：对特定cargo package，如果它对toolchain有要求，建议在package root目录下放置一个“rust-toolchain.toml”文件，下面是一个rust avr项目的例子：
    ```text
    [toolchain]
    channel = "nightly-2021-01-07"
    components = [ "rust-src" ]
    profile = "minimal"
    ```


# 3.初次rust编程

## 第一个程序

本次采用cargo进行package manager，而不是命令行rustc

```shell
# 当前文件下下会构建一个名叫 greeting 的 Rust 工程目录
<hi>/$ cargo greeting
<hi>/$ cd ./greeting 
# Cargo.toml是 manifest，记录编译该package所需要的所有信息
<hi>/greeting$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files

# 如果是一个git项目，cargo在build时会自动将所有依赖都下载下来
<hi>/greeting$ cargo build 
# 或执行./target/debug/greeting.exe效果一样
<hi>/greeting$ cargo run 
```

相比rustc编译rs文件，采用package管理工具cargo来编译package的好处是显而易见的。

## 概念

Rust 中，crate 是一个独立的可编译单元。具体说来，就是一个或一批文件（如果是一批文件，那么有一个文件是这个 crate 的入口）。它编译后，会对应着生成一个可执行文件或一个库。

crate类似C中的library。Rust 引用 crate 的关键字是 use

查看有哪些 crate 可供选择，可访问 [Crates - crates.io: Rust Package Registry](https://crates.io/crates)


## cargo典型使用

- create binary program: cargo new hello_world --bin
- create lib: cargo new hello_world --lib
- build package: 在package的目录内执行cargo build 
- active manifest update： cargo update

通过cargo创建lib、bin，其实唯一区别就是一个是"src/lib.rs",一个是"src/lib.rs". 这个cargo manager会自动理解而去分别创建lib，bin。


### 配置cargo-build的编译选项参数

除了在`cargo build`命令行传递参数，还有一种方式是在crate的根目录（与Cargo.toml同级）中放置“.cargo/config”文件或文件名是“.cargo/config.toml”，在其中写参数。下面是一个例子：


```text
[target.thumbv7m-none-eabi]
rustflags = ["-C", "link-arg=-Tlink.x"]

[build]
target = "thumbv7m-none-eabi"
```
### 配置cargo-run的自定义运行器

当我们需要使用qemu来模拟运行时，我们需要输入qemu长长的参数。其实是可以通过`cargo run`运行自定义运行器来简化日常输入的。

在crate的根目录（与Cargo.toml同级）中放置“.cargo/config”文件或文件名是“.cargo/config.toml”，在其中写自定义运行器参数。下面是一个例子：

```text
[target.thumbv7m-none-eabi]
# uncomment this to make `cargo run` execute programs on QEMU
# runner = "qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel"
```
在上面配置完成后，当我们执行类似"`cargo run --example hello --release`",将会在qemu上运行它

### 配置cargo-run执行examples

cargo build/run 对crate example基于以下要求：
- 固定目录名为`<cargo_package_root>/examples`，在该目录下是一个个example，写作要求同“crate root”（即src/main.rs）。
- 编译exmple采用: `cargo build --example <NAME>`. 例如对"examples/hello.rs" sample,对应编译指令为`cargo build --example hello`
- 运行example采用：`cargo run --example <NAME>`. 考虑到嵌入式的特殊性，执行它前面应确保已经设置了正确的自定义运行器。


### cargo Build Scripts

一些package需要编译第三方非 Rust 代码，例如 C 库。其他包需要链接到 C 库，这些库可以位于系统上，也可能需要从源代码构建。其他人仍然需要功能设施，例如在构建之前生成代码（想想解析器生成器）。

build scripts与cargo manager通信：build scripts执行中向stdout的输出都会被cargo manager截获，具体来说就是会解析stdout中以"cargo:"开头的line作为编译时的指令。

详细内容见[cargo build scripts](https://doc.rust-lang.org/cargo/reference/build-scripts.html)

Cargo 的目标不是替换针对这些任务进行了良好优化的其他工具，但它确实将它们与自定义构建脚本集成在一起。将一个名为的文件build.rs放在包的根目录中将导致 Cargo 编译该脚本并在构建包之前执行它。

```rust
// Example custom build script.
fn main() {
    // Tell Cargo that if the given file changes, to rerun this build script.
    println!("cargo:rerun-if-changed=src/hello.c");
    // Use the `cc` crate to build a C file and statically link it.
    cc::Build::new()
        .file("src/hello.c")
        .compile("hello");
}
```

## 维护Cargo.toml manifest

rust的社区library在crates.io网站。如果你的工程需要引用一个第三方的library，需要在Cargo.toml中“[dependencies]”章节中增加第三方lib描述，下面是一个小例子。
```
[package]
name = "hello_world"
version = "0.1.0"
edition = "2021"

[dependencies]
time = "0.1.12"
regex = "0.1.41"
```
在这个例子中，这个第三方库是存放在rust官方库中。如果是在第三方，则需要采用类似"`regex = { git = "https://github.com/rust-lang/regex.git", rev = "9f9f693" }`"的样式来描写依赖

需要注意的是如果更新了manifest，但没有执行“cargo update”或指定某个依赖更新的““cargo update” -p time”，那更新部分是还不会起作用的，这个机制是通过自动生成的“Cargo.lock”文件来实现的。

同时注意，一旦在dependencies中声明了，那该dependency crate就可以在该package中使用，不需要使用use去import。

## 持续集成

可以采用“Travis CI”进行持续集成，因此需要自己提供“.travis.yml”配置文件。 还可以采用其他方式进行持续集成，参见[continuous-integration](https://doc.rust-lang.org/cargo/guide/continuous-integration.html)

## cargo-binutils 典型使用

前置条件,需要单独进行安装：
```shell
$ cargo +stable install cargo-binutils
$ rustup +stable component add llvm-tools-preview
```

```shell
#实际调用的是llvm_objdump,因此可以通过`cargo objdump -- --help`查看llvm_objdump的选项
#例如通过该方式可以查看“-d”的作用
$ cargo objdump --bin app -- -d --no-show-raw-insn
```

## 书籍

[rust语言圣经](https://course.rs/)；[The Rust Programming Language](https://doc.rust-lang.org/book/),在本地可以通过` rustup docs --book`来阅读，另外还有[中文版](https://github.com/KaiserY/trpl-zh-cn)；[RustPrimer 中文版](https://www.bookstack.cn/read/RustPrimer/README.md)

# 4.rust语言语法

let statement, which is used to create a variable.

Rust code uses snake case as the conventional style for function and variable names.


## 语法速查

### 类型

```rust
// equal to `let a:i32; a=1;` two statements. let key create varible
let a = 1;  							// 定义变量，默认不可变
let b: bool = true;				// 明确指定变量类型
let mut x = 5;						// 定义可变变量
const MAX_POINTS: u32 = 100_000;   // 定义常量
let i:i32 = _f as i32;		// 转数据类型
type Int = i32;  					// 用关键字 type 为i32类型创建别名Int
//The double colon (::) is an operator that allows us to namespace 
//this particular from function under the String type
let mut s = String::from("hello");


//下划线_是一个特殊的名字,表示丢弃些东西.
//以下划线开头的名称是常规名称，有一点特殊，就是如果它们未被使用的话编译器不会报警告:
// this calls `get_thing` but throws away its result
let _ = get_thing();

// 对整行进行注释
/* ..  对区块注释  */
/// 生成库文档，一般用于函数或者结构体的说明，置于说明对象的上方
//! 也生成库文档，一般用于说明整个模块的功能，置于模块文件的头部

let tup: (i32, f64, u8) = (500, 6.4, 1);			// 元组（tuple）
let (x, y, z) = tup;													// 模式匹配（pattern matching）来解构元组值
(1,)   // 当元组中只有一个元素时，需要加逗号，即 
｀()｀  // 空元组，
let arr: [i32; 3] = [1, 2, 3];  // 数组
assert_eq!((1..5), Range{ start: 1, end: 5 }); // 范围类型，左闭右开
assert_eq!((1..=5), RangeInclusive::new(1, 5)); // 范围类型，全闭
let arr: [i32; 5] = [1, 2, 3, 4, 5];						// 固定大小数组的切片
let arr = &mut [1, 2, 3];												// 可变数组的切片
let vec = vec![1, 2, 3];												// 使用 vec! 宏定义的动态数组的切片
let str_slice: &[&str] = &["one", "two", "three"];		// 字符串数组的切片
pub struct People {															// Named-Field Struct
    name: &'static str,
    gender: u32,
} // 注意这里没有分号
let alex = People::new("Alex", 1); // 用 :: 来调用new方法，默认不可变
struct Color(i32, i32, i32); // 注意这里要有分号！ Tuple-Like Struct，字段没有名字，只有类型
let color = Color(0, 1, 2);		// 直接构造，不用new方法
struct Integer(u32); // 当元组结构体只有一个字段的时候，称为 New Type 模式
struct Empty;					// 等价于  struct Empty {}，单元结构体是没有任何字段的结构体。

enum Number {		// 无参数枚举
    Zero,
    One,
    Two,
}
enum Color {		// 类C枚举
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}
enum IpAddr {		// 带参数枚举
    V4(u8, u8, u8, u8),
    V6(String),
}
let mut v1 = vec![]; 					// 用宏创建可变向量
let v2 = vec![0; 10];					// 用宏创建不可变向量
let mut v3 = Vec::new();			// 用 new 方法创建向量

let a = [1,2,3]; 
let b = &a;										// 引用操作符 &，不可变，本质上是一种非空指针
let mut c = vec![1,2,3];			// 要获取可变引用，必须先声明可变绑定
let d = &mut c;								// 通过 &mut 得到可变引用

let mut x = 10;
let ptr_x = &mut x as *mut i32;			// 可变原始指针 *&mut T
let y = Box::new(20);
let ptr_y = &*y as *const i32;			// 不可变原始指针 *const T


pub fn math(op: fn(i32, i32) -> i32, a: i32, b: i32) -> i32{			/// 将函数作为参数传递
    op(a, b)				/// 通过函数指针调用函数
}
fn true_maker() -> fn() -> bool { is_true }				/// 函数的返回值是另外一个函数

let box_point = Box::new(Point { x: 0.0, y: 0.0 });		// 智能指针

```

### 流程

```rust
let big_n = if n < 10 && n > -10 { // if 不带括号
    10 * n
} else {
    n / 2
};

for n in 1..101 {} 			// for … in 循环
while n < 101 {}				// while 循环
loop { }								// loop 循环，相当于一个 while true，需要程序自己 break
```

## 语句与表达式概念

表达式：表达式会进行求值，然后返回一个值。例如 5 + 6，在求值后，返回值 11，因此它就是一条表达式。例如单独的”6“是一个表达式；例如函数（函数体中有返回值）调用是表达式，如果函数体中没有返回值，那该函数调用不是表达式。如果一个“{....}块”最后是个表达式,那也是表达式。

语句：包含声明语句（声明变量，静态变量，常量，结构体，函数等，以及通过 extern 和 use 关键字引入包和模块...）,表达式语句(以分号结束的表达式,此类表达式求值结果将会被舍弃，并总是返回单元类型`()`)。

## 变量

Rust 语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变。引入了"不可变变量"与"可变变量"概念。

rust不允许精度有损失的自动数据类型转换

注意：let这个关键字是典型的“绑定”用途的关键字，绑定是“绑定语句"的简称。 绑定没有返回值的含义，所以“`let a = (let b = 2);`”是不合法的。（补充：let 作为表达式已经是试验功能了，现在先不考虑）

需要区分绑定语句与表达式的区别：“绑定”没有返回值，而表达式有返回值。

典型表达式包括：

```rust
//假设出现的标识符已经被定义：
a = 7
b + 2
c * (a + b)
```

注意上面没有";",如果有那就不是表达式而是语句。


- 声明"可变变量"
```rust
let mut a = 123;
//错误，rust不允许精度有损失的自动数据类型转换
a = 4.56; 
```

- 声明"不可变变量"
```rust
let  a = 123;
```

- 声明常量
```rust
const a: i32 = 123;
```

### 隐藏（Shadowing） 概念

可以定义一个与之前变量同名的新变量，而新变量会 隐藏(Shadowing) 之前的变量。
```rust
//当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字:
let spaces = "   ";  //类型是&str
let spaces = spaces.len();    //类型是usize
```

## 数据类型

Rust 是 静态类型（statically typed）语言，在编译时必须知道所有变量的类型，但书写代码时，如果编译器可以自动推断出类型，那代码也可以不用直接添加类型注释（type annotations）。

Rust 有两类数据类型子集：标量（scalar）和复合（compound）

scalar类型包括：
 - 32 位浮点数（f32）和 64 位浮点数（f64）;
 - 有符号8位整形(i8) 和 无符号8位整形(u8) 
 - i16/u16, i32/u32,i64/u64;i128/u128; 以及特定架构支持的其他长度
 - 布尔类型(bool)
 - 字符型(char),大小是4字节代表unicode标量值

可以使用 as 操作符将字符转为数字类型，例如`assert_eq!('%' as i8, 37)`

复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：

 - 元组（tuple）
 - 数组（array）

### 复合类型：tuple

元组（tuple）是一种异构有限序列：异构 指元组内的元素可以是不同的类型，有限 是指元组有固定长度

访问方式有两种：模式匹配解构与索引。见下面演示：
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
/// 下面演示了模式匹配解构外与使用点号（.）后跟值的索引来直接访问它们
// tup.0 等于 500
// tup.1 等于 6.4
// tup.2 等于 1
let (x, y, z) = tup;
// y 等于 6.4
```

### 符合类型：array

数组（array）与元组不同，数组中的每个元素的类型必须相同。数组的特点是：
- 数组大小固定
- 元素均为相同类型
- 默认不可变

当前rust不支持VLA（variable-length array) 数组

```rust
let a = [1, 2, 3, 4, 5];
// a 是一个长度为 5 的整型数组

let b = ["January", "February", "March"];
// b 是一个长度为 3 的字符串数组

let c: [i32; 5] = [1, 2, 3, 4, 5];
// c 是一个长度为 5 的 i32 数组

let d = [3; 5];
// 等同于 let d = [3, 3, 3, 3, 3];

let first = a[0];
let second = a[1];
// 数组访问

a[0] = 123; // 错误：数组 a 不可变
let mut a = [1, 2, 3];
a[0] = 4; // 正确
```

`let names = vec!["Pascal".to_string(), "Christoph".to_string()];`代码创建了一个名字的vector。Rust的vector类似一个数组(array)或者列表(list)，但是它是动态增长的。我们可以在运行时调用push()把值放进去。

### 符合类型 切片Slice

Slice 切片是对一个数组（包括固定大小数组和动态数组）的引用片段，可以安全访问数组的一部分，而不需要拷贝。一定要注意是引用，声明slice的时候必须按照引用声明，同样因为是一类引用，所以它没有所有权。

```rust
fn main() {
    let s = String::from("broadcast");

    let part1 = &s[0..5];
    let part2 = &s[5..9];

    println!("{}={}+{}", s, part1, part2);
}
```

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

### 复合类型：范围Range

Rust 内置的范围类型，包括 左闭右开 和 全币 两种区间，分别是 std::ops::Range 和 std::ops::RangeInclusive 的实例
```rust
// (1..5)是结构体std::ops::Range的一个实例
use std::ops::{Range, RangeInclusive};
assert_eq!((1..5), Range{ start: 1, end: 5 });
// (1..=5)是结构体std::ops::RangeInclusive的一个实例
assert_eq!((1..=5), RangeInclusive::new(1, 5));
// 自带的 sum 方法用于求和
assert_eq!(3+4+5, (3..6).sum());
assert_eq!(3+4+5+6, (3..=6).sum());
(3..6)

// 每个范围都是一个迭代器，可用for 循环打印范围内的元素
for i in (1..5) {
    println!("{}", i);
}
for i in (1..=5) {
    println!("{}", i);
}
```
### 复合类型：结构体


## 函数

Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值

`fn <函数名> ( <参数> ) [->返回值]<函数体>`

- 在函数签名中，您必须声明每个参数的类型。这个与普通变量声明不一样，普通变量声明，rust提供了编译器自动推导的便利。
- 函数返回值可以通过两种方式实现： 最后一个是个表达式；最后是个return 语句。

注意： Rust 不支持自动返回值类型判断！如果没有明确声明函数返回值的类型，函数将被认为是"纯过程"，不允许产生返回值，return 后面不能有返回值表达式。

rust函数和golang函数的样子挺像的。 比如下面的：
```rust
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
```

Rust 的 never 类型（ ! ）用于表示永远不可能有返回值的计算类型。Rust 是一个类型安全的语言，所以需要将没有返回值的情况（如线程退出）纳入类型管理。

### 所有权与函数
将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。

示例使用注释展示变量何时进入和离开作用域：
```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，
                                    // 所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。没有特殊之处
```

当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 main 函数中添加使用 s 和 x 的代码来看看哪里能使用他们，以及所有权规则会在哪里阻止我们这么做。

返回值与作用域
返回值也可以转移所有权。示例 4-4 展示了一个返回了某些值的示例，与示例 4-3 一样带有类似的注释。

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 转移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 离开作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 会将
                                             // 返回值移动给
                                             // 调用它的函数

    let some_string = String::from("yours"); // some_string 进入作用域.

    some_string                              // 返回 some_string 
                                             // 并移出给调用的函数
                                             // 
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域
                                                      // 

    a_string  // 返回 a_string 并移出给调用的函数
}
```

## if语句

rust if语句和golang挺像的，也是没有“（）”。

## struct

struct，或者 structure，是一个自定义数据类型，允许你包装和命名多个相关的值，从而形成一个有意义的组合。

下面演示了如何定义一个自定义数据类型；演示了field init shorthand，以及“.. 语法”语法.同时对结构更新语法中设计所有权的问题也进行了说明：
```rust
//自定义一个数据类型
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        //由于参数名与字段名都完全相同，可以使用 字段初始化简
        //写语法（field init shorthand）
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
    //我们在创建 user2 后不能再使用 user1，因为 user1 的 username 字段中的 
    //String 被移到 user2 中。
    //如果我们给 user2 的 email 和 username 都赋予新的 String 值，从而只使用 user1 的 active 和 sign_in_count 值，那么 user1 在创建 user2 后仍然有效。active 和 sign_in_count 的类型是实现 Copy trait 的类型
    let user2 = User {
        email: String::from("another@example.com"),
        //.. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值
        ..user1
    };
```

### struct method

它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 self，它代表调用该方法的结构体实例。

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
//使函数定义于 Rectangle 的上下文中(通过impl block来描述)
impl Rectangle {
    //定义method,作用于结构体的实例
    //&self 实际上是 self: &Self 的缩写。在一个 impl 块中，Self 类型
    //是 impl 块的类型的别名
    //这个例子是不可变引用，当然也可以获得self所有权，可变借用...,和其他参数一样
    //总之，不论是哪种，第一个参数必须是self
    fn area(&self) -> u32 {
        self.width * self.height
    }

    //定义associated functions，作用于Rectangle type scope。访问采用“::”
    //
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

## 枚举enumerations

```rust
//自定义数据类型IpAddrKind
enum IpAddrKind {
    V4,
    V6,
}
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
```

## collections

最常见的几个集合数据结构：

- A vector allows you to store a variable number of values next to each other.
- A string is a collection of characters. We’ve mentioned the String type previously, but in this chapter we’ll talk about it in depth.
- A hash map allows you to associate a value with a particular key. It’s a particular implementation of the more general data structure called a map.

let v: Vec<i32> = Vec::new(); // or use vec! macro

## 闭包Closure

闭包（Closure）也叫Lambda表达式或匿名函数。

不像普通函数，闭包可以对参数和返回类型进行推断，大多数时候都不需要写出来。以下定义都是合法的：
```rust
|| 42;
let r = (|x| x + 1)(2);
let f= |x:i32| x + 1;
|x:i32| -> i32 { x + 1 };
```

关于闭包的类型推断，下面例子解释了闭包首次调用后，类型推断信息会锁定在闭包中，在后续调用如果出现不同类型则会出现类型错误。
```rust
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);//Error
```    

## 特征trait

特性（trait）概念接近于 Java 中的接口（Interface），但两者不完全相同。特性与接口相同的地方在于它们都是一种行为规范，可以用于标识哪些类有哪些方法。

```rust
//定义一个名为Descriptive的trait ，它必须实现describe接口方法
// trait可以为接口方法实现默认实现
trait Descriptive {
    fn describe(&self) -> String {String::from("[Object]")};
}
struct Persona {
    name: String,
    age: u8
}
struct Personb {
    name: String,
    age: u8
}
//为类型实现某个trait的格式是
//impl <特性名> for <所实现的类型名>
impl Descriptive for Persona {
    fn describe(&self) -> String {
        format!("{} {}", self.name, self.age)
    }
}
//Personb采用Descriptive的默认方法
impl Descriptive for Personb {}

//可以通过传递特性参数作为接口参数，
//调用该函数时，任何实现了 Descriptive 特性的对象都可以作为这个函数的参数
fn output(object: impl Descriptive) {
    println!("{}", object.describe());
}
```

# 5.rust 高级功能

## macro

前面我们经常使用类似"`println!("{}", i);`"语句，其中“`!`”代表 to invoke the macro。
因为println是一个宏。

不同于C/C++中的宏，Rust的宏并非简单的文本替换，而是在词法层面甚至语法树层面作替换.rust macro有两大类：
- Declarative Macros with macro_rules! 这种宏允许您编写类似于 Rustmatch表达式的东西
- and three kinds of procedural macros.这类宏类似函数，procedural marcros接受一些代码作为输入，对该代码进行操作，并生成一些代码作为输出

### 描述宏Declarative Macros
使用`macro_rules!`来创建宏，下面是一个例子：
```rust
// This is a simple macro named `say_hello`.

//The #[macro_export] annotation indicates that this macro should 
//be made available whenever the crate in which the macro is defined 
//is brought into scope. Without this annotation, the macro can’t be 
//brought into scope.
#[macro_export]
//注意定义时name后面不带"!"
macro_rules! vec {
    //模式"$x:expr"代表它匹配任何 Rust 表达式并为表达式命名 $x
    //The * specifies that the pattern matches zero or more of 
    //whatever precedes the *.
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            //根据模式匹配的次数，为在模式中匹配零次或多次的每个部分生成temp_vec.push()
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

### 过程宏（Procedure Macro）

过程宏分为三种：

- 派生宏（Derive macro）：用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）。
- 属性宏（Attribute macro）：用在结构体、字段、函数等地方，为其指定属性等功能。如标准库中的#[inline]、#[derive(...)]等都是属性宏。
- 函数式宏（Function-like macro）：用法与普通的规则宏类似，但功能更加强大，可实现任意语法树层面的转换功能。

函数式宏的定义方法如下：
```rust
//表明这是一个函数宏
#[proc_macro]
//宏实现
pub fn seq(input: TokenStream) -> TokenStream {
    let _ = input;

    unimplemented!()
}
```
使用方法如下：
```rust
seq! { n in 0..10 {
    /* ... */
}}
```
# 6.rust 模块化组织
当你编写大型程序时，组织你的代码显得尤为重要。Rust 有许多功能可以让你管理代码的组织，这有时被称为 “模块系统（the module system）”，包括：

- 包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate。
- Crates ：一个模块的树形结构，它形成了库或二进制项目。
- 模块（Modules）和 use： 允许你控制作用域和路径的私有性。
- 路径（path）：一个命名例如结构体、函数或模块等项的方式

## packages and crates

crate：是一个binary或一个library。“crate root”指代某个源文件，rust编译器以他为启动去构建该crate的root module

package：包含一个Cargo.toml文件，以及一个或多个create（其中至多一个library crate，任意多个binary crate）

## Modules 

module: 模块 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。module采用tree组织。

```rust
//定义模块方式是：mod关键字加模块名字
mod front_of_house {
    //只有pub外界才可访问
    pub mod hosting {
        //只有pub外界才可访问
        pub fn add_to_waitlist() {}
    }
    mod serving {
        fn take_payment() {}
    }
}

// 演示如何进行module访问
//将该函数作为我们crate的公共API，因此使用pub
pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    front_of_house::hosting::add_to_waitlist();
}
```

## Cargo.toml文件说明

[dependencies] section is where you tell Cargo which external crates your project depends on and which versions of those crates you require.

单独提到crate，指源文件集合。 其它还有library crate，binary crate。



Package、Crate、Module、Path：

顶层、Package 包，Cargo的特性，让你构建、测试、共享crate
第二层、Crate 单元包，一个模块数，它可以产生一个library 或可执行文件。
第三层、Module 模块，控制代码的组织、作用域、私有路径。
最后、Path 路径，为struct、function或module等项命名的方式。
Crate 相关
包（package）创建规则：
1、一个包中至多只能包含一个库Crate。
2、包中可以包含任意多个二进制Crate。
3、包中至少包含一个 crate，无论是库的还是二进制的。
4、包中应该包含一个 Cargo.toml 配置文件，用来说明如何去构建这些 crate。
Package 的特点：
1、包含一个 Cargo.toml
2、默认的项目的 `binary crate` 的入口文件是 src/main.rs 
3、默认的库 `library crate` 的入口文件是 src/lib.rs 库名称与Package的名称相同。
4、所以一个package 既可以包含一个 `main.rs` 也可以包含 一个 `lib.rs`
5、文件放置 src/bin 下面，每个文件都是单独的binary crate

## 发布配置profile

Profile 其实是一种发布配置，例如它默认包含四种: dev、 release、 test 和 bench，正常情况下，我们无需去指定，Cargo 会根据我们使用的命令来自动进行选择。

例如 cargo build 自动选择 dev profile，而 cargo test 则是 test profile，而 cargo build --release 自动选择 release profile。

profile 可以通过 Cargo.toml 中的 [profile] 部分进行设置和改变:
```ignore
[profile.dev]
opt-level = 1               # 使用稍高一些的优化级别，最低是0，最高是3
overflow-checks = false     # 关闭整数溢出检查
```

如果是工作空间的话，只有根 package 的 Cargo.toml 中的 [profile 设置才会被使用，其它成员或依赖包中的设置会被自动忽略。

更详细说明，参见[Rust Cargo使用指南 | 第十四篇 | 发布配置 Profile](https://zhuanlan.zhihu.com/p/476524365?utm_medium=social&utm_oi=1089297405844787200)

## 条件编译

使用`#[cfg(...)]`属性标注，或在条件表达式中使用`cfg!(...)`. 详细说明见[“rust条件编译”](https://www.jianshu.com/p/c4d816e1442a)

常见类型条件有：
- debug_assertions - 若没有开启编译优化时就会成立。
- target_arch = "..." - 目标平台的CPU架构，包括但不限于x86, x86_64, mips, - powerpc, arm或aarch64。
- target_endian = "..." - 目标平台的大小端，包括big和little。
- target_env = "..." - 表示使用的运行库，比如musl表示使用的是MUSL的libc实现, msvc表- 示使用微软的MSVC，gnu表示使用GNU的实现。 但在部分平台这个数据是空的。
- target_family = "..." - 表示目标操作系统的类别，比如windows和unix。这个属性可以直- 接作为条件使用，如#[unix]，#[cfg(unix)]。

# 7.与其他语言交换

[Rust FFI](https://doc.rust-lang.org/nomicon/ffi.html`) 

`https://stackoverflow.com/questions/40833078/how-do-i-specify-the-linker-path-in-rust` 和 `https://doc.rust-lang.org/cargo/reference/build-script-examples.html`

# rust 选择不同的编译器

[Rust cargo.toml specify custom path for C linker and compiler](https://stackoverflow.com/questions/62371337/rust-cargo-toml-specify-custom-path-for-c-linker-and-compiler)

[Step by step instruction to install Rust and Cargo for mingw with Msys2](https://stackoverflow.com/questions/47379214/step-by-step-instruction-to-install-rust-and-cargo-for-mingw-with-msys2)


# STM32 (Cortex M3) 和 GD32 (RISC-V) 

[Rust 嵌入式教程](https://docs.rust-embedded.org/)

Rust 嵌入式列表

在 STM32F103 上用 Rust 驱动经典的 SSD1306

$ git clone https://github.com/jamwaffles/ssd1306

$ rustup target add thumbv7m-none-eabi
rustup target add riscv32imac-unknown-none-elf

# 问题处理

如果出现错误，执行类似`rustc --explain E0463`命令，将会得到错误码的详细解释。

## error: Unable to update registry `crates-io`

报错：
```
error: Unable to update registry `crates-io`

Caused by:
  failed to fetch `https://github.com/rust-lang/crates.io-index`
```

解决方式：

  将“~/.cargo/registry/index”或windows上的类似“C:\Users\<username>\.cargo\registry\index”删除,重新build

## error: failed to parse manifest at ... edition key

报错
```
d:\home\atmel\temp\rustdemo\greeting>cargo build
error: failed to parse manifest at `d:\home\atmel\temp\rustdemo\greeting\Cargo.toml`

Caused by:
  failed to parse the `edition` key

Caused by:
  this version of Cargo is older than the `2021` edition, and only supports `2015` and `2018` editions.
```

类似当前环境toolchain是“nightly-2021-01-07”，但project中Cargo.toml中edition为`edition = "2021"`就会产生该问题。rust edition是每隔三年发布一个edition。

解决方式：
- 如果项目的edition不可更改，比如rust avr只能支持历史版本的toolchain。调整当前rust 环境的toolchain版本，匹配项目Cargo.toml中edition
- 如果项目没有要求，则调整当前环境的toolchain