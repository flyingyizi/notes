

Rust没有垃圾回收器，取而代之的是，它引入了“所有权”(Ownership)和“借用”(Borrowing)概念来解决保证内存安全的问题。当我们说Rust是内存安全的，我们是指，在默认情况下，Rust的编译器根本不允许我们写出内存不安全的代码。

下面通过一个例子来描述典型所有权概念，这里要注意如果改为了i32等基本类型（已知大小）她们时放置到栈里面去，就不会有下面的move等行为了，下面的程序会正常编译的。

```rust
const MAJOR_VERSION: i32 = 1;
fn main() {
    let money: String = "42".to_string();
    fn borrow_it(qty: &String) {
      println!("Your money total is ${}", qty)
    }
    borrow_it(&money); // borrowed ownership
    // the ownership of money has been returned to this higher scope
    fn consume_it(qty: String) {
      println!("My money total is ${}", qty)
    }
    consume_it(money);
    // money memory is freed as the ownership has been
    // taken into the methods scope and that scope has ended.
    println!("No money: ${}", money);//Error
}
```

String类型包含有“ptrl,len,cap”等由基本类型的信息，这些信息存放在栈上，ptrl指向的内容放置在堆上。类似“`s1=s2；`”操作会导致内存的栈上s1的“ptrl,len,cap”从s1拷贝得到；对“s1=s2.clone();”行为，这会导致ptr指向的内容也会被copy单独一份作为"s1.ptr"指向。

再次强调，像整型这样的在编译时已知大小的类型被整个存储在栈上，和我们上面介绍的String不同。

***rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章详细讲解 trait）。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。要学习如何为你的类型添加 Copy 注解以实现该 trait，请阅读附录 C 中的 “可派生的 trait”。***

***那么哪些类型实现了 Copy trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：***

   - 所有整数类型，比如 u32。
   - 布尔类型，bool，它的值是 true 和 false。
   - 所有浮点数类型，比如 f64。
   - 字符类型，char。
   - 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但   - (i32, String) 就没有。

变量与数据交互的方式：
- 移动
- 克隆

# 所有权 Ownership

[A closer look at Ownership in Rust](https://blog.thoughtram.io/ownership-in-rust/), 以及[它的中文翻译](https://zhuanlan.zhihu.com/p/115651233)

所有权有以下三条规则：

- Rust 中的每个值都有一个变量，称为其所有者。
- 一次只能有一个所有者。
- 当所有者不在程序运行范围时，该值将被删除。
- 这三条规则是所有权概念的基础。

Rust在进行类似赋值或者给函数传值的行为时，Rust把值移动给了新的拥有者。这是一个非常重要的概念，因为这会影响我们在Rust中写代码的方式。

“所有权” ：某段内存只能被最后的变量名所有，前面声明过的变量都作废，这有效的避免被多个变量释放的问题，而且该操作是在编译期就可以检查到的，这策略可在编译期就能有效的避免空指针问题。

下面的例子演示了因为赋值操作导致“name”变量不再拥有值，从而导致后面出现借用一个已经moved值的错误。
```rust
/// error[E0382]: borrow of moved value: `name`
///  --> src\main.rs:6:19
///   |
/// 4 |     let name = "Pascal".to_string();
///   |         ---- move occurs because `name` has type `String`, which does not implement the `Copy` trait
/// 5 |     let a = name;
///   |             ---- value moved here
/// 6 |     println!("{}",name);
///   |                   ^^^^ value borrowed here after move
    let name = "Pascal".to_string();
    let a = name;
    println!("{}",name); //error

```

在下面例子中，虽然“name”变量因为赋值操作，它拥有的值被moved，但后面又给它拥有了一个新值，从而使用该变量合法。
```rust
    let mut name = "Pascal".to_string();
    let a = name;

    name = "other".to_string();
    println!("{}",name); //OK

```


其实本质上就是在语言层面禁止了同一个可变数据会有多个变量引用的情况，一旦作为参数传递了，就会发生所有权的移动（Move）或借用（Borrow）。赋值给另一个变更也就自动放弃了所有权。从根本上杜绝了并发情景下的数据共享冲突。

# 借用 Borrowing

不用获取所有权就可以使用值的功能，叫做 引用（references）.创建一个引用的行为称为 借用（borrowing）

如果我们尝试修改借用的变量呢？这需要类似“`fn change(some_string: &mut String) `”函数签名表达可变引用（mutable reference）。当前可变引用有一个很大的限制：在同一时间只能有一个对某一特定数据的可变引用。
