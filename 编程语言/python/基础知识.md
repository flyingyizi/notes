
Python3改变了"除"运算符行为。细节请看[python3porting](http://python3porting.com/preparing.html#use-instead-of-when-dividing-integers)网站.

### python3 引入注解

```python
a:str = "abc"
def xyz(x:int) -> int:
```

你可以通过 mypy 库来检验最终代码是否符合注解。

安装 mypy：

pip install mypy
执行代码：

mypy test.py

### 基础数据结构

    list:  []

    tuple: (,)

    list/tuple slice: L[start:end]    ,L[-2:]代表变量的倒数第二个元素以及往后的所有元素， 记住倒数第一个元素的索引是-1；L[:10:2]代表前10个元素每2个取1个；L[::5]代表所有数，每5个取一个：

    set: {}

    dict :{x:y}

### 判断变量是否可以迭代
isinstance('abc', Iterable) # str是否可迭代

### 通过enumerate内置函数实现“索引-元素对”
 for i, value in enumerate(['A', 'B', 'C']):

### 列表生成式
    [x * x for x in range(1, 11)]就生成了[1x1, 2x2, 3x3, ..., 10x10]
    ```python
    >>> [m + n for m in 'ABC' for n in 'XYZ']
    ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
    ```

### 生成器

    创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。通常访问生成器都是通过for去访问
    ```python
    >>> L = [x * x for x in range(10)]
    >>> L
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    >>> g = (x * x for x in range(10))
    >>> g
    <generator object <genexpr> at 0x1022ef630>
    ```

### 函数式编程


## python yield

[python中yield的用法详解](https://blog.csdn.net/mieleizhi0522/article/details/82142856)

把yield看做return，之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器）

生成器有两个较为重要的方法：next， send

```python
def foo():
    print("starting...")
    while True:
        res = yield 4
        print("res:",res)

g = foo()      #因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g

print(next(g)) #直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环
               #程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给
               # res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二
               # 个是return出的结果）是执行print(next(g))的结果，

print("*"*20)  #程序执行print("*"*20)，输出20个*

print(next(g)  #又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是
               #从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候
               # 赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），
               # 所以这个时候res赋值是None,所以接着下面的输出就是res:None,

               #程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print
               # 函数输出的4就是这次return出的4.
```

执行的输出是

```text
starting...
4
********************
res: None
4
```

# 

## 1. 初识python

- ython的变量标识符没有类型。
- python list的index 从0开始，倒数第一个的index是-1。 list 增加元素采用append

```python
>>> a=["a","b","c"]
>>> type(a)
<class 'list'>
>>> a.append("d")
>>> a, a[0], a[-1]
(['a', 'b', 'c', 'd'], 'a', 'd')
>>> x=a, a[0], a[-1]
>>> type(x),x
(<class 'tuple'>, (['a', 'b', 'c', 'd'], 'a', 'd'))
```

- python list常用访问语句： `for target_list in expression_list:`
- isinstance () 它允许检查某个特定标识符是否包含某个特定类型的数据
- 函数： `def funcname(parameter_list):`

- 知道python库的搜索路径

```python
>>> import sys; sys.path
['', 'C:\\prog\\Anaconda3\\envs\\myenv\\python38.zip', 'C:\\prog\\Anaconda3\\envs\\myenv\\DLLs', 'C:\\prog\\Anaconda3\\envs\\myenv\\lib', 'C:\\prog\\Anaconda3\\envs\\myenv', 'C:\\prog\\Anaconda3\\envs\\myenv\\lib\\site-packages', 'C:\\prog\\Anaconda3\\envs\\myenv\\lib\\site-packages\\win32', 'C:\\prog\\Anaconda3\\envs\\myenv\\lib\\site-packages\\win32\\lib', 'C:\\prog\\Anaconda3\\envs\\myenv\\lib\\site-packages\\Pythonwin']
```

- list/tuple的工厂函数: list/tuple
- range(4)生成0，1，2，3这四个数字



## 2 共享你的代码

共享通过： 模块、发布工具实现。

- 模块就是一个包含Python代码的文本文件。对模块的主要蒂求就是要求文件名以PY结尾，这是Python扩展名。要把你的函数转换为一个模块，需要把代码保存到一个适当命名的文件
- pyPI（python package index）为第三方库提供了一个集中的存储库

###  建立模块的例子

下面是一个最简单的例子

首先建立几个文件
```sh
packageDemo/$touch nester.py
packageDemo/$touch setup.py
packageDemo/$touch readme.md
packageDemo/$touch __init__.py
```

它们的内容分别是：

```python
# setup.py 内容
import setuptools
setuptools.setup(
    name="mydemo",
    version="0.0.1",
    author="",
    author_email="",
    py_modules=["nester"],
    packages=setuptools.find_packages(),
)

# nester.py内容是随意写的一个函数print_lol

# __init__.py 内容空
```

首先执行sdist指令，构建发布文件

```sh
(myenv) packageDemo>python setup.py sdist
running sdist
running egg_info
writing mydemo.egg-info\PKG-INFO
writing dependency_links to mydemo.egg-info\dependency_links.txt
writing top-level names to mydemo.egg-info\top_level.txt
reading manifest file 'mydemo.egg-info\SOURCES.txt'
writing manifest file 'mydemo.egg-info\SOURCES.txt'
running check
warning: check: missing required meta-data: url

warning: check: missing meta-data: either (author and author_email) or (maintain
er and maintainer_email) must be supplied

creating mydemo-0.0.1
creating mydemo-0.0.1\mydemo.egg-info
copying files to mydemo-0.0.1...
copying nester.py -> mydemo-0.0.1
copying setup.py -> mydemo-0.0.1
copying mydemo.egg-info\PKG-INFO -> mydemo-0.0.1\mydemo.egg-info
copying mydemo.egg-info\SOURCES.txt -> mydemo-0.0.1\mydemo.egg-info
copying mydemo.egg-info\dependency_links.txt -> mydemo-0.0.1\mydemo.egg-info
copying mydemo.egg-info\top_level.txt -> mydemo-0.0.1\mydemo.egg-info
Writing mydemo-0.0.1\setup.cfg
Creating tar archive
removing 'mydemo-0.0.1' (and everything under it)

(myenv) c:\tuxueqing\pythondemo\packageDemo>
```

接着执行install，将构建安装到本地

```sh
(myenv) packageDemo>python setup.py install
running install
running bdist_egg
running egg_info
writing mydemo.egg-info\PKG-INFO
writing dependency_links to mydemo.egg-info\dependency_links.txt
writing top-level names to mydemo.egg-info\top_level.txt
reading manifest file 'mydemo.egg-info\SOURCES.txt'
writing manifest file 'mydemo.egg-info\SOURCES.txt'
installing library code to build\bdist.win-amd64\egg
running install_lib
warning: install_lib: 'build\lib' does not exist -- no Python modules to install

creating build
creating build\bdist.win-amd64
creating build\bdist.win-amd64\egg
creating build\bdist.win-amd64\egg\EGG-INFO
copying mydemo.egg-info\PKG-INFO -> build\bdist.win-amd64\egg\EGG-INFO
copying mydemo.egg-info\SOURCES.txt -> build\bdist.win-amd64\egg\EGG-INFO
copying mydemo.egg-info\dependency_links.txt -> build\bdist.win-amd64\egg\EGG-IN
FO
copying mydemo.egg-info\top_level.txt -> build\bdist.win-amd64\egg\EGG-INFO
zip_safe flag not set; analyzing archive contents...
creating 'dist\mydemo-0.0.1-py3.8.egg' and adding 'build\bdist.win-amd64\egg' to
 it
removing 'build\bdist.win-amd64\egg' (and everything under it)
Processing mydemo-0.0.1-py3.8.egg
Copying mydemo-0.0.1-py3.8.egg to c:\prog\anaconda3\envs\myenv\lib\site-packages

Adding mydemo 0.0.1 to easy-install.pth file

Installed c:\prog\anaconda3\envs\myenv\lib\site-packages\mydemo-0.0.1-py3.8.egg
Processing dependencies for mydemo==0.0.1
Finished processing dependencies for mydemo==0.0.1

(myenv) c:\tuxueqing\pythondemo\packageDemo>
```

最后导入该package，并执行的验证结果如下

```SH
(myenv) c:\tuxueqing\pythondemo\packageDemo>python
Python 3.8.1 (default, Jan  8 2020, 15:55:49) [MSC v.1916 64 bit (AMD64)] :: Ana
conda, Inc. on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import nester
>>> cast=["a","b",]
>>> nester.print_lol(cast)
a
b
>>>
```

## 3 文件与异常

[Python 工匠：高效操作文件的三个建议](https://www.zlovezl.cn/articles/three-tips-on-writing-file-related-codes/)

