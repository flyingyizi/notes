
# 伪操作和宏指令

伪指令——是汇编语言程序里的特殊指令助记符，在汇编时被合适的机器指令替代。

伪操作——为汇编程序所用，在源程序进行汇编时由汇编程序处理，只在汇编过程起作用，不参与程序运行。

宏指令——通过伪操作定义的一段独立的代码。在调用它时将宏体插入到源程序中。也就是常说的宏。

说明：所有的伪指令、伪操作和宏指令，均与具体的开发工具中的编译器有关

1.宏定义(MACRO、MEND)

格式：MACRO

{$标号名}宏名{$参数1，$参数2，……}

指令序列

MEND

MACRO、MEND伪指令可以将一段代码定义为一个整体，称为宏指令，在程序中通过宏指令多次调用该段代码。

{}为可选项

$标号在宏指令被展开时，标号会被替换为用户定义的符号

在宏定义体的第一行应声明宏的原型(包含宏名、所需的参数)，然后就可以在汇编程序中通过宏名来调用该指令序列

写在代码段或数据段前面

MEXIT跳出宏

例：没有参数的宏（实现子函数返回）

MACRO

MOV_PC_LR;宏名

MOVPC,LR;子程序返回，R0内为返回的结果

MEND

AREAExample,CODE,READONLY;声明代码段Example

ENTRY;程序入口

Start

MOVR0,#0;设置实参,将传递给子程骗子的实参存放在r0和r1内

MOVR1,#10

BLADD_NUM;调用子程序ADD_NUM

BLSUB_NUM;调用子程序SUB_NUM

BOVER;跳转到OVER标号处，进入结尾

EXPORTADD_NUM

ADD_NUM

ADDR0,R0,R1;实现两数相加

MOV_PC_LR;调用宏，代表子函数结束

EXPORTSUB_NUM

SUB_NUM

SUBR0,R1,R0;实现两数相减

MOV_PC_LR;调用宏，代表子函数结束

OVER

END

例：有参数宏

宏定义从MACRO伪指令开始，到MEND结束，并可以使用参数。类似于C的#define

MACRO;宏定义

CALL$Function,$dat1,$dat2;宏名称为CALL,带3个参数

IMPORT$Function;声明外部子程序宏开始

MOVR0,$dat1;设置子程序参数,R0=$dat1

MOVR1,$dat2

BL$Function;调用子程序宏最后一句

MEND;宏定义结束

CALLFADD1,#3,#2;宏调用，后面是三个参数

汇编预处理后，宏调用将被展开，程序清单如下：

IMPORTFADD1

MOVR0,#3

MOVR1,#3

BLFADD1

2.符号定义伪操作

1)定义常量(EQU)

格式：标号名称EQU表达式{，类型}

用于为程序中的常量、标号等定义一个等效的字符名称，类似于C语言中的＃define。

其中EQU可用*代替。

标号名称：为常量名。

表达式：寄存器的地址值、程序中的标号、32位地址常量、32位常量

当表达式为32位的常量时，可以指定表达式的数据类型，可以有以下三种类型：

CODE16、CODE32和DATA

示例：EQU的使用

XEQU45;即#defineX45，必须顶格

YEQU64

stack_topEQU0x30200000，CODE32

AREAExample,CODE,READONLY

CODE32

ENTRY

Start

LDRSP,=stack_top;stack_top内的值0x30200000是地址，=stack_top是取stack_top常量地址(即指针的指针)

MOVR0,#X;将X替换为45

STRR0,[SP];将R0内的45存入到SP所指向的内存中（SP此时是指针的指针）

MOVR0,#Y

LDRR1,[SP];从内存中读取数据到R1内

ADDR0,R0,R1

STRR0,[SP]

END

注：X,Y,stack_top为标号，必须顶格写，大多写在代码段外面

2)定义变量

常量:数字常量,有三种表示方式：十进制数、十六进制数、字符串常量、布尔常量(如testnoSETS{FALSE})

变量:数字变量、逻辑变量、字符串变量

(1)*GBLA、GBLL、GBLS定义全局变量

格式：GBLA(GBLL、GBLS)全局变量名

GBLA伪指令用于定义一个全局的数字变量，并初始化为0；

GBLL伪指令用于定义一个全局的逻辑变量，并初始化为F(假)；

GBLS伪指令用于定义一个全局的字符串变量，并初始化为空；

由于以上三条伪指令用于定义全局变量，因此在整个程序范围内变量名必须唯一。

示例：全局变量的定义与赋值

GBLAcount;定义全局变量

countSETA2;给全局变量赋值为2，必须顶格

AREAExample,CODE,READONLY

CODE32

ENTRY

Start

MOVR0,#count;将count内的值写入R0内

ADDR0,R0,#2

BStart

END

注：在赋值过程中，全局变量名必须顶格写，全局变量常在代码段外定义和赋值

示例：变量与内存地址

GBLAglobv

globvSETA23

AREAExample,CODE,READONLY;声明代码段Example

ENTRY;程序入口

Start

LDRR0,=globv;golbv是全局变量，将内存地址读入到R0内

LDRR1,[R0];将内存数据值读入到R1内

ADDR1,R1,#2

STRR1,[R0];将修改后数据再赋给变量

MOVR0,#0

OVER

END

注：#取变量值=取变量地址［R0］读取R0内地址所指向的数据值

(2)*LCLA、LCLL、LCLS定义局部变量

格式：LCLA(LCLL或LCLS)局部变量名

LCLA伪指令用于定义一个局部的数字变量，并初始化为0；

LCLL伪指令用于定义一个局部的逻辑变量，并初始化为F(假)；

LCLS伪指令用于定义一个局部的字符串变量，并初始化为空；

以上三条伪指令必须写在宏定义内，用于声明局部变量，宏结束，局部变量不再起作用

示例：

LCLAnum；声明一个局部的数字变量，变量名为num

numSETA0xaa；将该变量赋值为0xaa

LCLLisOk；声明一个局部的逻辑变量，变量名为isOk

isOkSETL；将该变量赋值为真

LCLSstr1；定义一个局部的字符串变量，变量名为str1

str1SETS"Testing"；将该变量赋值为"Testing"

示例：局部变量的定义与赋值

MACRO

MOV_START;宏名

LCLAx;定义局部变量

LCLAy

xSETA12;必须顶格写

ySETA24

MOVR0,#2

MOVR1,#3

ADDR0,R0,R1

MEND

AREAExample,CODE,READONLY;声明代码段Example

ENTRY;程序入口

Start

MOV_START

MOVR0,#0

OVER

END

注：在赋值过程中，局部变量名必须顶格写，局部变量必须在宏定义内使用

(3)*SETA、SETL和SETS用于给一个已经定义的全局变量或局部变量赋值。

SETA伪指令用于给一个数学变量赋值；

SETL伪指令用于给一个逻辑变量赋值；

SETS伪指令用于给一个字符串变量赋值；

其中，变量名为已经定义过的全局变量或局部变量，表达式为将要赋给变量的值。

(4)变量代换$

$在数字变量前，将变值转换为十六进制字符串

$在逻辑变量前，将变量转换为真或假

$在字符串变量前,替换后面变量的字符串

如：

LCLSY1;定义局部字符串变量Y1和Y2

LCLSY2

Y1SETS"WORLD!"

Y2SETS"LELLO,$Y1";将字符串Y2的值替换$Y1，形成新的字符串

3)、定义一个寄存器(RN)

格式：名称RN表达式

RN伪指令用于给一个寄存器定义一个别名。

示例：

TempRNR0；将R0定义一个别名Temp

4)定义寄存器列表(RLIST)

格式：名称RLIST{寄存器列表}

用于对一个通用寄存器列表定义名称，使用该伪指令定义的名称可在ARM指令LDM/STM中使用。

在LDM/STM指令中，寄存器列表中的寄存器访问次序总是先访问编号较低的寄存器，再访问编号较高的寄存器，而不管寄存器列表中各寄存器的排列顺序。

示例：RegListRLIST{R0-R5，R8，R10};将寄存器列表名称定义为RegList，用于多寄存器寻址（后面详解）

5)定义协处理器寄存器(CN)

格式：名称CN协处理器的寄存器编号

示例：PowerCN6;将协处理器的寄存器6名称定义为Power

6)定义协处理器(CP)

格式:名称CP协处理器名

示例：DmuCP6;将协处理器6名称定义为Dmu

7)定义浮点或精度寄存器(DN,SN,FN)

格式：名称DN双精度寄存器编号;DN为双精度VFP寄存器定义名称

格式：名称SN单精度寄存器编号;SN为单精度VFP寄存器定义名称

格式：名称FN浮点寄存器编号;FN为浮点寄存器定义名称

示例:

heightDN6;将VFP双精度寄存器6名称定义为height

widthSN16;将VFP单精度寄存器16名称定义为width

heightFN6;将浮点寄存器6名称定义为height

//^^^^^^^^^^^^^^^^^^^^^^^^^^下午^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

3.数据定义伪操作（申请内存）

数据定义伪指令用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。

1)按类型分配内存

格式：标号伪指令表达式

标号

表达式：初始化的值，表达式可以为程序标号或字符、数字表达式

伪指令：如下

(1)DCB用于分配一片连续的字节存储单元（字符数组），可用=号代替

StrDCB"Thisisatest!";分配一片连续的字节存储单元并初始化。

(2)DCW(或DCWU)用于分配一片连续的半字存储单元(16位短整型数组)，DCW半字对齐，DCWU不严格半字对齐。

DataTestDCW1,2,3

(3)DCD(或DCDU)用于分配一片连续的字存储单元(32位，整型数组),DCD可用&代替，DCD字对齐的

DataTestDCD4,5,6

(4)DCFD(或DCFDU)为双精度的浮点数分配一片连续的字存储单元,每个双精度的浮点数占据两个字单元。

FDataTestDCFD2E115,-5E7

(5)DCFS(或DCFSU)为单精度的浮点数分配一片连续的字存储单元,每个单精度的浮点数占据一个字单元。

FDataTestDCFS2E5,-5E-7

(6)DCQ(或DCQU)用于分配一片以8个字节为单位的连续存储区域(每8字节为一个数据的数组)

DataTestDCQ100;分配一片连续的存储单元并初始化为指定的值100。

2)申请连续内存

(1)申请一个连续内存（SPACE）

用于分配一片连续的存储区域并初始化为0,可用%代替

格式:标号SPACE表达式

表达式为要分配的字节数

例：DataSpaceSPACE100;分配连续100字节的存储单元并初始化为0。

(2)声明一个数据缓冲池的开始(LTORG)

通常，把数据缓冲池放在代码段的最后面，下一个代码段之前，或END之前

示例：

AREAExample,CODE,READONLY;声明代码段Example

ENTRY;程序入口

Start

BLfuncl

funcl

LDRR0,=0x12345678

ADDR1,R1,R0

MOVPC,LR

LTORG;定义缓冲池0x12345678LTORG根据LDR确定内存地址

dataSPACE4200;从当前位置开始分配4200字节内存

END

(3)定义一个结构化的内存表首地址（MAP）

格式:MAP表达式{，基址寄存器}

用于定义一个结构化的内存表的首地址。可用^代替。

表达式可以为程序中的标号或数学表达式，基址寄存器为可选项.

当基址寄存器选项不存在时，表达式的值即为内存表的首地址，

当该选项存在时，内存表的首地址为表达式的值与基址寄存器的和。

例：

DatastrucSPACE280;分配280个字节单元

MAPDatastruc；内存表的首地址为Datastruc内存块

(4)定义一个结构化内存表的数据域（FILED）

用于定义一个结构化内存表中的数据域。可用#代替

格式：标号FILED表达式

FIELD伪指令常与MAP伪指令配合使用来定义结构化的内存表。表达式的值为当前数据域所占的字节数。

标号为数据域（字段、成员变量）名

MAP伪指令定义内存表的首地址，

FIELD伪指令定义内存表中的各个数据域，并可以为每个数据域指定一个标号供其他的指令引用。(3)内存首地址(MAP)

MAP伪指令通常与FIELD伪指令配合使用来定义结构化的内存表。

示例：

DatastrucSPACE280;分配280个字节单元

MAPDatastruc；内存表的首地址为Datastruc内存块

constaFIELD4；字段consta长度4字节，相对地址0

constabFIELD4；字段constab长度4字节，相对地址4

xFIELD8；字段x长度8字节，相对地址8

yFIELD8；字段y长度8字节，相对地址16

stringFIELD256；字段string长度256字节，相对地址24

LDRR6，[R9,consta];引用内存表中的数据域

注意：MAP伪操作和FIELD伪操作仅仅是定义数据结构，他们并不实际分配内存单元，而SPACE用于分配内存

4.汇编控制伪操作

用于控制汇编程序的执行流程，常用的汇编控制伪指令包括以下几条：

(1)IF逻辑表达式...ELSE...ENDIF条件控制

(2)WHILE逻辑表达式...WEND循环控制

例：条件编译

AREAExample,CODE,READONLY

CODE32

Data_in*100;定义标号Data_in的值为100在ENTRY入口之前

GBLAcount;定义全局变量

countSETA20

ENTRY

Start

IFcount

MOVR0,#3

ELSE

MOVR1,#24

ENDIF

MOVR1,#12

ADDR0,R0,R1

END

例：循环编译

GBLACounter；声明一个全局的数学变量，变量名为Counter

CounterSETA3；由变量Counter控制循环次数

……

WHILECounter<10

指令序列

IFcontinue

MEXIT;退出宏

ENDIF

WEND

5.其他常用的伪指令

1)、AREA

格式：AREA段名属性1，属性2，……

AREA伪指令用于定义一个代码段或数据段。其中，段名若以数字开头，则该段名需用"|"括起来，如|1_test|。

属性字段表示该代码段(或数据段)的相关属性，多个属性用逗号?

—CODE属性：用于定义代码段，默认为READONLY。

—DATA属性：用于定义数据段，默认为READWRITE。

—READONLY属性：指定本段为只读，代码段默认为READONLY。

—READWRITE属性：指定本段为可读可写，数据段的默认属性为READWRITE。

—ALIGN属性：使用方式为ALIGN表达式。在默认时，ELF(可执行连接文件)的代码段和数据段是按字对齐的

—COMMON属性：定义一个通用的段，不包含任何的用户代码和数据。各源文件中同名的COMMON段共享同一段存储单元

一个汇编语言程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段。

使用示例：

AREAInit，CODE，READONLY

该伪指令定义了一个代码段，段名为Init，属性为只读

2)、ENTRY

格式：ENTRY

用于指定汇编程序的入口点。一个源文件里最多只能有一个ENTRY(可以没有)。

3)、END

格式：END

用于通知编译器已经到了源程序的结尾。

4)、CODE16、CODE32

格式：CODE16(或CODE32)

CODE16伪指令通知编译器，其后的指令序列为16位的Thumb指令。

CODE32伪指令通知编译器，其后的指令序列为32位的ARM指令。

在使用ARM指令和Thumb指令混合编程的代码里，可用这两条伪指令进行切换

示例：

AREAInit，CODE，READONLY

CODE32；通知编译器其后的指令为32位的ARM指令

LDRR0，＝NEXT+1；将跳转地址放入寄存器R0

BXR0；程序跳转到新的位置执行，并将处理器切换到Thumb工作状态

……

CODE16；通知编译器其后的指令为16位的Thumb指令

NEXTLDRR3，＝0x3FF

……

END；程序结束

5)、EXPORT(或GLOBAL)

格式：EXPORT标号

export伪指令用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。

6)、IMPORT

格式：IMPORT标号

IMPORT伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用

如果当前源文件实际并未引用该标号，该标号也会被加入到当前源文件的符号表中。

7)、EXTERN

格式：EXTERN标号

EXTERN伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用

如果当前源文件实际并未引用该标号，该标号就不会被加入到当前源文件的符号表中。

8)、GET(或INCLUDE)

格式：GET文件名

GET伪指令用于将一个源文件包含到当前的源文件中，并将被包含的源文件在当前位置进行汇编处理。

汇编程序中常用的方法是在某源文件中定义一些宏指令，用EQU定义常量的符号名称，用MAP和FIELD定义结构化的数据类型，然后用GET伪指令将这个源文件包含到其他的源文件中。使用方法与C语言中的"include"相似。

GET伪指令只能用于包含源文件，包含目标文件需要使用INCBIN伪指令

示例：

AREAInit，CODE，READONLY

GETa1.s；通知编译器当前源文件包含源文件a1.s

GETC：\a2.s；通知编译器当前源文件包含源文件C：\a2.s……

END

9)、INCBIN

格式：INCBIN文件名

INCBIN伪指令用于将一个目标文件或数据文件包含到当前的源文件中

示例：

AREAInit，CODE，READONLY

INCBINa1.dat；通知编译器当前源文件包含文件a1.dat

INCBINC：\a2.txt；通知编译器当前源文件包含文件C：\a2.txt……

END

10)、ROUT

格式：{名称}ROUT

ROUT伪指令用于给一个局部变量定义作用范围。

在程序中未使用该伪指令时，局部变量的作用范围为所在的AREA，

而使用ROUT后，局部变量的作为范围为当前ROUT和下一个ROUT之间。

11)、ALIGN

格式：ALIGN{表达式{，偏移量}}

ALIGN伪指令可通过添加填充字节的方式，使当前位置满足一定的对其方式

表达式的值用于指定对齐方式，可能的取值为2的幂，如1、2、4、8、16等。

偏移量也为一个数字表达式，若使用该字段，则当前位置的对齐方式为：2的表达式次幂＋偏移量。

示例：

AREAInit，CODE，READONLY，ALIEN＝3；指定后面的指令为8字节对齐。

五.ARM汇编伪指令(读取内存地址)

1)ADR及ADRL

将PC相对偏移的地址或基于寄存器相对偏移的地址值读取到寄存器中

格式：ADR(ADRL)寄存器,地址表达式

ADR小范围的地址读取伪指令，

ADRL中等范围的地址读取伪指令

例：

查表

ADRR0,D_TAB;加载转换表地址

LDRBR1,[R0,R2];使用R2作为参数，进行查表

……

D_TAB

DCB0xC0,0xF9,0xA4,0xB0,0x99,0x92

2)LDR

用于加载32位立即数或一个地址值到指定的寄存器，大范围的地址读取伪指令.

LDR通常都是作加载指令，但是它也可以作伪指令。作用是装载一个32bit常数和一个地址到寄存器。

格式：LDR寄存器,=地址表达式

COUNTEQU0x56000054;COUNT是一个变量，地址为0x56000054。

LDRR1,=COUNT;将COUNT这个变量的值（地址），也就是0x56000054放到R1中。

MOVR0,#0

STRR0,[R1];是一个典型的存储指令，将R0中的值放到以R1中的值为地址的存储单元去

;这三条指令是为了完成对变量COUNT赋值。

3)NOP

空操作伪指令，可用于延时操作

例：延时子程序

Delay

NOP;空操作

NOP

NOP

SUBSR1,R1,#1;循环次数减1

BNEDelay

MOVPC,LR

六、Thumb指令集

有兴趣的自学
