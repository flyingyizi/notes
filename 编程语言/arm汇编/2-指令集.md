
[ARM Compiler v5.06 for µVision armasm User Guide](https://www.keil.com/support/man/docs/armasm/default.htm)

指令集：
- A64 instruction set：The A64 instruction set, introduced in Armv8-A to support the 64-bit architecture. [document](https://developer.arm.com/architectures/instruction-sets/base-isas/a64). 
- A32 instruction set: The A32 instruction set, referred to as ‘ARM’ in Armv6 and Armv7 architectures. [document](https://developer.arm.com/architectures/instruction-sets/base-isas/a32).ARM指令集通常称为 A32指令集）是一种固定长度（32 位）的指令集。它是 ARMv4T、ARMv5TEJ 和 ARMv6 架构中使用的基础 32 位 ISA。
- T32 instruction set: The T32 instruction set, referred to as ‘Thumb’ in Armv6 and Armv7 architectures. [document](https://developer.arm.com/architectures/instruction-sets/base-isas/t32). Thumb （T32） 指令集提供已压缩至 16 位宽操作码的、最常用的 32 位 ARM 指令的子集。在执行时，这些 16 位指令实时、透明地解压缩为完整 32 位 ARM 指令，且无性能损失。

本章节内容主要来自官方[introduction-to-arm](http://www.davespace.co.uk/arm/introduction-to-arm/multiply.html).

[UAL (Unified Assembler Language). Among many other changes this allows the condition code to go after the flags](http://www.davespace.co.uk/arm/introduction-to-arm/syntax.html).

[ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition](https://developer.arm.com/documentation/ddi0406/cd/)

http://5b0988e595225.cdn.sohucs.com/images/20181217/a13cefa977844f9f9a35b04a8728c2d7.png

S = 0: means dont set the condition codes
S = 1: means set the condition codes according to the result of the operation
 
data processing / PSR transfer
  1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 9 8 7 6 5 4 3 2 1 0
  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 ┌───────┬─┬─┬─┬───────┬─┬───────┬───────┬───────────────────────┐
 │cond   │0│0│1│opcode │S│  Rn   │  Rd   │  Operand 2            │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
-multiply
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬─┬─┬─┬─┬───────┐
 │cond   │0│0│0│0│0│0│A│S│  Rd   │  Rn   │  Rs   │1│0│0│1│ Rm    │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
-multiply long
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬─┬─┬─┬─┬───────┐
 │cond   │0│0│0│0│1│U│A│S│ RdHi  │ RdLo  │  Rn   │1│0│0│1│ Rm    │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
_single data swap
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┐
 │cond   │0│0│0│1│0│B│0│0│  Rn   │  Rd   │0│0│0│0│1│0│0│1│  Rm   │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
branch and exchange
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬───────┐
 │cond   │0│0│0│1│0│0│1│0│1│1│1│1│1│1│1│1│1│1│1│1│0│0│0│1│ Rn    │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
halfword data transfer: register offset
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┐
 │cond   │0│0│0│P│U│0│W│L│  Rn   │  Rd   │0│0│0│0│1│S│H│1│  Rm   │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
halfword data transfer: immediate offset
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬─┬─┬─┬─┬───────┐
 │cond   │0│0│0│P│U│1│W│L│  Rn   │  Rd   │offset │1│S│H│1│offset │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
-single data transfer
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────────────────────┐
 │cond   │0│1│1│P│U│B│W│L│  Rn   │  Rd   │  offset               │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
block data transfer
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────────────────────────────┐
 │cond   │1│0│0│P│U│S│W│L│  Rn   │   register list               │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
-branch
 ┌───────┬─┬─┬─┬─┬───────────────────────────────────────────────┐
 │cond   │1│0│1│L|    offset                                     │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
-coprocessor data transfer
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬───────────────┐
 │cond   │1│1│0│P│U│N│W│L│  Rn   │  CRd  │ CP#   │   offset      │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
-coprocessor data operaton
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬─────┬─┬───────┐
 │cond   │1│1│1│0│CP  Opc│  CRn  │  CRd  │ CP#   │CP   │0│ CRm   │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
-coprocessor data Register transfer
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬─────┬─┬───────┐
 │cond   │1│1│1│0│CPOpc|L│  CRn  │  Rd   │ CP#   │CP   │1│ CRm   │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
software interrupt
 ┌───────┬─┬─┬─┬─┬───────────────────────────────────────────────┐
 │cond   │1│1│1│1│     ignored by  processor                     │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘


ARM 指令集共包括6种类型:数据处理指令、跳转指令、程序状态指令、加载存取储指令、协处理指令、软中断指令

参考：
- ARM Compiler toolchain version 5.0 Assmbler Reference
- ARM Architecture Reference Manual
- ARM Instruction Set

# (零)指令格式与语法

最简单的汇编指令格式是操作码和操作数

如:"`MOV r0,#10`"

操作码：即CPU指令如MOV, ADD

操作数：即表示数据是在寄存器中还是在内存中，是绝对地址还是相对地址

操作数部分要解决的问题是，到哪里去获取操作数，获取操作数的方式就是寻址方式。

ARM每一条指令都是32位机器码，对应CPU的位数

ARM指令格式：

在32位中分为7个位域，每个位域分别存储不同意义的编码（二进制数）

```text
   31                              11             0
    ┌────┬──┬──┬───────┬──┬───┬───┬───────────────┐
    │cond│00│X │ opcode│ S│ Rn│Rd │shifted-operand│
    └────┴──┴──┴───────┴──┴───┴───┴───────────────┘
```

语法格式：

```text
 <opcode>{<cond>}{S}    <Rd>,<Rn>{,第2操作数}

 解释：
 - <>内的项是必须的，{}内的项是可选的 
 - opcode：指令助记符；指令操作码用4个位存储，如MOV,ADD。每一个操作码和操作数最终都是以二进制形式存在
 - cond：执行条件；可省略
 - S：是否影响CPSR寄存器的值；省略则表示为0值，否则为1值
 - Rd：目标寄存器；
 - Rn：第1个操作数的寄存器；
 - operand2：第2个操作数； bits[11,0]
```

## <cond>

"cond"条件码列表：

|Code	|Suffix|	Description	                              |Flags|
|-----|------|-------------------------------------------|----|
|0000	|EQ	 |  Equal / equals zero	                     |Z==1|
|0001	|NE	 |  Not equal	                              |Z==0|
|0010	|CS    |  / HS	Carry set / unsigned higher or same	|C==1|
|0011	|CC    |  / LO	Carry clear / unsigned lower	      |C==0|
|0100	|MI	 |  Minus / negative	                        |N==1|
|0101	|PL	 |  Plus / positive or zero	               |N==0|
|0110	|VS	 |  Overflow	                              |V==1|
|0111	|VC	 |  No overflow	                           |V==0|
|1000	|HI	 |  Unsigned higher	                        |C==1 and Z==0|
|1001	|LS	 |  Unsigned lower or same	                  |C==0 or Z==1|
|1010	|GE	 |  Signed greater than or equal	            |N == V|
|1011	|LT	 |  Signed less than	                        |N != V|
|1100	|GT	 |  Signed greater than	                     |Z==0 and (N == V)|
|1101	|LE	 |  Signed less than or equal	               |Z==1 or (N != V)|
|1110	|AL	 |  Always (default)	                        |any|

注： 上表中的"N(negative)/Z(zero)/C(carry)/V(overflow)"标志位指[CPSR](https://img-blog.csdn.net/20180427165727925)中的最高四位



位域"cond"例子：

   - "`ADD r0,r0,#1 ;计算r0加1后的值，再写入到r0内`"; 
   - "`ADDEQ  r0,r0,#1;只有在CPSR寄存器条件标志位满足指定条件时，才计算r0加1后的值，再写入到r0内`"

```arm
//例子1：Use a sequence of several conditional instructions:
    ;Assume a is in R0. Compare R0 to 5. The next two instructions 
    ;will be executed only if the compare returns EQual. They 
    ;move 10 into R0, then call ‘fn’ (branch with link, BL).
    CMP   r0, #5   ; if (a == 5)
    MOVEQ r0, #10  
    BLEQ  fn       ;   fn(10)

//例子2：Set the flags, then use various condition codes:
    CMP   r0, #0   ; if (x <= 0)
    MOVLE r0, #0   ;   x = 0;
    MOVGT r0, #1   ; else x = 1;

//例子3:Use conditional compare instructions:
    CMP   r0, #'A' ; if (c == 'A'
    CMPNE r0, #'B' ;  || c == 'B')
    MOVEQ r1, #1   ;   y = 1;

//例子4：A sequence which doesn’t use conditional execution:

    CMP   r3, #0
    BEQ   next
    ADD   r0, r0, r1
    SUB   r0, r0, r2
next
    ...
```



## "`<S>`"

位域"S"例子：

   - "`SUBS  R0,R0,#1 ;R0减1，结果放入R0，同时响影CPSR的值`"; 
   - "`SUB   R0,R0,#1 ;R0减1，结果放入R0，不影响CPSR的值`"

x


# (一）、数据处理指令

数据处理指令，只能对寄存器内容进行操作，而不能对内存进行操作，所有数据处理指令均可使用S后缀，并影响状态标志

包括：

- 数据搬移指令：MOV MVN
- 算术指令：    ADD ADC SUB SBC RSB RSC
- 逻辑运算指令: AND ORR EOR BIC
- 比较指令：    CMP CMN TST TEQ
- 乘法指令：
- 移位指令

```text
data processing / PSR transfer
  1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 9 8 7 6 5 4 3 2 1 0
  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 ┌───────┬─┬─┬─┬───────┬─┬───────┬───────┬───────────────────────┐
 │cond   │0│0│1│opcode │S│  Rn   │  Rd   │  Operand 2            │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

语法：<操作>{cond}{S}  Rd, Rn, Operand2

```

## 1.数据传输指令

### 1)MOV数据传送指令

```text
MOV data processing 
 ┌───────┬─┬─┬─┬───────┬─┬───────┬───────┬───────────────────────┐
 │cond   │0│0│1│1 1 0 1│S│x x x x│  Rd   │  Operand 2            │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

语法：MOV{cond}{S}  Rd, Operand2

Operand2 只有bits[0,11]12位代表value,其中包括：rotate4, immediated8(8 bit unsigned binary number)
 ┌───────┬───────────────┐
 │rotated│ immediate     │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
          7 6 5 4 3 2 1 0
   - if rotate4 =0, the 8 bit constans is not rotated
   - if rotate4 =1, the 8 bit constans is rotated left 2 positions
   - if rotate4 =2, the 8 bit constans is rotated left 4 positions
   - ...
```


格式：MOV Rd,

功能：Rd＝操作数,操作数可以是寄存器、被移位的寄存器或立即数。

例：

   - "`MOV R0,#0xFF000;立即寻址，将立即数0xFF000(第2操作数)装入R0寄存器`"
   - "`MOV R1,R2;寄存器寻址，将R2的值存入R1`"
   - "`MOV R0,R2,LSL#3;移位寻址，R2的值左移3位，结果放入R0`"

### 2)MVN数据取反传送指令


格式：MVN,;

功能：将操作数传送到目的寄存器Rd中，但该值在传送前被按位取反，即Rd=!op1；

例：
   - "`MVN R0,＃0;R0=-1`" 

mvn意为“取反传输”，它把源寄存器的每一位取反，将得到的结果写入结果寄存器。

movs和mvns指令对pc寄存器赋值时有特殊含义，表示要求在赋值的同时从spsr中恢复cpsr。

mov和mvn指令，编译器会进行智能的转化。比如指令“movr1,0xffffff00”中的立即数是非法的。

在编译时，编译器将其转化为“mvn r1,0xff”，这样就不违背立即数的要求。所以对于mov和mvn指令，

可以认为：合法的立即数反码也是合法的立即数。


## 2.算术指令

### 1)ADD加法指令

格式：ADD{}{S},,;

功能：Rd＝Rn+op2

例：

ADDR0,R1,＃5;R0=R1+5

ADDR0,R1,R2;R0=R1+R2

ADDR0,R1,R2,LSL＃5;R0=R1+R2左移5位

### 2)ADC带进位加法指令

格式：ADC{}{S},,;

功能：Rd＝Rn+op2+carry,carry为进位标志值。该指令用于实现超过32位的数的加法。

例如：

第一个64位操作数存放在寄存器R2，R3中；

第二个64位操作数存放在寄存器R4，R5中；

64位结果存放在R0，R1中。

ADDSR0,R2,R4;低32位相加，S表示结果影响条件标志位的值

ADCR1,R3,R5;高32位相加

### 3)SUB减法指令

格式：SUB{}{S},,;

功能：Rd＝Rn-op2

例：
 
   - "`SUB R0,R1,＃5;R0=R1-5`"
   - "`SUB R0,R1,R2;R0=R1-R2`"
   - "`SUB R0,R1,R2,LSL＃5;R0=R1-R2左移5位`"
   - "``"



### 4)SBC带借位减法指令

格式：SBC{}{S},,;

功能：Rd＝Rn-op2-!carry

SUB和SBC生成进位标志的方式不同于常规，如果需要借位则清除进位标志，所以指令要对进位标志进行一个非操作。

例：

第一个64位操作数存放在寄存器R2，R3中；

第二个64位操作数存放在寄存器R4，R5中；

64位结果存放在R0，R1中。

SUBS R0,R2,R4;低32位相减，S表示结果影响条件标志位的值

SBCR1,R3,R5;高32位相减

### 5)其它减法指令

RSB反向减法指令,同SUB指令，但倒换了两操作数的前后位置，即Rd＝op2-Rn。

RSC带借位的反向减法指令,同SBC指令，但倒换了两操作数的前后位置，即Rd＝op2-Rn-!carry。

rsb r0,r1,r2 /*r0=r2–r1*/

rsc r0,r1,r2 /*r0=r2–r1+carry–1*/

adds和adcs在进位时将cpsr的C标志置1；否则置0。

subs和sbcs在产生借位时将cpsr的C标志置0；否则置1。

## 3.逻辑指令：and、orr、eor和bic

### 1)AND逻辑与指令

格式：AND{}{S},,;

功能：Rd＝RnANDop2一般用于清除Rn的特定几位。

例：

ANDR0,R0,＃5;保持R0的第0位和第2位，其余位清0

### 2)ORR逻辑或指令

格式：ORR{}{S},,;

功能：Rd＝RnORop2一般用于设置Rn的特定几位。

例：

ORRR0,R0,＃5;R0的第0位和第2位设置为1，其余位不变

### 3)EOR逻辑异或指令

格式：EOR{}{S},,;

功能：Rd＝RnEORop2一般用于将Rn的特定几位取反。

例：

EORR0,R0,＃5;R0的第0位和第2位取反，其余位不变

### 4)BIC位清除指令

格式：BIC{}{S},,;

功能：Rd＝RnAND(!op2)用于清除寄存器Rn中的某些位，并把结果存放到目的寄存器Rd中

例：

BICR0,R0,＃5;R0中第0位和第2位清0，其余位不变

## 4.CMP/CMN/TST/TEQ 比较指令
```text
 ┌───────┬─┬─┬─┬───────┬─┬───────┬───────┬───────────────────────┐
 │cond   │0│0│1│opcode │S│  Rn   │x x x x│  Operand 2            │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

语法：<operation>{cond} Rn, Operand2

比较指令不指定Rd, 并且比较指令不需要指定"S",因为"S"位对比较指令是隐含使用的，比较指令的结果就是CPSR条件标志位。
<operation>
  - CMP – compare:Flags set to result of (Rn − Operand2).
  - CMN – compare negative: Flags set to result of (Rn + Operand2).
  - TST – bitwise test: Flags set to result of (Rn AND Operand2).
  - TEQ – test equivalence: Flags set to result of (Rn EOR Operand2).
```

例子：
   - "`TST R0，#5 ;测试R0中第0位和第2位是否为1`"
   - "`TST r11, #1 ;Test bit zero.`"
   - "`CMP r9, r8, ROR r0          ; Take R8 and rotate it right by R0, then compare that with R9. The result is the processor flags`"
   - CMP指令例子

      ```arm
      CMP   R0,#5    ;计算R0-5，根据结果设置条件标志位
      ADDGT R0,R0,#5 ;ADD为加法指令，GT为判断条件标志位是否大于5,如果R0>5，则执行ADD指令
      ```


#  其他指令
## 1.乘法指令

### 1)MUL/MULA 32位乘法指令

```text
multiply(32×32→32)
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬─┬─┬─┬─┬───────┐
 │cond   │0│0│0│0│0│0│A│S│  Rd   │  Rn   │  Rs   │1│0│0│1│ Rm    │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

语法：<operation>{cond}{S} Rd, Rm, Rs {,Rn}

<operation>
  - MUL – Multiply : Rd := Rm × Rs
  - MLA – Multiply with Accumulate: Rd := Rn + (Rm × Rs)
```

例子：
   - "`MULS R0,R1,R2   ;R0＝R1×R2，因为带S，所以计算结果会去影响寄存器CPSR的值`"
   - "`MLA R0,R1,R2,R3 ;R0＝R1×R2+R3`"





### 3)SMULL/SMLAL 64位有符号数乘法指令

```text
multiply long(32×32→64)
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬─┬─┬─┬─┬───────┐
 │cond   │0│0│0│0│1│U│A│S│ RdHi  │ RdLo  │  Rn   │1│0│0│1│ Rm    │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

语法：<operation>{cond}{S} RdLo, RdHi, Rm, Rs

<operation>

  - UMULL – Unsigned Multiply Long: RdHi, RdLo := Rm × Rs
  - UMLAL – Unsigned Multiply with Accumlate Long: RdHi, RdLo := RdHi,RdLo + (Rm × Rs)
  - SMULL – Signed Multiply Long: RdHi, RdLo := Rm × Rs
  - SMLAL – Signed Multiply with Accumlate Long: RdHi, RdLo := RdHi,RdLo + (Rm × Rs)
```
格式：SMULL{}{S},,,;

功能：RdhRdl＝Rn×op2Rdh、Rdl和op2均为寄存器。Rn和op2的值为32位的有符号数。

例：
  - "`SMULL R0,R1,R2,R3 ;R0＝R2×R3的低32位, R1＝R2×R3的高32位`"
  - "`SMLAL R0,R1,R2,R3 ;R0＝R2×R3的低32位+R0, R1＝R2×R3的高32位+R1`"



### 5)UMULL 64位无符号数乘法指令

格式：UMULL{}{S},,,;

功能：同SMULL指令，但指令中Rn和op2的值为32位的无符号数。

例：

UMULLR0,R1,R2,R3;R0＝R2×R3的低32位R1＝R2×R3的高32位其中R2，R3的值为无符号数

### 6)UMLAL 64位无符号数乘加指令

格式：UMLAL{}{S},,,;

功能：同SMLAL指令，但指令中Rn，op2的值为32位的无符号数，RdhRdl的值为64位无符号数。

例：

UMLALR0,R1,R2,R3;R0＝R2×R3的低32位+R0R1＝R2×R3的高32位+R1

;其中R2，R3的值为32位无符号数R1，R0的值为64位无符号数



## 2.移位指令(位运算指令)

参考[官方实例](http://www.davespace.co.uk/arm/introduction-to-arm/barrel-shifter.html)

- LSL(logical left shift) :无符号数乘2
- LSR(logical shift right)：无符号数除2
- ASR(arithmetic right shift)：除2，并保留符号位
- ROR(rotate  right)：位循环
- RRX(rotate right Extended)：位循环，从CF到MSB都参与操作

例子：
```arm
MOV r0, r0, LSL #1  ;Multiply R0 by two.
MOV r1, r1, LSR #2  ;Divide R1 by four (unsigned).
MOV r2, r2, ASR #2  ;Divide R2 by four (signed).
MOV r3, r3, ROR #16 ;Swap the top and bottom halves of R3.
ADD r4, r4, r4, LSL #4 ;Multiply R4 by 17. (N = N + N * 16)
RSB r5, r5, r5, LSL #5 ;Multiply R5 by 31. (N = N * 32 - N)
```


### 1)LSL(或ASL)左移

格式：寄存器,LSL(或ASL)操作数

功能：将寄存器内的数据左移，操作数是移位的位数在0-31之间

例:

MOVR0,R1,LSL#2；将R1中的内容左移两位后传送到R0中。

### 2)LSR操作右移

格式:寄存器LSR操作数

功能:将寄存嚣内的数据右移

例：

MOVR0,R1,LSR#2；将R1中的内容右移两位后传送到R0中，左端用零来填充。

### 3)其它移位

ASR右移，左端用第31位值来填充

ROR右移，循环右移，左端用右端移出的位来填充

RRX右移，循环右移，左端用进位标志位C来填充

## 3. ADR

ADR
This instruction adds an immediate value to the PC value to form a PC-relative address, and writes the result to the
destination register

ADR<c> <Rd>, <label>



# (二)、B/BL 跳转指令

```text
branch
                  23                                            0
 ┌───────┬─┬─┬─┬─┬───────────────────────────────────────────────┐
 │cond   │1│0│1│L|    offset                                     │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

处理器是将offset左移2位得到26位，进行符号扩展后再与PC相加，因此跳转范围是:+/- 32MB。显然如果要支持超出这个范围的长跳转，那就智能显示的对PC赋值，如采用ldr，mov。

branch,对应L为0：B{<cond>} label
branch with link，对应L为1：BL{<cond>} subroutine_label

"branch with link"同branch指令，但BL指令执行跳转操作的同时，还将PC（寄存器R15）的值(即BL 命令行的下一条指令地址)保存到LR寄存器（寄存器R14）中。该指令(branch with link)用于实现子程序调用。

```

例子：
   - "`B exit;程序跳转到标号exit处`"
   - "`BL func;调用子程序func`"

例子：
```arm
//Using BL to call a subroutine:

    ...
    ...
    BL  calc       ; call 'calc'
    ...            ; returns to here
    ...

calc               ; function body
    ADD r0, r1, r2 ; do some work here
    MOV pc, r14    ; PC = R14 to return
```

## 3)其它跳转指令

BLX带返回和状态切换的跳转指令，用于子程序调用和程序Thumb状态的切换。

BX带状态切换的跳转指令，处理器跳转到目标地址处，目标地址处的指令可以是ARM指令，也可以是Thumb指令。

跳转指令用于实现程序的跳转和程序状态的切换。

ARM程序设计中，实现程序跳转有两种方式：跳转指令、直接向程序寄存器PC中写入目标地址值。

//----------------------------------------------------------------------------------------

# (三)、程序状态指令

用于状态寄存器和通用寄存器间传送数据。总共有两条指令：MRS和MSR。两者结合可用来修改程序状态寄存器的值。

1)MRS程序状态寄存器到通用寄存器的数据传送指令

格式：MRS{},CPSR/SPSR;

功能：用于将程序状态寄存器的内容传送到目标寄存器Rd中。

例：

MRSR0,CPSR;状态寄存器CPSR的值存入寄存器R0中

2)MSR通用寄存器到程序状态寄存器的数据传送指令

格式：MSR{}CPSR/SPSR_,;

功能：用于将寄存器Rd的值传送到程序状态寄存器中。

：用来设置状态寄存器中需要操作的位。

32位的状态寄存器可以分为4个域：

位[31：24]为条件标志位域，用f表示。

位[23：16]为状态位域，用s表示。

位[15：8]为扩展位域，用x表示。

位[7：0]为控制位域，用c表示。

例：

MSRCPSR_f,R0;用R0的值修改CPSR的条件标志域

MSRCPSR_fsxc,#5;CPSR的值修改为5


MSR - Load specified fields of the CPSR or SPSR with an immediate constant, or from the contents of a general-purpose register.

     Syntax:

     MSR{cond} <psr>_<fields>, #immed_8r MSR{cond} <psr>_<fields>, Rm where: cond is an optional condition code. <psr> is either CPSR or SPSR. <fields> specifies the field or fields to be moved. <fields> can be one or more of:

c control field mask byte (PSR[7:0]) x extension field mask byte (PSR[15:8]) s status field mask byte (PSR[23:16) f flags field mask byte (PSR[31:24]). immed_8r is an expression evaluating to a numeric constant. The constant must correspond to an 8-bit pattern rotated by an even number of bits within a 32-bit word. Rm is the source register.

      C 控制域屏蔽字节(psr[7:0])
      X 扩展域屏蔽字节(psr[15:8])
      S 状态域屏蔽字节(psr[23:16])
      F 标志域屏蔽字节(psr[31:24])

常用于MRS或MSR指令,用于psr中的值转移到寄存器或把寄存器的内容加载到psr中.
如:

MSR CPSR_c，＃0xd3

# (四)、加载存储指令

该集合的指令使用频繁，当数据存放在内存中时，必须先把数据从内存装载到寄存器，执行完后再把寄存器

中的数据存储到内存中

## 1.单数据访存指令

### 1）LDR 单数据加载指令

```text
single data transfer
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────────────────────┐
 │cond   │0│1│1│P│U│B│W│L│  Rn   │  Rd   │  offset               │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

语法： <operation>{cond}{size} Rd, <address>

<operation>
   - LDR: Rd := value at <address>
   - STR: value at <address> := Rd

{size} 
   is specified to  transfer bytes or half-words:
   - <operation>B:  unsigned byte
   - <operation>SB: signed byte
   - <operation>H:  unsigned half-word
   - <operation>SH: signed half-word

<address> 
  can take multiple forms:
  - An address expression: <expression>
  - A pre-indexed address – where the address generated is used immediately:
     - [Rn, <expression>]{!}
     - [Rn, {-}Rm]{!}
     - [Rn, {-}Rm <shift> count]{!}
  - A post-indexed address – where the address generated later replaces the base register:
     - [Rn], <expression>
     - [Rn], {-}Rm
     - [Rn], {-}Rm <shift> count
注：
   - 32-bit words must be 4-byte aligned. 
   - 16-bit half-words must be 2-byte aligned.
   - Bytes – no restriction.
```

例子：
```arm
LDR r0,[r1]  ;Load word addressed by R1 into R0.
LDRB r0,[r1] ;The same as above but loads a byte.

LDR r0,[r1,#4]  ;Load word addressed by R1+4.
STR r0,[r1],#4  ;Store R0 to word addressed by R1. Increment R1 by 4.
LDR r0,[r1,#4]! ;Load word addressed by R1+4. Increment R1 by 4.
LDRLS pc,[r1,r0,LSL #2] ;Jump table idiom: load routine address into PC from R1 + R0 * 4.
```

格式：LDR(或LDRB、LDRBT、LDRH、LDRSB、LDRSH、LDRT、STR、STRB、STRBT、STRH、STRT),;

功能：内存地址中的数据装载到目标寄存器Rd中，同时还可以把合成的有效地址写回到基址寄存器。

寻址方式：Rn：基址寄存器。Rm：变址寄存器。Index：偏移量，12位的无符号数。

LDR Rd,[Rn];把内存中地址为Rn的字数据装入寄存器Rd中

LDR Rd,[Rn,Rm];将内存中地址为Rn+Rm的字数据装入寄存器Rd中

LDR Rd,[Rn,＃index];将内存中地址为Rn+index的字数据装入Rd中

LDR Rd,[Rn,Rm,LSL＃5];将内存中地址为Rn+Rm×32的字数据装入Rd

LDR Rd,[Rn,Rm]!;将内存中地址为Rn+Rm的字数据装入Rd，并将新地址Rn+Rm写入Rn

LDR Rd,[Rn,＃index]!;将内存中地址为Rn+index的字数据装入Rd，并将新地址Rn+index写入Rn

LDR Rd,[Rn,Rm，LSL＃5]!;将内存中地址为Rn+Rm×32的字数据装入Rd，并将新地址Rn+Rm×32写入Rn

LDR Rd,[Rn],Rm;将内存中地址为Rn的字数据装入寄存器Rd，并将新地址Rn+Rm写入Rn

LDR Rd,[Rn],＃index;将内存中地址为Rn的字数据装入寄存器Rd，并将新地址Rn+index写入Rn

LDR Rd,[Rn],Rm,LSL＃5;将内存中地址为Rn的字数据装入寄存器Rd，并将新地址Rn+Rm×32写入Rn

各指令的区别：

(1)LDR字数据加载指令

将内存地址中的字数据装载到目标寄存器Rd中

例：LDR R0,[R1,R2,LSL＃5]!;将内存中地址为R1+R2×32的字数据装入寄存器R0，并将新地址R1+R2×32写入R1

(2)LDRB字节数据加载指令

同LDR,只是从内存读取一个8位的字节数据而不是一个32位的字数据，并将Rd的高24位清0。

例：LDRBR0,[R1];将内存中起始地址为R1的一个字节数据装入R0中

(3)LDRBT用户模式的字节数据加载指令

同LDRB指令，但无论处理器处于何种模式，都将该指令当作一般用户模式下的内存操作。

(4)LDRH半字数据加载指令

同LDR指令，但该指令只是从内存读取一个16位的半字数据而不是一个32位的字数据，并将Rd的高16位清0。

例：LDRHR0,[R1];将内存中起始地址为R1的一个半字数据装入R0中

(5)LDRSB有符号的字节数据加载指令

同LDRB指令，但该指令将寄存器Rd的高24位设置成所装载的字节数据符号位的值。

例：LDRSBR0,[R1];将内存中起始地址为R1的一个字节数据装入R0中，R0的高24位设置成该字节数据的符号位

(6)LDRSH有符号的半字数据加载指令

同LDRH指令，但该指令将寄存器Rd的高16位设置成所装载的半字数据符号位的值。

例：LDRSHR0,[R1];将内存中起始地址为R1的一个16位半字数据装入R0中，R0的高16位设置成该半字数据的符号位

(7)LDRT用户模式的字数据加载指令

同LDR指令，但无论处理器处于何种模式，都将该指令当作一般用户模式下的内存操作。有效地址必须是字对齐的

### 2）STR 单数据存储指令

格式：STR(或STR、STRB、STRBT、STRH、STRT),;

功能：将寄存器数据写入到内存中

寻址方式：Rn：基址寄存器。Rm：变址寄存器。Index：偏移量，12位的无符号数。

STR Rd,[Rn];将寄存器Rd中的字数据写入到内存中地址为Rn内存中

STR Rd,[Rn,Rm];将寄存器Rd中的字数据写入到内存中地址为Rn+Rm的内存中

STR Rd,[Rn,＃index];将寄存器Rd中的字数据写入到内存中地址为Rn+index内存中

STR Rd,[Rn,Rm,LSL＃5];将寄存器Rd中的字数据写入到内存中地址为Rn+Rm×32内存中

STR Rd,[Rn,Rm]!;将寄存器Rd中的字数据写入到内存中地址为Rn+Rm的内存中

STR Rd,[Rn,＃index]!;将寄存器Rd中的字数据写入到内存中地址为Rn+index的内存中，并将新地址Rn+index写入Rn

STR Rd,[Rn,Rm，LSL＃5]!;将寄存器Rd中的字数据写入到内存中地址为Rn+Rm×32的内存中，并将新地址Rn+Rm×32写入Rn

STR Rd,[Rn],Rm;将寄存器Rd中的字数据写入到内存中地址为Rn的内存中，并将新地址Rn+Rm写入Rn

STR Rd,[Rn],＃index;将寄存器Rd中的字数据写入到内存中地址为Rn的内存中，并将新地址Rn+index写入Rn

STR Rd,[Rn],Rm,LSL＃5;将寄存器Rd中的字数据写入到内存中地址为Rn的内存中，并将新地址Rn+Rm×32写入Rn

(1)STR字数据存储指令

把寄存器Rd中的字数据（32位）保存到addr所表示的内存地址中，同时还可以把合成的有效地址写回到基址寄存器。

例：STR R0,[R1,＃5]!;把R0中的字数据保存到以R1+5为地址的内存中，然后R1＝R1+5

(2)STRB字节数据存储指令

把寄存器Rd中的低8位字节数据保存到addr所表示的内存地址中。

例：STRB R0,[R1];将寄存器R0中的低8位数据存入R1表示的内存地址中

(3)STRBT用户模式的字节数据存储指令

同STRB指令，但无论处理器处于何种模式，该指令都将被当作一般用户模式下的内存操作。

(4)STRH半字数据存储指令

把寄存器Rd中的低16位半字数据保存到addr所表示的内存地址中，而且addr所表示的地址必须是半字对齐的。

例：STRH R0,[R1];将寄存器R0中的低16位数据存入R1表示的内存地址中

(5)STRT用户模式的字数据存储指令

同STR指令，但无论处理器处于何种模式，该指令都将被当作一般用户模式下的内存操作。

## 2.多数据访存指令

### 1)LDM 批量数据加载指令

http://www.davespace.co.uk/arm/introduction-to-arm/stack.html

<LDM|STM>{<cond>}<address_mode> Rd{!}, <寄存器list>

格式：LDM{}{}{!},{^};

功能：从一片连续的内存单元读取数据到各个寄存器中，内存单元的起始地址为基址寄存器Rn的值，各个寄存器由寄存

器列表regs表示。

该指令一般用于多个寄存器数据的出栈。

type字段种类：

IA：每次传送后地址加1。

IB：每次传送前地址加1。

DA：每次传送后地址减1。

DB：每次传送前地址减1。

FD：push, 块存储-full descend stack。"`STMFD sp!,{r4-r7,lr}`"

ED：空递减堆栈。

FA：满递增堆栈。

EA：空递增堆栈。

堆栈寻址的命令LDMFA/STMFA、LDMEA/STMEA、LDMFD/STMFD、LDMED/STMED。

LDM和STM表示多寄存器寻址，即一次可以传送多个寄存器值。

LDM：一次装载多个，这里用来出栈。

STM：一次存储多个，这里用来入栈。

F/E表示指针指向的位置

F：full满堆栈，表示堆栈指针指向最后一个入栈的有效数据项。

E：empty空堆栈，表示堆栈指针指向下一个要放入的空地址。

A/D表示堆栈的生长方式

A：堆栈向高地址生长，即递增堆栈。

D：堆栈向低地址生长，即递减堆栈。

注意：有一个约定，编号低的寄存器在存储数据或者加载数据时对应于存储器的低地址。

FD、ED、FA和EA指定是满栈还是空栈，是升序栈还是降序栈，用于堆栈寻址。

一个满栈的栈指针指向上次写的最后一个数据单元.

空栈的栈指针指向第一个空闲单元。

一个降序栈是在内存中反向增长而升序栈在内存中正向增长。

{!}：若选用了此后缀，则当指令执行完毕后，将最后的地址写入基址寄存器。

{^}：当regs中不包含PC时，该后缀用于指示指令所用的寄存器为用户模式下的寄存器，

否则指示指令执行时，将寄存器SPSR的值到CPSR中。

### 2)STM 批量数据存储指令

格式：STM{}{}{!},{^};

功能：将各个寄存器的值存入一片连续的内存单元中，内存单元的起始地址为基址寄存器Rn的值

各个寄存器由寄存器列表regs表示。该指令一般用于多个寄存器数据的入栈。

{^}：指示指令所用的寄存器为用户模式下的寄存器。其他参数用法同LDM指令。

例：STMEAR13!,{R0-R12,PC};将寄存器R0~R12以及程序计数器PC的值保存到R13指示的堆栈中

## 3.数据交换指令

### 1)SWP 字/字节 数据交换指令

```text
single data swap
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┐
 │cond   │0│0│0│1│0│B│0│0│  Rn   │  Rd   │0│0│0│0│1│0│0│1│  Rm   │
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

字交换,对应B为0：SWP{<cond>} <Rd>, <Rm>, [<Rn>]
字节交换，对应B为1：SWP{<cond>}B <Rd>, <Rm>, [<Rn>]

- Rd: 确定指令的目标寄存器。
- Rm: 该寄存器包含将要被存储到内存单元中的数据。
- Rn: 内存单元地址寄存器。
```

例子：
   - "`SWP r1，r1，［r0］;@将r1的内容与r0指向的存储单元的内容进行交换。`"
   - "`SWP r0, r1, [r2] ;@将R2所表示的内存单元中的字数据装载到R0，然后将R1中的字数据保存到R2所表示的内存单元中`"
   - "`SWPB R0, R1,[R2] ;@将R2所表示的内存单元中的一个字节数据装载到R0的低8位，然后将R1中的低8位字节数据保存到R2所表示的内存单元中`"


# (五)、协处理指令

ARM支持16个协处理器。有三种协处理器指令：

- Initiate a coprocessor data-processing operation. 
   - CDP, CDP2 on page A8-356.

- Transfer ARM core registers to and from coprocessor registers. For details, see:
   - MCR, MCR2 on page A8-477.协处理器寄存器->ARM寄存器
   - MCRR, MCRR2 on page A8-479.
   - MRC, MRC2 on page A8-493.ARM寄存器->协处理器寄存器
   - MRRC, MRRC2 on page A8-495.

- Load or store the values of coprocessor registers. For details, see:
   - LDC, LDC2 (immediate) on page A8-393.存储器->协处理器寄存器
   - LDC, LDC2 (literal) on page A8-395.
   - STC, STC2 on page A8-663.协处理器寄存器->存储器

coprocessor data transfer
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬───────────────┐
 │cond   │1│1│0│P│U│N│W│L│  Rn   │  CRd  │ CP#   │   offset      │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
coprocessor data operaton
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬─────┬─┬───────┐
 │cond   │1│1│1│0│CP  Opc│  CRn  │  CRd  │ CP#   │CP   │0│ CRm   │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
coprocessor data Register transfer
 ┌───────┬─┬─┬─┬─┬─┬─┬─┬─┬───────┬───────┬───────┬─────┬─┬───────┐
 │cond   │1│1│1│0│CPOpc|L│  CRn  │  Rd   │ CP#   │CP   │1│ CRm   │ 
 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘


## 1)CDP协处理器操作指令

Coprocessor Data Processing tells a coprocessor to perform an operation that is independent of ARM core registers
and memory. If no coprocessor can execute the instruction, an Undefined Instruction exception is generated.
This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and
are free for use by the coprocessor instruction set designer. These are the opc1, opc2, CRd, CRn, and CRm fields.
However, coprocessors CP8-CP15 are reserved for use by ARM, and this manual defines the valid CDP and CDP2
instructions when coproc is in the range p8-p15. For more information see Coprocessor support on page A2-93 and
General behavior of system control registers on page B5-1768

A8.8.30
格式：CDP<cond> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2>

coproc: 0~7是提供给vendor使用，其他都是被arm reserve，具体情况如下：

   - Coprocessor 15 (CP15) provides system control functionality. This includes architecture and feature identification, as well as control, status information and configuration support.
   - Coprocessor 14 (CP14) supports debug, The Thumb Execution Environment,Direct Java bytecode execution
   - Coprocessors 10 and 11 (CP10 and CP11) together support floating-point and vector operations, and the control and configuration of the Floating-point and Advanced SIMD architecture extensions.
   - Coprocessors 8, 9, 12, and 13 are reserved for future use by ARM. Any coprocessor access instruction. attempting to access one of these coprocessors is UNDEFINED.


功能：用于传递指令给协处理器p，要求其在寄存器CRn和CRm上，进行操作opcode1，并把结果存放到CRd中，

可以使用opcode2提供与操作有关的补充信息。指令中的所有寄存器均为协处理器的寄存器，操作由协处理器完成。

指令中:

P为协处理器编号；

CRd为目的寄存器的协处理器寄存器；

CRm和CRn为存放操作数的协处理器寄存器；

Opcode1和opcode2为协处理器即将执行的操作。

例：CDPp5，5，c0，c1，c2，9；该指令用于通知协处理器p5，在c1和c2上执行操作5和9，并将结果存放到c0中。

2)LDC协处理器数据读取指令

格式：LDC{}{L}

,,;

功能：将addr表示的内存地址中的连续数据传送到目的寄存器CRd中。

L表示指令为长读取操作，比如用于双精度数据的传输；

目的寄存器CRd为协处理器的寄存器；

addr的寻址方式同LDR指令，其寄存器为ARM处理器的寄存器。

例：LDCp5，c1，[R1+5]:该指令用于将R1＋5所对应的存储单元中的数据，传送到协处理器p5的寄存器c1中。

3)STC协处理器数据存储指令

格式：STC{}{L}

,,;

功能：将寄存器CRd的值传送到addr表示的内存地址中。指令中各参数用法同LDC。

例如：STCp5，c1，[R1+5];该指令用于将协处理器p5中寄存器c1的数据传送到R1＋5所对应的存储单元中。

4)MCRARM寄存器到协处理器寄存器的数据传送指令

格式：MCR{}

,,,,{,op2};

功能：将ARM处理器的寄存器Rd中的数据传送到协处理器p的寄存器CRn，CRm中；op1，op2为协处理器将要执行的操作。

例：MCRp5,5,R1,C1,C2,9；该指令将R1中的数据传送到协处理器p5的寄存器C1，C2中，协处理器执行操作5和9。

MRC协处理器寄存器到ARM寄存器的数据传送指令

格式：MRC{}

,,,,{,op2};

功能：将协处理器p的寄存器CRn，CRm的数据传送到ARM处理器的寄存器Rd中；op1，op2为协处理器将要执行的操作。

例：MRCp5,5,R1,C1,C2,9；该指令将寄存器C1，C2中的数据传送到R1中，协处理器p5协处理器执行操作5和9。

# (六)、异常中断指令

异常中断产生指令：用于系统调用和调试。

1)SWI软件中断指令

格式：SWI{}24位的立即数；

功能：用于产生软件中断，以使用户程序调用操作系统的系统例程。

指令中24位的立即数指定用户程序调用系统例程的类型，其参数通过通用寄存器传递。当24位的立即数

被忽略时，系统例程类型由寄存器R0指定，其参数通过其他通用寄存器传递。

例：SWI0X05;调用编号为05的系统例程。

2)BKPT断点中断指令

格式：BKPT16位的立即数；

功能：用于产生软件断点中断，以便软件调试时使用。16位的立即数用于保存软件调试中额外的断点信息。

指令操作的伪代码：

# (七)、信号量操作指令

信号量操作指令：用于进程间的同步互斥，提供对信号量的原子操作。

# (八)、ARM程序常见结构

1.子函数和主函数

使用BL指令进行调用，该指令会把返回的PC值保存在LR

AREAExample,CODE,READONLY;声明代码段Example

ENTRY;程序入口

Start

MOVR0,#0;设置实参,将传递给子程骗子的实参存放在r0和r1内

MOVR1,#10

BLADD_SUM;调用子程序ADD_SUM

BOVER;跳转到OVER标号处，进入结尾

ADD_SUM

ADDR0,R0,R1;实现两数相加

MOVPC,LR;子程序返回，R0内为返回的结果

OVER

END

运行过程

(1)程序从ENTRY后面指令处开始运行(即主函数)

R0和R1先准备好数据令子函数运算时使用

(2)BL为跳转指令，用于调用子函数后面为函数标号。

在调用函数的过程中，自动将PC内的值保存到LR(R14)内备份，PC内当前的值为下一条要执行的指令地址

（即BOVER指令地址），在子函数结束前将该地址恢复到PC内

(3)B为跳转指令，用于跳转到指定的标号后,此处跳转到程序结尾

(4)MOVPC,LR是子函数内的最后一条语句，用于将LR内保存的地址恢复到PC内

PC(R15)程序计数器存储要执行的指令在内存中的地址

PC的值=当前正在执行指令在内存中的地址+8

2.条件跳转语句

AREAExample,CODE,READONLY;声明代码段Example

ENTRY;程序入口

Start

MOVR0,#2;将R0赋初值2

MOVR1,#5;将R1赋初值5

ADDR5,R0,R1;将R0和R1内的值相加并存入R5

CMPR5,#10

BEQDOEQUAL;若R5为10，则跳转到DOEQUAL标签处

WAIT

CMPR0,R1

ADDHIR2,R0,#10;若R0>R1则R2=R0+10

ADDLSR2,R1,#5;若R1<=R2则R2=R1+5

DOEQUAL

ANDSR1,R1,#0x80;R1=R1&0x80,并设置相应标志位

BNEWAIT;若R1的d7位为1则跳转到WAIT标签

OVER

END

运行过程

(1)程序从ENTRY后面指令处开始运行(即主函数)

R0和R1赋初值2和5

将R0与R1相加后存入R5内

(2)CMP用于比较两个数据，指令格式如下：

CMP操作数1,操作数2

CMP用于把一个寄存器的内容和另一个寄存器或立即数进行比较，同时

更新CPSR中条件标志位的值。标志位表示操作数1和操作数2的关系。然后执行后面的语句

(3)条件助记符

BEQB为跳转指令，EQ为条件相等，读取CPSR内的条件标志位，如相等则跳转到所指定的标号处

BNEB为跳转指令，NE为不相等（0），如不相等则跳转到所指定的标号处

ADDHIADD为相加指令，HI为无符号大于，如大于则执行相加

ADDLSADD为相加指令，LS为无符号小于或等于，如小于或等于则相加

(4)位运算

ANDSAND按位与，0x80取出第7位，S为将该位与的值写入标志位

3.循环语句

AREAExample,CODE,READONLY;声明代码段Example

ENTRY;程序入口

Start

MOVR1,#0;将R1赋初值0

LOOP

ADDR1,R1,#1

CMPR1,#10

BCCLOOP;R1小于10则执行跳转到LOOP处执行循环，即R1从0到10后退出循环

END

例：编写一具有完整汇编格式的程序，实现冒泡法排序功能。

设无符号字数据存放在从0x400004开始的区域，字数据的数目字存放在0x400000中。

AREASORT，CODE，READONLY

ENTRY

START

MOV R1，#0x400000

LP

SUBS R1，R1，#1

BEQ EXIT

MOV R7，R1

LDR R0，=0x400004

LP1

LDR R2，[R0]，#4

LDR R3，[R0]

CMP R2，R3

STRLOR3，[R0,#-4]

STRLOR2，[R0]

SUBS R7，R7，#1

BNE LP1

B LP

EXIT

END

