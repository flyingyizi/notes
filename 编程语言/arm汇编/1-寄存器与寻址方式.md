
# ARM 寄存器

[官方document](http://www.davespace.co.uk/arm/introduction-to-arm/registers.html)

ARM寄存器分为2类：普通寄存器和状态寄存器

## 普通寄存器

(1)通用寄存器和计数器：共32个，15个通用寄存器

### R0-R7未备份寄存器 :

	R0(a1),R1(a1),R2(a3),R3(a4),R4(v1),R5(v2),R6(v3),R7(WR,v4)

### R8-R12备份寄存器:

	R8(v5),R9(SB,v6),R10(SL,v7,)R11(FP,v8),R12(IP)数据寄存器


### R15(PC)程序计数器:

	它的值是当前正在执行的指令在内存中的位置。当指令执行结束后，CPU会自动将PC值加上一个单位，PC值指向下一条即将执行的指令的地址
	如果通过汇编指令对PC寄存器赋值，就会完成一次程序的跳转（如从子函数跳转回主函数内）

### R14(LR)链接寄存器:

	存放子程序的返回地址. 例如：在主函数内，如果调用子函数，程序会进入到子函数内执行。当子函数执行
	完毕后，需要回到主函数内，所以，在子函数调用前需要将这个地址先保存起来，否则无法找到这个地址。

	LR用于保存这个地址，这个地址也称为子程序返回地址。当子函数结束后，再将LR内的地址赋给PC即可。

	如果子程序再调用孙程序，LR如何保存地址呢？先把当前LR内的值压入内存的栈区，然后LR再保存孙程
	序的返回地址。当孙程序执行完后通过PC跳转到

	子程序内，此时将栈区内的子程序返回地址取出保存在LR内。当子程序执行完后，再通过PC跳转到主函数内。

### R13(SP)栈指针寄存器:

	用于存放堆栈的栈顶地址。SP相当于指针变量，保存的是栈顶的地址，出栈时，从SP指向的内存中取出数据，
	入栈时将新的内存地址压入栈顶，而SP相当于链表的头指针(head)。

原则上说R0-R12可以保存任何数据。其中R0-R7用来临时存储数据，R8-R12系统没有用来做任何特殊用途，常用于中断

而在汇编与C语言的交互中，定制了ATPCS标准:

   - 寄存器：R4-R11用来保存局部变量
   - 参数：参数小于等于4，用R0-R3保存参数，参数多于4，剩余的传入堆栈
   - 函数返回：结果为32位整数，通过R0返回.结果为64位整数，通过R0，R1返回.对于位数更多的结果，通过内存传递


## 状态寄存器:

状态寄存器用于保存程序的当前状态

CPSR当前程序状态寄存器

一个寄存器为32位，每一位数据代表不同的状态。分为三个部分(条件代码标志位、控制位、保留区位)

![CPSR寄存器详解](https://img-blog.csdn.net/20180427165727925)


条件码标志

N、Z、C、V，最高4位称为条件码标志。ARM的大多数指令可以条件执行的，即通过检测这些条件码标志来决定程序指令如何执行。

各个条件码的含义如下：

- N：在结果是有符号的二进制补码情况下，如果结果为负数，则N=1；如果结果为非负数，则N=0。

- Z：如果结果为0，则Z=1;如果结果为非零，则Z=0。

- C：其设置分一下几种情况：

    - 对于加法指令（包含比较指令CMN），如果产生进位，则C=1;否则C=0。

    - 对于减法指令（包括比较指令CMP），如果产生借位，则C=0;否则C=1。

    - 对于有移位操作的非法指令，C为移位操作中最后移出位的值。

    - 对于其他指令，C通常不变。

- V：对于加减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V=1;如果无溢出发生，则V=0;对于其他指令，V通常不发生变化。

# ARM的寻址方式


寻址方式：是根据指令中给出的地址码字段来实现寻找真实操作数地址的方式,共8种寻址方式：

寄存器寻址、立即寻址、寄存器间接寻址、基址寻址、多寄存器寻址、堆栈寻址、相对寻址、寄存器移位寻址


## 1.立即寻址

操作数是常量，用#表示立即数。对立即数前缀是"0x"或"&"表示16进制数否则表示十进制数

例

   - "`MOV R0,#0xFF000 ;指令省略了第1个操作数寄存器。将立即数0xFF000(第2操作数)装入R0寄存器`"
   - "`SUB R0,R0,#64   ;R0减64，结果放入R0`"

立即数由32位机器码中低位的12位存放。这引发一个问题：32位的数据（long或float）如何存储？


32位的数据以一种特殊的方式来处理：
  
   - 其中：高4位表示的无符号整数
   - 低8位补0扩展为32位，然后循环右移x位来代表一个数。x=高4位整数*2

所以，不是每一个32位数都是合法的立即数，只有能通过上述构造得到的才是合法的立好数。如：

合法立即数：0xff,0x104,0xff0

不合法立即数：ox101，0x102,0xff1

## 2.寄存器寻址

操作数的值在寄存器中，指令执行时直接取出寄存器值来操作

例：

   - "`MOV R1,R2 ;将R2的值存入R1在第1个操作数寄存器的位置存放R2编码`"
   - "`SUB R0,R1,R2;将R1的值减去R2的值，结果保存到R0在第2操作数位置，存放的是寄存器R2的编码`"


## 3.寄存器间接寻址

操作数从寄存器所指向的内存中取出，寄存地存储的是内存地址

例：

   - "`LDRR1,[R2];将R2指向的存储单元的数据读出，保存在R1中R2相当于指针变量`"
   - "`STRR1,[R2];将R1的值写入到R2所指向的内存`"
   - "`SWPR1,R1,[R2];将寄存器R1的值和R2指定的存储单元的内容交换`"

"[R2]"表示寄存器所指向的内存，相当于*p

"LDR"指令用于读取内存数据, "STR"指令用于写入内存数据


## 4.寄存器基址寻址

操作数从内存址偏移后读取数据。常用于查表、数组操作、功能部件寄存器访问等。

基址：相当于首地址，地址偏移后取值作为操作数

基址寄存器：用来存放基址的寄存器

变址寻址：基址寻址也称为变址寻址

1)前索引寻址

例：

   - "`LDR R2,[R3,#4];读取R3+4地址上的存储单元的内容，放入R2`"
   - "`LDRR2,[R3,#4]!;读取R3+4地址上的存储单元的内容，放入R2，然后R3内的地址变为R3+4,即R3=R3+4`"

    [R3,#4]表示地址偏移后取值，相当于*(p+4)或p[4]，R3内保存的地址不变

    [R3,#4]!表示地址偏移后取值，相当于*(p+4)或p[4],!表示回写，即R3=R3-4,R3的值发生了改变

2)后索引寻址

例：

   - "`LDR R2,[R3],#4;先读取R3地址上的存储单元的内容，放入R2，然后R3内的地址变为R3+4,即R3=R3+4`"

	[R3],#4类似于*p++只不过自加的不是1，而是指定的4

	[R3,#4]!类似于*++p只不过自加的不是1，而是指定的4

3)寄存器的值作索引

例：

   - "`LDRR2,[R3,R0];R0内存储索引值，R3内存地址，读取R3+R0地址上的存储单元的内容，放入R2`"

	[R3,R0]表示地址偏移后取值，相当于*(p+i)或p[i]

## 5.多寄存器寻址

一次可传送多个寄存器的值，也称为块拷贝寻址

例：LDMIAR1!,{R2-R7,R12};将R1指向的存储单元中的数据读写到R2～R7、R12中，然后R1自加1

STMIAR1!,{R2-R7,R12};将寄存器R2～R7、R12的值保存到R1指向的存储单元中，然后R1自加1

其中R1是基址寄存器，用来存基址，R2-R7、R12用来存数据赋值编号小的寄存器与低地址相对应，与寄存器列表顺序无关

!为可选后缀，表示改变R1的值，则当数据传送完毕之后，将最后的地址写入基址寄存器

基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。

这里R1没有写成[R1]!，是因为这个位不是操作数位，而是寄存器位

LDMIA和STMIA是块拷贝指令,LDMIA是从R1所指向的内存中读数据，STMIA是向R1所指向的内存写入数据

R1指向的是连续地址空间

## 6.寄存器堆栈寻址

是按特定顺序存取存储区，按后进先出原则，使用专门的寄存器SP（堆栈指针)指向一块存储区

例：LDMIASP!,{R2-R7,R12};将栈内的数据，读写到R2～R7、R12中，然后下一个地址成为栈顶

STMIASP!,{R2-R7,R12};将寄存器R2～R7、R12的值保存到SP指向的栈中

SP指向的是栈顶

## 7.相对寻址

即读取指令本身在内存中的地址。是相对于PC内指令地址偏移后的地址。

由程序计数器PC提供基准地址，指令中的地址码字段作为偏移量，两者相加后得到的地址即为操作数的有效地址。

例：

BLOOP;B指令用于跳转到标号LOOP指令处执行代码

...

LOOP

MOVR6#1

其中LOOP仅仅是标号，而不是地址，不是CPU指令，所以在指令的机器码中没有标号的机器码，而是

计算出了从B指令到MOV指令之间内存地址的差值，这个差值相当于PC的偏移量，即相当于：addpc,pc,#偏移量

B指令引起了PC寄存器值的变化，PC内永远保存将要运行指令在内存中的地址。

## 8.寄存器移位寻址

操作数在被使用前进行移位运算

例：MOVR0,R2,LSL#3;R2的值左移3位，结果放入R0，;即是R0=R2×8

LSL是移位指令，用于将前面寄存器的数据左移


## arm 协处理器mcr/mrc指令说明

参见 [proc info的获取](https://blog.csdn.net/ooonebook/article/details/52791202)

MCR 指令：ARM寄存器到协处理器寄存器的数据传送：
   ```asm
   MCR{<cond>} <p>，<opcode_1>，<Rd>,<CRn>,<CRm>{,<opcode_2>}
   MCR{<cond>} p15，
   ```
MRC指令： 协处理器寄存器到ARM寄存器的数据传送:
   ```asm
   MRC{<cond>} <p>，<opcode_1>，<Rd>,<CRn>,<CRm>{,<opcode_2>}
   MRC{<cond>} p15，
   ```

参数说明：

- cond: 为指令执行的条件码。当忽略时指令为无条件执行。
- opcode_1: 为协处理器将执行的操作的操作码。对于CP15协处理器来说，< opcode_1>永远为0b000，当< opcode_1>不为0b000时，该指令操作结果不可预知。
- Rd:  作为源寄存器的ARM寄存器，其值将被传送到协处理器寄存器中。
- CRn: 作为目标寄存器的协处理器寄存器，其编号可能是C0，C1，…，C15。
- CRm和opcode_2: 两者组合决定对协处理器寄存器进行所需要的操作，如果没有指定，则将为为C0，opcode_2为0，否则可能导致不可预知的结果。

## 移位指令

移位指令：LSL,ASL,LSR,ASR,ROR,RRX

ARM 处理器组建了可以与数据处理指令(ADC、ADD、AND、BIC、CMN、CMP、EOR、MOV、MVN、ORR、RSB、SBC、SUB、TEQ、TST)一
起使用的桶式移位器(barrel shifter)。你还可以使用桶式移位器影响在 LDR/STR 操作中的变址值。

注意：

	移位操作在 ARM 指令集中不作为单独的指令使用，它是指令格式中是一个字段，在汇编语言中表示为指令中的选项。
	如果数据处理指令的第二个操作数或者单一数据传送指令中的变址是寄存器，则可以对它进行各种移位操作。
	如果数据处理指令的第二个操作数是立即值，在指令中用 8 位立即值和 4 位循环移位来表示它，所以对大于 255 的
	立即值，汇编器尝试通过在指令中设置循环移位数量来表示它，如果不能表示则生成一个错误。
	
	在逻辑类指令中，逻辑运算指令由指令中 S 位的设置或清除来确定是否影响进位标志，而比较指令的 S 位总是设置的。
	在单一数据传送指令中指定移位的数量只能用立即值而不能用寄存器。


下面是给不同的移位类型的六个助记符:
- LSL 逻辑左移 ，与ASL等效
- ASL 算术左移 
- LSR 逻辑右移 
- ASR 算术右移 
- ROR 循环右移 
- RRX 带扩展的循环右移

你可以用一个立即值(从 0 到 31)指定移位数量，或用包含在 0 和 31 之间的一个值的寄存器指定移位数量。
逻辑或算术左移

(Logical or Arithmetic Shift Left)
	
	"`Rx, LSL #n or Rx, ASL #n or Rx, LSL Rn or Rx, ASL Rn`"
	接受 Rx 的内容并按用‘n’或在寄存器 Rn 中指定的数量向高有效位方向移位。最低有效位用零来填充。
	除了概念上的第 33 位(就是被移出的最小的那位)之外丢弃移出最左端的高位，如果逻辑类指令中 S 位
	被设置了，则此位将成为从桶式移位器退出时进位标志的值。

	例子："`MOV R1, #12 MOV R0, R1, LSL#2 @ R0 = 12 << 2`"

(Logical Shift Right)

	"`Rx, LSR #n`" or "`Rx, LSR Rn`"
	它在概念上与左移相对。把所有位向更低有效位方向移动。如果逻辑类指令中 S 位被设置了，则把最后被移
	出最右端的那位放置到进位标志中。它同于 BASIC 的 register = value >>> shift。

(Arithmetic Shift Right)
	"`Rx, ASR #n or Rx, ASR Rn`"
	类似于 LSR，但使用要被移位的寄存器(Rx)的第 31 位的值来填充高位，用来保护补码表示中的符号。如果逻辑类指
	令中 S 位被设置了，则把最后被移出最右端的那位放置到进位标志中。它同于 BASIC 的 register = value >> shift。

循环右移(Rotate Right)
	"`Rx, ROR #n or Rx, ROR Rn`"
	循环右移类似于逻辑右移，但是把从右侧移出去的位放置到左侧，如果逻辑类指令中 S 位被设置了，则同时放
	置到进位标志中，这就是位的‘循环’。一个移位量为 32 的操作将导致输出与输入完全一致，因为所有位都被移
	位了 32 个位置，又回到了开始时的位置!

带扩展的循环右移(Rotate Right with extend)
	"`Rx, RRX`"
	这是一个 ROR#0 操作，它向右移动一个位置 - 不同之处是，它使用处理器的进位标志来提供一个要被移位的 33 位的数量。

