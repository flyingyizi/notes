

[官方文档](https://docs.espressif.com/projects/esp8266-rtos-sdk/en/latest/get-started/index.html)

[ESP8266_NONOS_SDK All documentations](http://espressif.com/en/support/download/documents?keys=&field_type_tid%5B%5D=14)

[esp8266 NONOS SDK ESP8266 SDK 入门指南.](https://www.espressif.com/sites/default/files/documentation/2a-esp8266-sdk_getting_started_guide_cn.pdf)

注意： ESP8266 默认的波特率 74880，因此如果没有重新设置波特率，需要esp8266通信要采用该值。否则会乱码。

# install

## 方式0：
完全步骤： [Windows下用 Visual Studio Code开发 esp8266](https://blog.csdn.net/xh870189248/article/details/81382279)

注意esp8266 sdk仅仅支持mingw32，不支持mingw64.

总结来说就是：

- From this terminal, install the required tools:
```shell

# Update package mirrors (may be needed if you have a fresh install of MSYS2)
$ pacman -Sy pacman-mirrors

# Install build tools needed for Rust. If you're building a 32-bit compiler,
# then replace "x86_64" below with "i686". If you've already got git, python,
# or CMake installed and in PATH you can remove them from this list. Note
# that it is important that you do **not** use the 'python2', 'cmake' and 'ninja'
# packages from the 'msys2' subsystem. The build has historically been known
# to fail with these packages.
$ pacman -S git \
            make \
            diffutils \
            tar \
            tettext mingw-w64-i686-python mingw32/mingw-w64-i686-python-pip \
            mingw32/mingw-w64-i686-cmake mingw32/mingw-w64-i686-gcc mingw32/mingw-w64-i686-ninja
```

- 首先下载[msys2预置环境](https://dl.espressif.cn/dl/esp32_win32_msys2_environment_and_toolchain-20181001.zip)，即使本地环境历史已经有msys2，也建议重新下载该msys，因为在实践中碰到过莫名其妙的问题。
- 然后下载[esp8266 toolchain](https://dl.espressif.com/dl/xtensa-lx106-elf-gcc8_4_0-esp-2020r3-win32.zip), 假设放置目录为"/opt/xtensa-esp32-elf"
- 然后下载[esp8266 sdk](ESP8266_RTOS_SDK), 下载方式是如下面示意。假设放置目录为"/opt/ESP8266_RTOS_SDK"

```shell
$git clone --recursive https://github.com/espressif/ESP8266_RTOS_SDK.git
$git submodule update --init --recursive
```

- 更新"/etc/profile.d/esp32_toolchain.sh"文件内容为如下内容：
```sh
export PATH="$PATH:/opt/xtensa-lx106-elf/bin:/opt/ESP8266_RTOS_SDK/tools"
export IDF_PATH="D:/prog/esp8266/msys32/opt/ESP8266_RTOS_SDK"
```

最后 通过demo验证："`/opt/ESP8266_RTOS_SDK/examples/get-started/hello_world $ make`". 相比采用make，采用idf.py

在实际操作过程中可能会出现类似python缺少模块的问题,缺少那些安装那些即可，例如下面的例子:
```shell
$ python -m pip install --upgrade --force-reinstall pip
$ pip install click==?
$ pip install click
$ pip install pyelftools
$ make menuconfig
$ make
$ history
```


## 方式1（已实践）： Developing With the ESP8266_RTOS_SDK

信息来源：[Developing With the ESP8266_RTOS_SDK](https://github.com/espressif/ESP8266_RTOS_SDK#developing-with-the-esp8266_rtos_sdk)
- [下载toolchain](https://dl.espressif.com/dl/xtensa-lx106-elf-gcc8_4_0-esp-2020r3-win32.zip). 最后解压放在某个目录，例如放在“\Espressif\tools\xtensa-lx106-elf”
  
- [下载SDK](git clone --recursive https://github.com/espressif/ESP8266_RTOS_SDK.git)， 例如位置是"Espressif\frameworks\ESP8266_RTOS_SDK"。 注意拉取各个子模块"git submodule update --init --recursive"

The toolchain programs access ESP8266_RTOS_SDK using IDF_PATH environment variable.

如果使用vscode，在vscode 项目的settings.json中增加CMAKE_TOOLCHAIN_FILE的定义
```json
    "cmake.configureSettings": {
        "CMAKE_TOOLCHAIN_FILE": "D:\\prog\\Espressif\\frameworks\\ESP8266_RTOS_SDK\\tools\\cmake\\project.cmake",
    },
```

另外，cmake active kit选择Xtensa lx106 Toolchain，如果没有这个可以选择scan来扫描；

windows下（非msys2 环境）步骤汇总：

- 预先安装python， 将python放入PATH，例如“D:\prog\Python\Python37\”
- 预先安装msys2 ，并在其中安装gcc。 gcc需要纳入PATH
- 见前面说明,下载toolchain，下载sdk
- 设置IDF_PATH， 例如“d:\prog\esp8266\frameworks\ESP8266_RTOS_SDK”， 注意在windows（非msys2 环境）下不要设置为msys2路径格式，
- D:\prog\esp8266\tools\xtensa-lx106-elf\bin, cmake， msys2-gcc 包含在PATH中。
- 执行"${IDF_PATH}\tools\idf.py" 进行build，flash等。 前面为vscode设置的settings.json，用它来在vscode下进行编译是没有问题，但其他就不行了。

## 方式2： 关于ESP8266的安信可编译环境搭建流程

[关于ESP8266的安信可编译环境搭建流程](https://blog.csdn.net/qq_43680331/article/details/123622676)


## 最小系统

最小系统搭建（强调：烧录时候，一定要让GPIO0处于低电平，即接GND）

![esp8266最小系统](https://imgconvert.csdnimg.cn/aHR0cDovL2g1eHVob25nLm9zcy1jbi1ob25na29uZy5hbGl5dW5jcy5jb20vODI2NiVFNSU5QiVCRSVFNyU4OSU4Ny8lRTYlOUMlODAlRTUlQjAlOEYlRTclQjMlQkIlRTclQkIlOUYucG5n)

即：
- EN: 上拉
- 3V3： 3.3V供电
- IO15：下拉
- ID0： 下拉时为uart下载模式，悬空或上拉时为flash启动模式
- RXD： 对应uart下载模式的接收端
- TXD： 对应uart下载模式的发送端，因此uart下载模式时应悬空或上拉

ESP8266常见开发板的布局：

![ESP8266常见开发板的布局](https://img-blog.csdnimg.cn/20201210210025921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjMzMjYy,size_16,color_FFFFFF,t_70)

|pin|  | name      |type |  function    |
|---|--|-----------|-----|--------------|
|8 | D0  | XPD_DCDC    |I/O  |Deep-sleep wakeup (need to be connected to EXT_RSTB);GPIO16|
|9 | D5  | MTMS        | I/O | GPIO 14; HSPI_CLK|
|10| D6  | MTDI        | I/O | GPIO 12; HSPI_MISO|
|12| D7  | MTCK        |I/O  | GPIO 13; HSPI_MOSI; UART0_CTS|
|13| D8  | MTDO        |I/O  | GPIO 15; HSPI_CS; UART0_RTS|
|14| D4  | GPIO2       | I/O | UART TX during flash programming; GPIO2|
|15| D3  | GPIO0       | I/O | GPIO0; SPI_CS2|
|16| D2  | GPIO4       | I/O | GPIO4|
|18| SD2 | SDIO_DATA_2 | I/O | Connect to SD_D2 (Series R: 20 Ω); SPIHD; HSPIHD; GPIO9|
|19| SD3 | SDIO_DATA_3 | I/O | Connect to SD_D3 (Series R: 200 Ω); SPIWP; HSPIWP; GPIO10|
|20|     | SDIO_CMD    |I/O | Connect to SD_CMD (Series R: 200 Ω); SPI_CS0; GPIO11|
|21|     | SDIO_CLK    |I/O | Connect to SD_CLK (Series R: 200 Ω); SPI_CLK; GPIO6|
|22|     | SDIO_DATA_0 |I/O | Connect to SD_D0 (Series R: 200 Ω); SPI_MISO; GPIO7|
|23|     | SDIO_DATA_1 |I/O | Connect to SD_D1 (Series R: 200 Ω); SPI_MOSI; GPIO8|
|24| D1  | GPIO5       |I/O | GPIO5|
|25| D9  | U0RXD       |I/O | UART Rx during flash programming; GPIO3|
|26| D10 | U0TXD       |I/O | UART TX during flash programming; GPIO1; SPI_CS1|



# esp8266 要点记录

esp8266 12f 是基于esp8266ex mcu销售的模块。根据[esp-12f_规格书.pdf](https://docs.ai-thinker.com/_media/esp8266/docs/esp-12f_%E8%A7%84%E6%A0%BC%E4%B9%A6.pdf),得知该模块的外围模块是26MHz时钟源。同时我们查看esp8266-hal源代码也可以知道，该hal的“ESP8266Reset”使用了“`set_crystal_frequency(CrystalFrequency::Crystal26MHz);`”，与esp-12f硬件是对应的。

[es8266 datasheet](https://www.espressif.com.cn/sites/default/files/documentation/0a-esp8266ex_datasheet_en.pdf)



By default, UART0 outputs some printed information when the device is powered on and booting up. The
baud rate of the printed information is relevant to the frequency of the external crystal oscillator. If the frequency of the crystal oscillator is 40 MHz, then the baud rate for printing is 115200; if the frequency of the crystal oscillator is 26 MHz, then the baud rate for printing is 74880. If the printed information exerts any influence on the functionality of the device, it is suggested to block the printing during the power-on period by changing (U0TXD, U0RXD) to (MTDO, MTCK).

