

[A Primer on Bézier Curves](https://pomax.github.io/bezierinfo/index.html)

# algebra

## 1.3 THE DOT PRODUCT

在数学中，点积（德语：Skalarprodukt、英语：Dot Product）又称数量积或标量积（德语：Skalarprodukt、英语：Scalar Product），是一种接受两个等长的数字序列（通常是坐标向量）、返回单个数字的代数运算。在欧几里得几何中，两个笛卡尔坐标向量的点积常称为内积（德语：inneres Produkt、英语：Inner Product），见内积空间。

代数定义：两个向量 $\vec{a} = [a1, a2,…, an]$和 $\vec{b} = [b1, b2,…, bn]$的点积定义为：

$$\vec{a}\cdot \vec{b} = \sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \cdots + a_nb_n$$
这里的Σ是求和符号，而n是向量空间的维数。

几何定义：在欧几里得空间中，点积可以直观地定义为

$$\vec{a} \cdot \vec{b} = |\vec{a}| , |\vec{b}| \cos \theta ;$$

这里 $|\vec{x}|$ 表示 $\vec{x}$的模（长度）， $\theta$ 表示两个向量之间的角度。



The dot product is a form of vector multiplication that results in a scalar value; for this
reason, it is sometimes referred to as the scalar product. Let $u = (u_x, u_y, u_z)$ and $v = (v_x, v_y,v_z)$, then the dot product is defined as follows:

$$u \cdot v = u_{x}v_{x} +u_{y}v_{y} +u_{z}v_{z}$$

点积可以用来求两个向量之间的夹角，因为$u \cdot v=||u||||v||cos(\theta)$

## 1.4 THE CROSS PRODUCT

在数学和向量代数领域，叉积（英语：Cross product）又称向量积（英语：Vector product），是对三维空间中的两个向量的二元运算，使用符号 $\times$。与点积不同，它的运算结果是向量。对于线性无关的两个向量 $\mathbf {a}$ 和 $\mathbf {b}$ ，它们的叉积写作 ${\mathbf {a} \times \mathbf {b} }$，是 $\mathbf {a}$ 和 $\mathbf {b}$ 所在平面的法线向量，与 $\mathbf {a}$ 和 $\mathbf {b}$ 都垂直。叉积被广泛运用于数学、物理、工程学、计算机科学领域。

定义：两个向量 $\mathbf {a}$ 和 $\mathbf {b}$ 的叉积仅在三维空间中有定义，写作 ${\displaystyle \mathbf {a} \times \mathbf {b} }$。在物理学中，叉积有时也被写成${\displaystyle \mathbf {a} \wedge \mathbf {b} }$，但在数学中 ${\displaystyle \mathbf {a} \wedge \mathbf {b} }$ 是外代数中的外积。

叉积 ${\displaystyle \mathbf {a} \times \mathbf {b} }$ 是与 $\mathbf {a}$ 和 $\mathbf {b}$ 都垂直的向量 $\mathbf {c}$ 。其方向由右手定则决定，模长等于以两个向量为边的平行四边形的面积。

![右手定则](https://huangwang.github.io/2019/01/05/%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF%E5%8F%89%E7%A7%AF%E5%8F%8A%E5%85%B6%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89/images/Right_hand_rule_cross_product.png)

叉积可以定义为：

$${\displaystyle \mathbf {a} \times \mathbf {b} =|\mathbf {a} ||\mathbf {b} |\sin(\theta )\ \mathbf {n} }$$

其中$\theta$ 表示 $\mathbf {a}$ 和 $\mathbf {b}$ 在它们所定义的平面上的夹角（ ${\displaystyle 0^{\circ }\leq \theta \leq 180^{\circ }}$）。 ${\displaystyle |\mathbf {a} |}$ 和 ${\displaystyle |\mathbf {b} |}$ 是向量$\mathbf {a}$ 和 $\mathbf {b}$ 的模长，而 $\mathbf{n}$ 则是一个与 $\mathbf {a}$ 、 $\mathbf {b}$ 所构成的平面垂直的单位向量，方向由右手定则决定。根据上述公式，当$\mathbf {a}$ 与 $\mathbf {b}$ 平行（即 $\theta$ 为 0° 或 180°）时，它们的叉积为零向量 $\mathbf{0}$。

The second form of multiplication vector math defines is the cross product. Unlike the dot product, which evaluates to a scalar, the cross product evaluates to another vector;

moreover, the cross product is only defined for 3D vectors (in particular, there is no 2D cross product). Taking the cross product of two 3D vectors u and v yields another vector, w that is mutually orthogonal to u and v. By that we mean w is orthogonal to u, and w is orthogonal to v; see Figure 1.13. If $u = (u_x, u_y, u_z)$ and $v = (v_x, v_y,v_z)$, then the cross product
is computed like so:
$$w= u \times v=(u_{y}v_{z}-u_{z}v_{y},u_{z}v_{x}-u_{x}v_{z},u_{x}v_{y}-u_{y}v_{x})$$

结果w是与w，v正交。 w的方向遵从左手法则。take your left hand and aim the
fingers in the direction of the first vector u, and then curl your fingers toward v along an angle 0 ≤ θ ≤ π , then your thumb roughly points in the direction of w

# glm/eigen几何变换

[eigen几何变换举例](http://eigen.tuxfamily.org/dox/group__TutorialGeometry.html) 

以下代码涉及头文件如下：

```c++
#include <Eigen/Geometry>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
```

## 位移（平移）操作

```c++
TEST(computationalgeometry, translate)
{
  //  trans 是位移变换矩阵
  //  vec = trans  * vec

  // glm
  glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f); // 增加齐次
  glm::mat4 trans = glm::mat4(1.0f);
  trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));
  vec = trans * vec;
  ASSERT_EQ(vec.x == 2 && vec.y == 1 && vec.z == 0, true);

  //eigen
  Eigen::Vector3f vec_eigen;
  vec_eigen << 1.0f, 0.0f, 0.0f;
  Eigen::Translation3f trans_eigen(1.0f, 1.0f, 0.0f);
  vec_eigen = trans_eigen * vec_eigen;
  ASSERT_EQ(vec_eigen[0] == 2 && vec_eigen[1] == 1 && vec_eigen[2] == 0, true);
  // 2 1 0
}
```

## Z轴旋转

```c++
TEST(computationalgeometry, rotation_z)
{
  //  trans 是旋转变换矩阵， 当角度为正时是逆时针旋转
  //  vec = trans  * vec

  //glm
  glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f); // 增加齐次
  glm::mat4 trans = glm::mat4(1.0f);
  trans = glm::rotate(trans, glm::radians(45.0f), glm::vec3(0.0, 0.0, 1.0)); // 以z轴逆时针旋转45度
  vec = trans * vec;
  ASSERT_EQ(vec.x == vec.y && vec.z == 0, true);

  //eigen
  Eigen::Vector3f vec_eigen;
  vec_eigen << 1.0f, 0.0f, 0.0f;
  Eigen::AngleAxisf trans_eigen(M_PI / 4.0, Eigen::Vector3f::UnitZ()); //等同Eigen::Vector3f(0, 0, 1)
  vec_eigen = trans_eigen * vec_eigen;
  ASSERT_EQ(vec_eigen.x() == vec_eigen.y() && vec_eigen.z() == 0, true);
  // std::cout << "x:" <<vec_eigen.x() << ",y:"<< vec_eigen.y() << ",z:"<< vec_eigen.z() << std::endl;
}
```

## 缩放

```c++
TEST(computationalgeometry, scale)
{
  //glm
  glm::vec4 vec(1.0f, 1.0f, 1.0f, 1.0f); // 增加齐次
  glm::mat4 trans = glm::mat4(1.0f);
  trans = glm::scale(trans, glm::vec3(0.5, 0.2, 0.7));
  vec = trans * vec;
  // std::cout << "--x:" << vec.x << ",y:" << vec.y << ",z:" << vec.z << std::endl;
  ASSERT_EQ(vec.x == 0.5f && vec.y == 0.2f && vec.z == 0.7f, true);

  //eigen
  Eigen::Vector3f vec_eigen;
  vec_eigen << 1.0f, 1.0f, 1.0f;
  vec_eigen = Eigen::Scaling(0.5f, 0.2f, 0.7f) * vec_eigen;
  // std::cout << "x:" << vec_eigen.x() << ",y:" << vec_eigen.y() << ",z:" << vec_eigen.z() << std::endl;
  ASSERT_EQ(vec_eigen.x() == 0.5f && vec_eigen.y() == 0.2f && vec_eigen.z() == 0.7f, true);
}
```

## 缩放+旋转

```c++
TEST(computationalgeometry, scale_then_rotation)
{
  //  这里注意glm写法时两个变换的顺序

  //  trans 是旋转变换矩阵， 当角度为正时是逆时针旋转
  //  vec = trans * (scaling * vec)

  //glm
  glm::vec4 vec(1.0f, 0.7f, 1.0f, 1.0f); // 增加齐次
  glm::mat4 trans = glm::mat4(1.0f);
  trans = glm::rotate(trans, glm::radians(45.0f), glm::vec3(0.0, 0.0, 1.0)); // 以z轴逆时针旋转45度
  trans = glm::scale(trans, glm::vec3(0.5f, 0.2f, 0.7f));
  vec = trans * vec;
  std::cout << "--x:" << vec.x << ",y:" << vec.y << ",z:" << vec.z << std::endl;

  // 等价于下面
  //eigen
  Eigen::Vector3f vec_eigen;
  vec_eigen << 1.0f, 0.7f, 1.0f;
  Eigen::AngleAxisf trans_eigen(M_PI / 4.0, Eigen::Vector3f::UnitZ()); //等同Eigen::Vector3f(0, 0, 1)
  vec_eigen = (trans_eigen * Eigen::Scaling(0.5f, 0.2f, 0.7f)) * vec_eigen;
  std::cout << "x:" << vec_eigen.x() << ",y:" << vec_eigen.y() << ",z:" << vec_eigen.z() << std::endl;
}
```




# 开源几何计算数学库

## DirectXMath

To use the DirectX Math library, you need to #include <DirectXMath.h>, and
for some additional data types #include <DirectXPackedVector.h>. There are
no additional library files, as all the code is implemented inline in the header file.

In addition, for the x86 platform you should enable SSE2 (Project Properties > Configuration Properties >C/C++ > Code Generation > Enable Enhanced Instruction Set), and for all platforms you should enable the fast floating point model /fp:fast (Project Properties >Configuration Properties > C/C++ > Code Generation > Floating Point Model). You do not need to enable SSE2 for the x64 platform because all x64 CPUs support SSE2 (http://en.wikipedia.org/wiki/SSE2).

To summarize,
- 1. Use XMVECTOR for local or global variables.
- 2. Use XMFLOAT2, XMFLOAT3, and XMFLOAT4 for class data members.
- 3. Use loading functions to convert from XMFLOATn to XMVECTOR before doing calculations.
- 4. Do calculations with XMVECTOR instances.
- 5. Use storage functions to convert from XMVECTOR to XMFLOATn.



## a) Geos

Geos的全称就是Geometry Engine Open Source，参考网站就是：http://geos.refractions.net，从名称就可以看出，Geos就是判断几何体的过程。

Geos是用C++语言写的处理计算几何的开源库。

## b) CGAL

CGAL的全称就是Computational Geometry Algorithms Library，参考网站就是：http://www.cgal.org ，从名称就可以看出，CGAL就是计算几何的开源库。

CGAL是用C++语言写的计算几何最经典的开源库，

安装之前，系统预先安装：
```shell
sudo apt-get install mesa-common-dev
sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev
```

## c) LEDA

LEDA的全称就是Library of Efficient Data types and Algorithms，参考网站就是：http://www.algorithmic-solutions.com/，从名称就可以看出。

LEDA的是用C++语言写的关于数据类型和算法经典的开源库，

## d) Wykobi

Wykobi就是指的是Wykobi Computational Geometry Library ，参考网站就是：http://www.wykobi.com ，这个用C++语言实现的开源库，功能比较全，但是实现思想比较传统，也是比较简单。可以作为研究用，但是作为项目参考意义就不是很大。

# 游戏
